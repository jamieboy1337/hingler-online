/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EPSILON\": () => (/* binding */ EPSILON),\n/* harmony export */   \"ARRAY_TYPE\": () => (/* binding */ ARRAY_TYPE),\n/* harmony export */   \"RANDOM\": () => (/* binding */ RANDOM),\n/* harmony export */   \"setMatrixArrayType\": () => (/* binding */ setMatrixArrayType),\n/* harmony export */   \"toRadian\": () => (/* binding */ toRadian),\n/* harmony export */   \"equals\": () => (/* binding */ equals)\n/* harmony export */ });\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/common.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"glMatrix\": () => (/* reexport module object */ _common_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"mat2\": () => (/* reexport module object */ _mat2_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   \"mat2d\": () => (/* reexport module object */ _mat2d_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   \"mat3\": () => (/* reexport module object */ _mat3_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   \"mat4\": () => (/* reexport module object */ _mat4_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   \"quat\": () => (/* reexport module object */ _quat_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   \"quat2\": () => (/* reexport module object */ _quat2_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   \"vec2\": () => (/* reexport module object */ _vec2_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   \"vec3\": () => (/* reexport module object */ _vec3_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   \"vec4\": () => (/* reexport module object */ _vec4_js__WEBPACK_IMPORTED_MODULE_9__)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ \"./node_modules/gl-matrix/esm/mat2.js\");\n/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ \"./node_modules/gl-matrix/esm/mat2d.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ \"./node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ \"./node_modules/gl-matrix/esm/quat2.js\");\n/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ \"./node_modules/gl-matrix/esm/vec2.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/esm/vec4.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/index.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"LDU\": () => (/* binding */ LDU),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"sub\": () => (/* binding */ sub)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\n\nfunction fromValues(m00, m01, m10, m11) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\n\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2\n *\n * @param {ReadonlyMat2} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2\n *\n * @param {ReadonlyMat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {ReadonlyMat2} L the lower triangular matrix\n * @param {ReadonlyMat2} D the diagonal matrix\n * @param {ReadonlyMat2} U the upper triangular matrix\n * @param {ReadonlyMat2} a the input matrix to factorize\n */\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/mat2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"sub\": () => (/* binding */ sub)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 2x3 Matrix\n * @module mat2d\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b,\n *  c, d,\n *  tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\n\nfunction fromValues(a, b, c, d, tx, ty) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\n\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nfunction invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\n\nfunction translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2d} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat2d} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2d\n *\n * @param {ReadonlyMat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat2d(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/mat2d.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"fromMat4\": () => (/* binding */ fromMat4),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromMat2d\": () => (/* binding */ fromMat2d),\n/* harmony export */   \"fromQuat\": () => (/* binding */ fromQuat),\n/* harmony export */   \"normalFromMat4\": () => (/* binding */ normalFromMat4),\n/* harmony export */   \"projection\": () => (/* binding */ projection),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"sub\": () => (/* binding */ sub)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/mat3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromXRotation\": () => (/* binding */ fromXRotation),\n/* harmony export */   \"fromYRotation\": () => (/* binding */ fromYRotation),\n/* harmony export */   \"fromZRotation\": () => (/* binding */ fromZRotation),\n/* harmony export */   \"fromRotationTranslation\": () => (/* binding */ fromRotationTranslation),\n/* harmony export */   \"fromQuat2\": () => (/* binding */ fromQuat2),\n/* harmony export */   \"getTranslation\": () => (/* binding */ getTranslation),\n/* harmony export */   \"getScaling\": () => (/* binding */ getScaling),\n/* harmony export */   \"getRotation\": () => (/* binding */ getRotation),\n/* harmony export */   \"fromRotationTranslationScale\": () => (/* binding */ fromRotationTranslationScale),\n/* harmony export */   \"fromRotationTranslationScaleOrigin\": () => (/* binding */ fromRotationTranslationScaleOrigin),\n/* harmony export */   \"fromQuat\": () => (/* binding */ fromQuat),\n/* harmony export */   \"frustum\": () => (/* binding */ frustum),\n/* harmony export */   \"perspectiveNO\": () => (/* binding */ perspectiveNO),\n/* harmony export */   \"perspective\": () => (/* binding */ perspective),\n/* harmony export */   \"perspectiveZO\": () => (/* binding */ perspectiveZO),\n/* harmony export */   \"perspectiveFromFieldOfView\": () => (/* binding */ perspectiveFromFieldOfView),\n/* harmony export */   \"orthoNO\": () => (/* binding */ orthoNO),\n/* harmony export */   \"ortho\": () => (/* binding */ ortho),\n/* harmony export */   \"orthoZO\": () => (/* binding */ orthoZO),\n/* harmony export */   \"lookAt\": () => (/* binding */ lookAt),\n/* harmony export */   \"targetTo\": () => (/* binding */ targetTo),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"sub\": () => (/* binding */ sub)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/mat4.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"setAxisAngle\": () => (/* binding */ setAxisAngle),\n/* harmony export */   \"getAxisAngle\": () => (/* binding */ getAxisAngle),\n/* harmony export */   \"getAngle\": () => (/* binding */ getAngle),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"calculateW\": () => (/* binding */ calculateW),\n/* harmony export */   \"exp\": () => (/* binding */ exp),\n/* harmony export */   \"ln\": () => (/* binding */ ln),\n/* harmony export */   \"pow\": () => (/* binding */ pow),\n/* harmony export */   \"slerp\": () => (/* binding */ slerp),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"conjugate\": () => (/* binding */ conjugate),\n/* harmony export */   \"fromMat3\": () => (/* binding */ fromMat3),\n/* harmony export */   \"fromEuler\": () => (/* binding */ fromEuler),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"rotationTo\": () => (/* binding */ rotationTo),\n/* harmony export */   \"sqlerp\": () => (/* binding */ sqlerp),\n/* harmony export */   \"setAxes\": () => (/* binding */ setAxes)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/esm/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/esm/vec4.js\");\n\n\n\n\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nfunction getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nfunction getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nfunction exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nfunction ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nfunction pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nfunction fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nvar clone = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nvar fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nvar copy = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nvar set = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nvar add = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nvar scale = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nvar dot = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nvar lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nvar length = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nvar len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nvar squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nvar normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nvar exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nvar equals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nvar rotationTo = function () {\n  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();\n  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);\n  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);\n\n    if (dot < -0.999999) {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nvar sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nvar setAxes = function () {\n  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_3__.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/quat.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"fromRotationTranslationValues\": () => (/* binding */ fromRotationTranslationValues),\n/* harmony export */   \"fromRotationTranslation\": () => (/* binding */ fromRotationTranslation),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromMat4\": () => (/* binding */ fromMat4),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"getReal\": () => (/* binding */ getReal),\n/* harmony export */   \"getDual\": () => (/* binding */ getDual),\n/* harmony export */   \"setReal\": () => (/* binding */ setReal),\n/* harmony export */   \"setDual\": () => (/* binding */ setDual),\n/* harmony export */   \"getTranslation\": () => (/* binding */ getTranslation),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"rotateByQuatAppend\": () => (/* binding */ rotateByQuatAppend),\n/* harmony export */   \"rotateByQuatPrepend\": () => (/* binding */ rotateByQuatPrepend),\n/* harmony export */   \"rotateAroundAxis\": () => (/* binding */ rotateAroundAxis),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"conjugate\": () => (/* binding */ conjugate),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ \"./node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ \"./node_modules/gl-matrix/esm/mat4.js\");\n\n\n\n/**\n * Dual Quaternion<br>\n * Format: [real, dual]<br>\n * Quaternion format: XYZW<br>\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\n * @module quat2\n */\n\n/**\n * Creates a new identity dual quat\n *\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\n */\n\nfunction create() {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n\n  dq[3] = 1;\n  return dq;\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat2} a dual quaternion to clone\n * @returns {quat2} new dual quaternion\n * @function\n */\n\nfunction clone(a) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n/**\n * Creates a new dual quat initialized with the given values\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} new dual quaternion\n * @function\n */\n\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n/**\n * Creates a new dual quat from the given values (quat and translation)\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component (translation)\n * @param {Number} y2 Y component (translation)\n * @param {Number} z2 Z component (translation)\n * @returns {quat2} new dual quaternion\n * @function\n */\n\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n/**\n * Creates a dual quat from a quaternion and a translation\n *\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\n * @param {ReadonlyQuat} q a normalized quaternion\n * @param {ReadonlyVec3} t tranlation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\n\nfunction fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Creates a dual quat from a translation\n *\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\n * @param {ReadonlyVec3} t translation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\n\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n/**\n * Creates a dual quat from a quaternion\n *\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\n * @param {ReadonlyQuat} q the quaternion\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\n\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\n * Creates a new dual quat from a matrix (4x4)\n *\n * @param {quat2} out the dual quaternion\n * @param {ReadonlyMat4} a the matrix\n * @returns {quat2} dual quat receiving operation result\n * @function\n */\n\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__.create();\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getRotation(outer, a);\n  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getTranslation(t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n/**\n * Copy the values from one dual quat to another\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the source dual quaternion\n * @returns {quat2} out\n * @function\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\n * Set a dual quat to the identity dual quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @returns {quat2} out\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\n * Set the components of a dual quat to the given values\n *\n * @param {quat2} out the receiving quaternion\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} out\n * @function\n */\n\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n/**\n * Gets the real part of a dual quat\n * @param  {quat} out real part\n * @param  {ReadonlyQuat2} a Dual Quaternion\n * @return {quat} real part\n */\n\nvar getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;\n/**\n * Gets the dual part of a dual quat\n * @param  {quat} out dual part\n * @param  {ReadonlyQuat2} a Dual Quaternion\n * @return {quat} dual part\n */\n\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n/**\n * Set the real component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat} q a quaternion representing the real part\n * @returns {quat2} out\n * @function\n */\n\nvar setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;\n/**\n * Set the dual component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat} q a quaternion representing the dual part\n * @returns {quat2} out\n * @function\n */\n\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n/**\n * Gets the translation of a normalized dual quat\n * @param  {vec3} out translation\n * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed\n * @return {vec3} translation\n */\n\nfunction getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n/**\n * Translates a dual quat by the given vector\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {quat2} out\n */\n\nfunction translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n/**\n * Rotates a dual quat around the X axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\n\nfunction rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateX(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\n * Rotates a dual quat around the Y axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\n\nfunction rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateY(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\n * Rotates a dual quat around the Z axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateZ(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\n * Rotates a dual quat by a given quaternion (a * q)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {ReadonlyQuat} q quaternion to rotate by\n * @returns {quat2} out\n */\n\nfunction rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n/**\n * Rotates a dual quat by a given quaternion (q * a)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat} q quaternion to rotate by\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @returns {quat2} out\n */\n\nfunction rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n/**\n * Rotates a dual quat around a given axis. Does the normalisation automatically\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @param {Number} rad how far the rotation should be\n * @returns {quat2} out\n */\n\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return copy(out, a);\n  }\n\n  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Adds two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {quat2} out\n * @function\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n/**\n * Multiplies two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {quat2} out\n */\n\nfunction multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n/**\n * Alias for {@link quat2.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Scales a dual quat by a scalar number\n *\n * @param {quat2} out the receiving dual quat\n * @param {ReadonlyQuat2} a the dual quat to scale\n * @param {Number} b amount to scale the dual quat by\n * @returns {quat2} out\n * @function\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n/**\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\n *\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nvar dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__.dot;\n/**\n * Performs a linear interpolation between two dual quats's\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\n *\n * @param {quat2} out the receiving dual quat\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat2} out\n */\n\nfunction lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n  return out;\n}\n/**\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a dual quat to calculate inverse of\n * @returns {quat2} out\n */\n\nfunction invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n/**\n * Calculates the conjugate of a dual quat\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat2} a quat to calculate conjugate of\n * @returns {quat2} out\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\n * Calculates the length of a dual quat\n *\n * @param {ReadonlyQuat2} a dual quat to calculate length of\n * @returns {Number} length of a\n * @function\n */\n\nvar length = _quat_js__WEBPACK_IMPORTED_MODULE_1__.length;\n/**\n * Alias for {@link quat2.length}\n * @function\n */\n\nvar len = length;\n/**\n * Calculates the squared length of a dual quat\n *\n * @param {ReadonlyQuat2} a dual quat to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nvar squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;\n/**\n * Alias for {@link quat2.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Normalize a dual quat\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a dual quaternion to normalize\n * @returns {quat2} out\n * @function\n */\n\nfunction normalize(out, a) {\n  var magnitude = squaredLength(a);\n\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    var a0 = a[0] / magnitude;\n    var a1 = a[1] / magnitude;\n    var a2 = a[2] / magnitude;\n    var a3 = a[3] / magnitude;\n    var b0 = a[4];\n    var b1 = a[5];\n    var b2 = a[6];\n    var b3 = a[7];\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\n  }\n\n  return out;\n}\n/**\n * Returns a string representation of a dual quatenion\n *\n * @param {ReadonlyQuat2} a dual quaternion to represent as a string\n * @returns {String} string representation of the dual quat\n */\n\nfunction str(a) {\n  return \"quat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \")\";\n}\n/**\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat2} a the first dual quaternion.\n * @param {ReadonlyQuat2} b the second dual quaternion.\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n/**\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat2} a the first dual quat.\n * @param {ReadonlyQuat2} b the second dual quat.\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/quat2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"transformMat2\": () => (/* binding */ transformMat2),\n/* harmony export */   \"transformMat2d\": () => (/* binding */ transformMat2d),\n/* harmony export */   \"transformMat3\": () => (/* binding */ transformMat3),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"angle\": () => (/* binding */ angle),\n/* harmony export */   \"zero\": () => (/* binding */ zero),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nfunction fromValues(x, y) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nfunction rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/vec2.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"hermite\": () => (/* binding */ hermite),\n/* harmony export */   \"bezier\": () => (/* binding */ bezier),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"transformMat3\": () => (/* binding */ transformMat3),\n/* harmony export */   \"transformQuat\": () => (/* binding */ transformQuat),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"angle\": () => (/* binding */ angle),\n/* harmony export */   \"zero\": () => (/* binding */ zero),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction fromValues(x, y, z) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/vec3.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"transformQuat\": () => (/* binding */ transformQuat),\n/* harmony export */   \"zero\": () => (/* binding */ zero),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nfunction fromValues(x, y, z, w) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://hingler-online/./node_modules/gl-matrix/esm/vec4.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/animation/KeyframeList.js":
/*!******************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/animation/KeyframeList.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyframeList = void 0;\n// samplers will contain keyframelists\n// will probably use curves to store t values, then interpolate based on them\nclass KeyframeList {\n    constructor() {\n        this.keyframeList = [];\n    }\n    /**\n     * Inserts a new keyframe into this sampler.\n     * @param time - the time at which to place the keyframe.\n     * @param data - the data to insert.\n     * @returns an instance of T if an old keyframe overlapped with the insertion time, and was thus removed.\n     *          otherwise, undefined.\n     */\n    insert(time, data) {\n        for (let i = 0; i < this.keyframeList.length; i++) {\n            // close enough to overlap\n            if (Math.abs(this.keyframeList[i].time - time) < 0.0001) {\n                const oldValue = this.keyframeList[i].value;\n                this.keyframeList[i].value = data;\n                return oldValue;\n            }\n        }\n        this.keyframeList.push({ \"time\": time, value: data });\n        this.keyframeList.sort((a, b) => a.time - b.time);\n    }\n    /**\n     * @returns a list of all keyframes currently managed by this keyframe list.\n     */\n    getKeyframes() {\n        return this.keyframeList;\n    }\n    getKeyframe(index) {\n        if (this.keyframeList.length <= index || index < 0) {\n            return null;\n        }\n        return this.keyframeList[index];\n    }\n    deleteKeyframe(index) {\n        if (index >= 0 && index < this.keyframeList.length) {\n            const res = this.keyframeList[index];\n            this.keyframeList = this.keyframeList.splice(index, 1);\n            return res.value;\n        }\n        return null;\n    }\n    get length() {\n        return this.keyframeList.length;\n    }\n}\nexports.KeyframeList = KeyframeList;\n// samplers will wrap this\n// and use their own curve algo to fit it\n// actually would make sense to have a simple \"interpolator\" class\n// then we could just plug in that interpolator to a generic thing and be good\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/animation/KeyframeList.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/animation/interpolater/LerpVector.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/animation/interpolater/LerpVector.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LerpVector = void 0;\nclass LerpVector {\n    static interpolate(out, a, b, time) {\n        const aTime = 1.0 - time;\n        for (let i = 0; i < a.length; i++) {\n            out[i] = a[i] * aTime + b[i] * time;\n        }\n        return out;\n    }\n    static copy(out, input) {\n        for (let i = 0; i < input.length; i++) {\n            out[i] = input[i];\n        }\n        return out;\n    }\n}\nexports.LerpVector = LerpVector;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/animation/interpolater/LerpVector.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/animation/samplers/LinearBaseSampler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/animation/samplers/LinearBaseSampler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinearBaseSampler = void 0;\nconst KeyframeList_1 = __webpack_require__(/*! ../KeyframeList */ \"./node_modules/nekogirl-valhalla/animation/KeyframeList.js\");\n// factor out into a base, which always accepts a linear sampler?\n// from there: we could support pretty much everything!\nclass LinearBaseSampler {\n    constructor(customInterpolationMethod, copyMethod) {\n        this.keyframeList = new KeyframeList_1.KeyframeList();\n        this.interpMethod = customInterpolationMethod;\n        this.copyMethod = copyMethod;\n    }\n    sample(time, out) {\n        if (this.keyframeList.length <= 0) {\n            return null;\n        }\n        else if (this.keyframeList.length === 1) {\n            const val = this.keyframeList.getKeyframe(0);\n            out = this.copyMethod(out, val.value);\n        }\n        else {\n            let i;\n            let res;\n            for (i = 0; i < this.keyframeList.length; i++) {\n                if (this.keyframeList.getKeyframe(i).time > time) {\n                    break;\n                }\n            }\n            if (i === 0 || i === this.keyframeList.length) {\n                res = this.keyframeList.getKeyframe(Math.max(i - 1, 0)).value;\n                out = this.copyMethod(out, res);\n            }\n            else {\n                // interpolate\n                const keyFloor = this.keyframeList.getKeyframe(i - 1);\n                const keyCeil = this.keyframeList.getKeyframe(i);\n                const localTime = (time - keyFloor.time) / (keyCeil.time - keyFloor.time);\n                out = this.interpMethod(out, keyFloor.value, keyCeil.value, localTime);\n            }\n        }\n        return out;\n    }\n    insert(time, value) {\n        return this.keyframeList.insert(time, value);\n    }\n    delete(index) {\n        return this.keyframeList.deleteKeyframe(index);\n    }\n    getKeyframeList() {\n        return this.keyframeList.getKeyframes();\n    }\n}\nexports.LinearBaseSampler = LinearBaseSampler;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/animation/samplers/LinearBaseSampler.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/animation/samplers/LinearQuatSampler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/animation/samplers/LinearQuatSampler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinearQuatSampler = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst LinearBaseSampler_1 = __webpack_require__(/*! ./LinearBaseSampler */ \"./node_modules/nekogirl-valhalla/animation/samplers/LinearBaseSampler.js\");\nclass LinearQuatSampler {\n    constructor() {\n        this.engine = new LinearBaseSampler_1.LinearBaseSampler(gl_matrix_1.quat.slerp, gl_matrix_1.quat.copy);\n    }\n    sample(time, out) {\n        return this.engine.sample(time, out);\n    }\n    insert(time, value) {\n        return this.engine.insert(time, value);\n    }\n    delete(index) {\n        return this.engine.delete(index);\n    }\n    getKeyframeList() {\n        return this.engine.getKeyframeList();\n    }\n}\nexports.LinearQuatSampler = LinearQuatSampler;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/animation/samplers/LinearQuatSampler.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/animation/samplers/LinearVectorSampler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/animation/samplers/LinearVectorSampler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinearVectorSampler = void 0;\nconst LerpVector_1 = __webpack_require__(/*! ../interpolater/LerpVector */ \"./node_modules/nekogirl-valhalla/animation/interpolater/LerpVector.js\");\nconst LinearBaseSampler_1 = __webpack_require__(/*! ./LinearBaseSampler */ \"./node_modules/nekogirl-valhalla/animation/samplers/LinearBaseSampler.js\");\n// factor out into a base, which always accepts a linear sampler?\n// from there: we could support pretty much everything!\nclass LinearVectorSampler {\n    constructor() {\n        this.sampler = new LinearBaseSampler_1.LinearBaseSampler(LerpVector_1.LerpVector.interpolate, LerpVector_1.LerpVector.copy);\n    }\n    sample(time, out) {\n        return this.sampler.sample(time, out);\n    }\n    insert(time, value) {\n        return this.sampler.insert(time, value);\n    }\n    delete(index) {\n        return this.sampler.delete(index);\n    }\n    getKeyframeList() {\n        return this.sampler.getKeyframeList();\n    }\n}\nexports.LinearVectorSampler = LinearVectorSampler;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/animation/samplers/LinearVectorSampler.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/array/RingArray.js":
/*!***********************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/array/RingArray.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RingArray = void 0;\nclass RingArrayIterator {\n    constructor(arr) {\n        this.arr = arr;\n        this.ind = 0;\n    }\n    next() {\n        if (this.ind >= this.arr.length) {\n            return {\n                value: null,\n                done: true\n            };\n        }\n        else {\n            const res = this.arr.get(this.ind++);\n            return {\n                value: res,\n                done: false\n            };\n        }\n    }\n}\nclass RingArray {\n    constructor(len) {\n        this.elements = new Array(len);\n        this.capacity = len;\n        this.size = 0;\n        this.offset = 0;\n    }\n    get length() {\n        return this.size;\n    }\n    [Symbol.iterator]() {\n        return new RingArrayIterator(this);\n    }\n    /**\n     * Pushes the passed item onto the end of the array.\n     */\n    push(item) {\n        if (this.size >= this.elements.length) {\n            throw Error(\"Exceeded ringbuffer capacity\");\n        }\n        this.elements[(this.offset + this.size++) % this.elements.length] = item;\n    }\n    /**\n     * Pops the last item off the array.\n     */\n    pop() {\n        if (this.size <= 0) {\n            return undefined;\n        }\n        return this.elements[(this.offset + --this.size) % this.elements.length];\n    }\n    /**\n     *  Prepends the passed item.\n     */\n    enqueue(item) {\n        if (this.size >= this.elements.length) {\n            throw Error(\"Exceeded Ringbuffer Capacity!\");\n        }\n        // scoot back 1\n        this.offset = (this.offset + this.elements.length - 1) % this.elements.length;\n        this.size++;\n        this.elements[this.offset] = item;\n    }\n    /**\n     * Removes and returns the first item in the array.\n     */\n    dequeue() {\n        const res = this.elements[this.offset];\n        this.offset = (this.offset + 1) % this.elements.length;\n        this.size--;\n        return res;\n    }\n    get(ind) {\n        if (ind >= this.size || ind < 0) {\n            return undefined;\n        }\n        return this.elements[(this.offset + ind) % this.elements.length];\n    }\n    set(ind, val) {\n        if (ind >= this.size || ind < 0) {\n            throw Error(\"Attempted to set value which is OOB\");\n        }\n        this.elements[(this.offset + ind) % this.elements.length] = val;\n    }\n    remove(ind) {\n        if (ind < 0 || ind >= this.size) {\n            return null;\n        }\n        if (ind * 2 < this.size) {\n            return this.removeSlideStart(ind);\n        }\n        else {\n            return this.removeSlideEnd(ind);\n        }\n    }\n    removeSlideStart(ind) {\n        const res = this.get(ind);\n        for (let i = ind; i > 0; i--) {\n            this.elements[(this.offset + i) % this.elements.length] = this.elements[(this.offset + i - 1) % this.elements.length];\n        }\n        this.size--;\n        this.offset++;\n        return res;\n    }\n    removeSlideEnd(ind) {\n        const res = this.get(ind);\n        for (let i = ind + 1; i < this.size; i++) {\n            this.elements[(this.offset + i - 1) % this.elements.length] = this.elements[(this.offset + i) % this.elements.length];\n        }\n        this.size--;\n        return res;\n    }\n    clear() {\n        this.offset = 0;\n        this.size = 0;\n    }\n}\nexports.RingArray = RingArray;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/array/RingArray.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/buffer/ReadWriteBuffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/buffer/ReadWriteBuffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadWriteBuffer = void 0;\n// todo: add some model-oriented wrappers here which contain attribute data\n// that way we can pick it up seamlessly on the engine's end!\nclass ReadWriteBuffer {\n    constructor(buffer) {\n        if (typeof buffer === \"number\") {\n            this.buf = new ArrayBuffer(buffer);\n        }\n        else if (buffer) {\n            // copy lole\n            // TODO: copy lole\n            this.buf = new ArrayBuffer(buffer.byteLength);\n            new Uint8Array(this.buf).set(new Uint8Array(buffer), 0);\n        }\n        else {\n            this.buf = new ArrayBuffer(16);\n        }\n        this.view = new DataView(this.buf);\n        this.size_ = 0;\n        this.versionnum_ = 0;\n    }\n    ensureInBounds(offset) {\n        const SIZE_MAX = 1073741824;\n        if (this.buf.byteLength <= offset) {\n            let bufNew = new ArrayBuffer(Math.min(offset * 2, SIZE_MAX));\n            if (offset > SIZE_MAX) {\n                throw Error(\"Too much space reserved for array buffer :sade:\");\n            }\n            new Uint8Array(bufNew).set(new Uint8Array(this.buf), 0);\n            this.buf = bufNew;\n            this.view = new DataView(this.buf);\n        }\n        if (offset >= this.size_) {\n            // writing a byte to 0 should equate to 1 byte\n            this.size_ = (offset + 1);\n        }\n        this.versionnum_++;\n    }\n    get versionnum() {\n        return this.versionnum_;\n    }\n    getInt8(offset) {\n        return this.view.getInt8(offset);\n    }\n    getUint8(offset) {\n        return this.view.getUint8(offset);\n    }\n    getInt16(offset, littleEndian) {\n        return this.view.getInt16(offset, littleEndian);\n    }\n    getUint16(offset, littleEndian) {\n        return this.view.getUint16(offset, littleEndian);\n    }\n    getInt32(offset, littleEndian) {\n        return this.view.getInt32(offset, littleEndian);\n    }\n    getUint32(offset, littleEndian) {\n        return this.view.getUint32(offset, littleEndian);\n    }\n    getFloat32(offset, littleEndian) {\n        return this.view.getFloat32(offset, littleEndian);\n    }\n    getFloat32Array(offset, num) {\n        return new Float32Array(this.buf, offset, num);\n    }\n    setInt8(offset, value) {\n        this.ensureInBounds(offset);\n        this.view.setInt8(offset, value);\n    }\n    setUint8(offset, value) {\n        this.ensureInBounds(offset);\n        this.view.setUint8(offset, value);\n    }\n    setInt16(offset, value, littleEndian) {\n        this.ensureInBounds(offset + 1);\n        this.view.setInt16(offset, value, littleEndian);\n    }\n    setUint16(offset, value, littleEndian) {\n        this.ensureInBounds(offset + 1);\n        this.view.setUint16(offset, value, littleEndian);\n    }\n    setInt32(offset, value, littleEndian) {\n        this.ensureInBounds(offset + 3);\n        this.view.setInt32(offset, value, littleEndian);\n    }\n    setUint32(offset, value, littleEndian) {\n        this.ensureInBounds(offset + 3);\n        this.view.setUint32(offset, value, littleEndian);\n    }\n    setFloat32(offset, value, littleEndian) {\n        this.ensureInBounds(offset + 3);\n        this.view.setFloat32(offset, value, littleEndian);\n    }\n    setFloatArray(offset, arr, littleEndian) {\n        this.ensureInBounds(offset + (4 * arr.length));\n        let farr = new Float32Array(this.buf, offset, arr.length);\n        farr.set(arr);\n    }\n    getRegionAsUint16Array(offset, length) {\n        this.ensureInBounds(offset + (2 * length) - 1);\n        return new Uint16Array(this.buf, offset, length);\n    }\n    getRegionAsFloat32Array(offset, length) {\n        this.ensureInBounds(offset + 4 * length - 1);\n        return new Float32Array(this.buf, offset, length);\n    }\n    invalidate() {\n        this.versionnum_++;\n    }\n    size() {\n        return this.size_;\n    }\n    capacity() {\n        return this.buf.byteLength;\n    }\n    arrayBuffer() {\n        return this.buf;\n    }\n    copy() {\n        return new ReadWriteBuffer(this.buf);\n    }\n}\nexports.ReadWriteBuffer = ReadWriteBuffer;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/buffer/ReadWriteBuffer.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/map/LRUMap.js":
/*!******************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/map/LRUMap.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// iterable\n// update entries if pulled\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LRUMap = void 0;\nconst RingArray_1 = __webpack_require__(/*! ../array/RingArray */ \"./node_modules/nekogirl-valhalla/array/RingArray.js\");\nclass LRUMap {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.keyList = new RingArray_1.RingArray(capacity);\n        this.entries = new Map();\n    }\n    get size() {\n        return this.keyList.length;\n    }\n    /**\n     * Inserts a new entry into the LRUCache.\n     * @param key - the key being inserted.\n     * @param val - the value associated with that key.\n     * @returns the last evicted value, if one was evicted.\n     */\n    insert(key, val) {\n        // check if k is already in the keylist\n        // if so, just update our value\n        if (this.entries.has(key)) {\n            for (let i = 0; i < this.keyList.length; i++) {\n                if (key === this.keyList.get(i)) {\n                    const old = this.entries.get(key);\n                    this.entries.set(key, val);\n                    this.keyList.remove(i);\n                    this.keyList.enqueue(key);\n                    return old;\n                }\n            }\n        }\n        // not already present\n        let ret = null;\n        if (this.keyList.length >= this.capacity) {\n            ret = this.evict();\n        }\n        this.keyList.enqueue(key);\n        this.entries.set(key, val);\n        return ret;\n    }\n    get(key) {\n        if (this.entries.has(key)) {\n            return this.entries.get(key);\n        }\n        return null;\n    }\n    has(key) {\n        return this.entries.has(key);\n    }\n    /**\n     * Evicts the oldest entry currently stored, and returns its value.\n     */\n    evict() {\n        const outKey = this.keyList.pop();\n        const res = this.entries.get(outKey);\n        this.entries.delete(outKey);\n        return res;\n    }\n}\nexports.LRUMap = LRUMap;\n;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/map/LRUMap.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/model/AttributeType.js":
/*!***************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/model/AttributeType.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeType = void 0;\nvar AttributeType;\n(function (AttributeType) {\n    AttributeType[AttributeType[\"POSITION\"] = 0] = \"POSITION\";\n    AttributeType[AttributeType[\"NORMAL\"] = 1] = \"NORMAL\";\n    AttributeType[AttributeType[\"TEXCOORD\"] = 2] = \"TEXCOORD\";\n    AttributeType[AttributeType[\"JOINT\"] = 3] = \"JOINT\";\n    AttributeType[AttributeType[\"WEIGHT\"] = 4] = \"WEIGHT\";\n    AttributeType[AttributeType[\"TANGENT\"] = 5] = \"TANGENT\";\n})(AttributeType = exports.AttributeType || (exports.AttributeType = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/model/AttributeType.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/model/DataType.js":
/*!**********************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/model/DataType.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataType = void 0;\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"BYTE\"] = 5120] = \"BYTE\";\n    DataType[DataType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    DataType[DataType[\"SHORT\"] = 5122] = \"SHORT\";\n    DataType[DataType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    DataType[DataType[\"INT\"] = 5124] = \"INT\";\n    DataType[DataType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    DataType[DataType[\"FLOAT\"] = 5126] = \"FLOAT\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/model/DataType.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/model/GLModelSpec.js":
/*!*************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/model/GLModelSpec.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLModelSpec = void 0;\nconst DataType_1 = __webpack_require__(/*! ./DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\n/**\n * Wraps around a ReadWriteBuffer,\n * providing a specification for attributes which can be trivially\n * ported over to OpenGL\n */\nclass GLModelSpec {\n    constructor() {\n        this.attributeList = new Map();\n    }\n    static getByteSize(type) {\n        switch (type) {\n            case DataType_1.DataType.BYTE:\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                return 1;\n            case DataType_1.DataType.SHORT:\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                return 2;\n            case DataType_1.DataType.FLOAT:\n                return 4;\n            default:\n                let err = `Unknown component type: ${type}`;\n                console.warn(err);\n                throw Error(err);\n        }\n    }\n    // store buffers in a set\n    // \n    setAttribute(buffer, attrib, components, type, num, offset, stride) {\n        const data = {\n            \"buffer\": buffer,\n            \"components\": components,\n            \"type\": type,\n            \"count\": num,\n            \"offset\": (offset === undefined ? 0 : offset),\n            \"stride\": (stride === undefined ? 0 : stride)\n        };\n        this.attributeList.set(attrib, data);\n    }\n    setIndex(buffer, type, count, offset) {\n        const data = {\n            \"buffer\": buffer,\n            \"count\": count,\n            \"type\": type,\n            \"offset\": (offset ? offset : 0)\n        };\n        this.index = data;\n    }\n    getAttributes() {\n        return this.attributeList;\n    }\n    getIndex() {\n        return this.index;\n    }\n}\nexports.GLModelSpec = GLModelSpec;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/model/GLModelSpec.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/model/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/model/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLModelSpec = exports.DataType = exports.AttributeType = void 0;\nconst AttributeType_1 = __webpack_require__(/*! ./AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nObject.defineProperty(exports, \"AttributeType\", ({ enumerable: true, get: function () { return AttributeType_1.AttributeType; } }));\nconst DataType_1 = __webpack_require__(/*! ./DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\nObject.defineProperty(exports, \"DataType\", ({ enumerable: true, get: function () { return DataType_1.DataType; } }));\nconst GLModelSpec_1 = __webpack_require__(/*! ./GLModelSpec */ \"./node_modules/nekogirl-valhalla/model/GLModelSpec.js\");\nObject.defineProperty(exports, \"GLModelSpec\", ({ enumerable: true, get: function () { return GLModelSpec_1.GLModelSpec; } }));\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/model/index.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/object/IDGenerator.js":
/*!**************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/object/IDGenerator.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IDGenerator = void 0;\nclass IDGenerator {\n    constructor() {\n        this.idMin = 1;\n        this.idsInUse = new Set();\n    }\n    getNewID() {\n        while (this.idsInUse.has(this.idMin)) {\n            this.idsInUse.delete(this.idMin++);\n        }\n        return this.idMin++;\n    }\n    /**\n     * Determines if an ID is definitely unique.\n     * @param id - the ID being checked.\n     * @returns true if the ID is definitely unique, false otherwise.\n     *          Note that an ID which returns false may in fact be unique.\n     *          However, an ID which returns true is definitely unique.\n     */\n    isIDUnique(id) {\n        return (id >= this.idMin && !this.idsInUse.has(id));\n    }\n    /**\n     * Registers a new ID as used.\n     * @param id - the ID being registered.\n     */\n    registerNewID(id) {\n        if (id === this.idMin) {\n            this.idMin++;\n        }\n        else if (id > this.idMin) {\n            this.idsInUse.add(id);\n        }\n    }\n}\nexports.IDGenerator = IDGenerator;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/object/IDGenerator.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/object/NestableBase.js":
/*!***************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/object/NestableBase.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestableBase = void 0;\nclass NestableBase {\n    constructor(id) {\n        this.parent = null;\n        this.children = new Set();\n        this.id = id;\n    }\n    getChildren() {\n        return Array.from(this.children);\n    }\n    getParent() {\n        // ts freaks out but T \n        return this.parent;\n    }\n    findChild(id) {\n        let res = null;\n        for (let child of this.children) {\n            if (child.getId() === id) {\n                res = child;\n                break;\n            }\n        }\n        if (res === null) {\n            for (let child of this.children) {\n                res = child.getChild(id);\n            }\n        }\n        return res;\n    }\n    getChild(id) {\n        return this.findChild(id);\n    }\n    removeChild(id) {\n        if (id === this.id) {\n            return null;\n        }\n        for (let child of this.children) {\n            if (child.getId() === id) {\n                this.children.delete(child);\n                child.parent = null;\n                return child;\n            }\n        }\n        let child = this.findChild(id);\n        if (child) {\n            child.parent.removeChild(child.getId());\n            child.parent = null;\n        }\n        return child;\n    }\n    addChild(elem) {\n        if (elem.findChild(this.getId())) {\n            return false;\n        }\n        else {\n            if (elem.parent) {\n                elem.parent.removeChild(elem.getId());\n            }\n            // `this` is always a subtype of T\n            // crtp means T will inherit nestablebase<T>\n            elem.parent = this;\n            this.children.add(elem);\n            return true;\n        }\n    }\n    getId() {\n        return this.id;\n    }\n    setId(id) {\n        this.id = id;\n    }\n}\nexports.NestableBase = NestableBase;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/object/NestableBase.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/object/NestableComponent.js":
/*!********************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/object/NestableComponent.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestableComponent = void 0;\nclass NestableComponent {\n    constructor(id, self) {\n        this.parent = null;\n        this.children = new Set();\n        this.id = id;\n        this.self = self;\n    }\n    getChildren() {\n        const res = Array.from(this.children);\n        return res.map(a => a.self);\n    }\n    getParent() {\n        return (this.parent ? this.parent.self : null);\n    }\n    findChild(id) {\n        let res = null;\n        for (let child of this.children) {\n            if (child.getId() === id) {\n                res = child;\n                break;\n            }\n        }\n        if (res === null) {\n            for (let child of this.children) {\n                res = child.findChild(id);\n            }\n        }\n        return res;\n    }\n    getChild(id) {\n        return this.findChild(id).self;\n    }\n    removeChild(id) {\n        if (id === this.id) {\n            return null;\n        }\n        for (let child of this.children) {\n            if (child.getId() === id) {\n                this.children.delete(child);\n                child.parent = null;\n                return child.self;\n            }\n        }\n        let child = this.findChild(id);\n        if (child) {\n            child.parent.removeChild(child.getId());\n            child.parent = null;\n        }\n        return child.self;\n    }\n    addChild(elem) {\n        if (elem.findChild(this.getId())) {\n            return false;\n        }\n        else {\n            if (elem.parent) {\n                elem.parent.removeChild(elem.getId());\n            }\n            // `this` is always a subtype of T\n            // crtp means T will inherit nestablebase<T>\n            elem.parent = this;\n            this.children.add(elem);\n            return true;\n        }\n    }\n    getId() {\n        return this.id;\n    }\n    setId(id) {\n        this.id = id;\n    }\n}\nexports.NestableComponent = NestableComponent;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/object/NestableComponent.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/object/TransformableBase.js":
/*!********************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/object/TransformableBase.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransformableBase = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nclass TransformableBase {\n    constructor() {\n        this.rotation = gl_matrix_1.quat.identity(gl_matrix_1.quat.create());\n        this.position = gl_matrix_1.vec3.zero(gl_matrix_1.vec3.create());\n        this.scale = gl_matrix_1.vec3.set(gl_matrix_1.vec3.create(), 1, 1, 1);\n    }\n    getRotation() {\n        return this.rotation;\n    }\n    getPosition() {\n        return this.position;\n    }\n    getScale() {\n        return this.scale;\n    }\n    setRotationEuler(x, y, z) {\n        if (!(typeof x === \"number\") && x.length >= 3) {\n            this.setRotationEulerNum_(x[0], x[1], x[2]);\n        }\n        else if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\") {\n            this.setRotationEulerNum_(x, y, z);\n        }\n        else {\n            console.warn(\"Parameters to `setRotationEuler` cannot be interpreted.\");\n        }\n    }\n    setRotationEulerNum_(x, y, z) {\n        gl_matrix_1.quat.fromEuler(this.rotation, x, y, z);\n    }\n    setRotationQuat(x, y, z, w) {\n        if (!(typeof x === \"number\") && x.length >= 4) {\n            this.setQuatNum_(x[0], x[1], x[2], x[3]);\n        }\n        else if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\" && typeof w === \"number\") {\n            this.setQuatNum_(x, y, z, w);\n        }\n        else {\n            console.warn(\"Parameters to `setRotationQuat` cannot be interpreted.\");\n        }\n    }\n    setQuatNum_(x, y, z, w) {\n        this.rotation = gl_matrix_1.quat.fromValues(x, y, z, w);\n    }\n    setScale(x, y, z) {\n        if (!(typeof x === \"number\") && x.length >= 3) {\n            this.setScaleNum_(x[0], x[1], x[2]);\n        }\n        else if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\") {\n            this.setScaleNum_(x, y, z);\n        }\n        else {\n            console.warn(\"Parameters to `setScale` cannot be interpreted.\");\n            console.warn(x);\n        }\n    }\n    setScaleNum_(x, y, z) {\n        this.scale[0] = x;\n        this.scale[1] = y;\n        this.scale[2] = z;\n    }\n    setPosition(x, y, z) {\n        if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\") {\n            this.setPositionNum_(x, y, z);\n            // this is the best i can do i think\n        }\n        else if (!(typeof x === \"number\") && x.length >= 3) {\n            this.setPositionNum_(x[0], x[1], x[2]);\n        }\n        else {\n            console.warn(\"Parameters to `setPosition` cannot be interpreted.\");\n            console.error(x);\n        }\n    }\n    setPositionNum_(x, y, z) {\n        this.position[0] = x;\n        this.position[1] = y;\n        this.position[2] = z;\n    }\n}\nexports.TransformableBase = TransformableBase;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/object/TransformableBase.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/object/TransformableNestableComponent.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/object/TransformableNestableComponent.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransformableNestableComponent = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nclass TransformableNestableComponent {\n    // no way to fetch invalidation methods -- who cares!?\n    constructor(self) {\n        this.dirty = true;\n        this.transformCache = gl_matrix_1.mat4.create();\n        this.self = self;\n    }\n    getGlobalPosition() {\n        let posLocal = gl_matrix_1.vec3.zero(gl_matrix_1.vec3.create());\n        gl_matrix_1.vec3.transformMat4(posLocal, posLocal, this.getTransformationMatrix());\n        return posLocal;\n    }\n    lookAt(x, y, z) {\n        let dirVector = (typeof x === \"number\" ? gl_matrix_1.vec3.fromValues(x, y, z) : gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), x));\n        let pos = this.getGlobalPosition();\n        // account for own offset: vector from camera to dest\n        gl_matrix_1.vec3.sub(dirVector, dirVector, pos);\n        let dir = gl_matrix_1.vec3.create();\n        gl_matrix_1.vec3.normalize(dir, dirVector);\n        let theta = Math.PI + Math.atan2(dir[0], dir[2]);\n        let phi;\n        let phi_denom = Math.sqrt(dir[0] * dir[0] + dir[2] * dir[2]);\n        if (phi_denom === 0 || phi_denom === NaN) {\n            phi = 0;\n        }\n        else {\n            phi = Math.atan(dir[1] / phi_denom);\n        }\n        this.self.setRotationEuler(phi * (180 / Math.PI), theta * (180 / Math.PI), 0);\n    }\n    invalidateTransformCache() {\n        this.dirty = true;\n    }\n    getTransformationMatrix() {\n        if (this.dirty) {\n            const res = this.transformCache;\n            const that = this.self;\n            gl_matrix_1.mat4.fromRotationTranslationScale(res, that.getRotation(), that.getPosition(), that.getScale());\n            if (that.getParent() !== null) {\n                gl_matrix_1.mat4.mul(res, that.getParent().getTransformationMatrix(), res);\n            }\n            this.dirty = false;\n        }\n        return this.transformCache;\n    }\n}\nexports.TransformableNestableComponent = TransformableNestableComponent;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/object/TransformableNestableComponent.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/random/Xorshift32.js":
/*!*************************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/random/Xorshift32.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.xorshift32_seed = exports.xorshift32_float = exports.xorshift32 = void 0;\n// initial seed\nlet s = 3662;\nconst int32_max = 4294967295;\nconst int31_off = 2147483648;\n// up to 53 bits in mantissa, i cant multiply more because the computer will be cross with me\n// prime number :D\nconst int_greebler = 104593;\nconst int_greebler_b = 17497;\nconst int_greebler_c = 19;\nconst int_greebler_d = 3;\n/**\n * @returns a random 32 bit integer.\n */\nfunction xorshift32() {\n    let x = s;\n    x ^= x << 13;\n    x ^= x >>> 17;\n    x ^= x << 5;\n    // constrain to 32 bits\n    x &= -1;\n    x += int31_off;\n    let res = s;\n    s = x;\n    // introduce a large multiplication op to greeble our results a bit\n    // simulate large number mul with several factors\n    // todo: move to lib\n    res = (res * int_greebler) % int32_max;\n    res = (res * int_greebler_b) % int32_max;\n    res = (res * int_greebler_c) % int32_max;\n    res = (res * int_greebler_d) % int32_max;\n    return res;\n}\nexports.xorshift32 = xorshift32;\n/**\n * @returns A floating point number from 0 to 1.\n */\nfunction xorshift32_float() {\n    let res = xorshift32();\n    return res / (int32_max);\n}\nexports.xorshift32_float = xorshift32_float;\nfunction xorshift32_seed(seed) {\n    s = seed;\n    // flush out the seed\n    xorshift32();\n    xorshift32();\n    xorshift32();\n}\nexports.xorshift32_seed = xorshift32_seed;\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/random/Xorshift32.js?");

/***/ }),

/***/ "./node_modules/nekogirl-valhalla/random/index.js":
/*!********************************************************!*\
  !*** ./node_modules/nekogirl-valhalla/random/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.xorshift32_float = exports.xorshift32_seed = exports.xorshift32 = void 0;\nconst Xorshift32_1 = __webpack_require__(/*! ./Xorshift32 */ \"./node_modules/nekogirl-valhalla/random/Xorshift32.js\");\nObject.defineProperty(exports, \"xorshift32\", ({ enumerable: true, get: function () { return Xorshift32_1.xorshift32; } }));\nObject.defineProperty(exports, \"xorshift32_seed\", ({ enumerable: true, get: function () { return Xorshift32_1.xorshift32_seed; } }));\nObject.defineProperty(exports, \"xorshift32_float\", ({ enumerable: true, get: function () { return Xorshift32_1.xorshift32_float; } }));\n\n\n//# sourceURL=webpack://hingler-online/./node_modules/nekogirl-valhalla/random/index.js?");

/***/ }),

/***/ "./client/ts/game/GameConnectionManagerSinglePlayer.ts":
/*!*************************************************************!*\
  !*** ./client/ts/game/GameConnectionManagerSinglePlayer.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameConnectionManagerSinglePlayer = exports.PLAYER_MOTION_STATES = void 0;\nconst SinglePlayerMapState_1 = __webpack_require__(/*! ./manager/internal/SinglePlayerMapState */ \"./client/ts/game/manager/internal/SinglePlayerMapState.ts\");\nconst PlayerInputState_1 = __webpack_require__(/*! ./PlayerInputState */ \"./client/ts/game/PlayerInputState.ts\");\nconst TileID_1 = __webpack_require__(/*! ./tile/TileID */ \"./client/ts/game/tile/TileID.ts\");\nconst LayerInstance_1 = __webpack_require__(/*! ./tile/LayerInstance */ \"./client/ts/game/tile/LayerInstance.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nexports.PLAYER_MOTION_STATES = [PlayerInputState_1.PlayerInputState.MOVE_LEFT, PlayerInputState_1.PlayerInputState.MOVE_RIGHT, PlayerInputState_1.PlayerInputState.MOVE_UP, PlayerInputState_1.PlayerInputState.MOVE_DOWN, PlayerInputState_1.PlayerInputState.IDLE];\nconst knightSpeed = 1.5;\nconst BOMB_RADIUS = 1;\nconst GOAT_BASE_SPEED = 1.0;\nconst GOAT_MAX_SPEED = 4.0;\nconst GOAT_ACCEL_DUR = .25;\nconst GOAT_STUN_TIME = 2.5;\nconst TERM_SHOCK_COEFF = (1 / 450);\nconst TERM_SHOCK_INIT_VELO = 0.75;\nconst BASE_SPEED_POWERUP = 0.1;\nconst POWERUP_IDS = [TileID_1.TileID.POWER_BOMB, TileID_1.TileID.POWER_RADIUS, TileID_1.TileID.POWER_SPEED];\n// todo: draw colored outline around stronger tiles, brighten them?\n// todo: add grades of powerups\n// higher grades = better adders\nconst CRATE_POWERUP_CHANCE = .1;\nconst KNIGHT_POWERUP_CHANCE = 1.0;\nconst CRAB_POWERUP_CHANCE = 1.0;\nconst BASE_SPEED = 3.0;\nconst EXPLOSION_DUR = 0.02;\n// implement as game object so that we can receive update from root object\n// alternatively: we give it to some manager component which promises to update it\n// the manager component can handle dialogue, etc.\n// i'll do it later :)\nclass GameConnectionManagerSinglePlayer extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        this.state = new SinglePlayerMapState_1.SinglePlayerMapState(11);\n        this.playerpos = [0, 0];\n        this.bombCount = 0;\n        this.maxBombCount = 1;\n        // for nowz >:)\n        this.pipeBombInventory = 16;\n        this.speed = BASE_SPEED;\n        this.radius = 1;\n        this.termShockPos = -40;\n        this.bombCollision = new Set();\n        this.playerdead = false;\n        this.playermotion = PlayerInputState_1.PlayerInputState.IDLE;\n        this.playerdirection = PlayerInputState_1.PlayerInputState.MOVE_RIGHT;\n        this.loaded = false;\n        this.detonations = new Set();\n        this.time = 0;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < this.state.dims[1]; j++) {\n                this.state.setTile(i, j, TileID_1.TileID.EMPTY);\n            }\n        }\n        this.knightKills = 0;\n        this.crabKills = 0;\n        this.goatKills = 0;\n    }\n    get knightStart() {\n        return this.state.knightStart;\n    }\n    get crabStart() {\n        return this.state.crabStart;\n    }\n    get goatStart() {\n        return this.state.goatStart;\n    }\n    set knightStart(val) {\n        this.state.knightStart = val;\n    }\n    set crabStart(val) {\n        this.state.crabStart = val;\n    }\n    set goatStart(val) {\n        this.state.goatStart = val;\n    }\n    get killerIsDead() {\n        return this.playerdead;\n    }\n    reset() {\n        this.playerpos = [0, 0];\n        this.bombCount = 0;\n        this.knightKills = 0;\n        this.crabKills = 0;\n        this.goatKills = 0;\n        this.maxBombCount = 1;\n        this.speed = BASE_SPEED;\n        this.radius = 1;\n        this.playerdead = false;\n        let stateReplace = new SinglePlayerMapState_1.SinglePlayerMapState(11);\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < stateReplace.dims[1]; j++) {\n                stateReplace.setTile(i, j, TileID_1.TileID.EMPTY);\n            }\n        }\n        stateReplace.knightStart = this.state.knightStart;\n        stateReplace.crabStart = this.state.crabStart;\n        stateReplace.goatStart = this.state.goatStart;\n        this.state = stateReplace;\n        this.time = 0;\n    }\n    getKnightKillCount() {\n        return this.knightKills;\n    }\n    getCrabKillCount() {\n        return this.crabKills;\n    }\n    getGoatKillCount() {\n        return this.goatKills;\n    }\n    getMapState() {\n        return this.state;\n    }\n    getPlayerList() {\n        let me = {\n            name: \"player\",\n            position: this.playerpos,\n            lastInput: this.playerdirection,\n            dead: this.playerdead\n        };\n        let res = new Map();\n        res.set(1, me);\n        return res;\n    }\n    getMapTitle() {\n        return \"TEST_001\";\n    }\n    update() {\n        let delta = this.getContext().getDelta();\n        this.time += delta;\n        this.termShockPos = this.shockFunc(this.time);\n        if (this.time < 0.25 || (!this.loaded && (this.getContext().getFileLoader().getFractionLoaded() < 0.99 || (0, ShaderProgramBuilder_1.shadersStillCompiling)() > 0))) {\n            // ignore frames before loading is complete\n            return;\n        }\n        else if (!this.loaded) {\n            document.getElementById(\"overlay\").classList.add(\"hidden\");\n            this.loaded = true;\n            // give us a reset for the sake of it\n            this.time = 0;\n        }\n        for (let enemy of this.state.enemy) {\n            switch (enemy[1].type) {\n                case TileID_1.TileID.ENEMY_KNIGHT:\n                    this.moveKnight(delta, enemy[0], enemy[1]);\n                    break;\n                case TileID_1.TileID.ENEMY_CRAB:\n                    this.moveCrab(delta, enemy[0], enemy[1]);\n                    break;\n                case TileID_1.TileID.ENEMY_GOAT:\n                    this.moveGoat(delta, enemy[0], enemy[1]);\n            }\n        }\n        let velo = [0, 0];\n        // snag current motion state\n        if (!this.playerdead) {\n            switch (this.playermotion) {\n                case PlayerInputState_1.PlayerInputState.MOVE_LEFT:\n                    velo[0] = -this.speed * delta;\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_RIGHT:\n                    velo[0] = this.speed * delta;\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_UP:\n                    velo[1] = -this.speed * delta;\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_DOWN:\n                    velo[1] = this.speed * delta;\n            }\n        }\n        this.playerpos = this.stepInstance(this.playerpos, velo, true);\n        if (this.state.getTile(Math.round(this.playerpos[0]), Math.round(this.playerpos[1])) === TileID_1.TileID.EXPLOSION) {\n            this.playerdead = true;\n        }\n        // check if there's any knights near the player\n        let playertile = this.playerpos.map(Math.round);\n        for (let i = playertile[0] - 1; i <= playertile[0] + 1; i++) {\n            for (let j = playertile[1] - 1; j <= playertile[1] + 1; j++) {\n                let enemies = this.state.enemy.getEnemiesAtCoordinate(i, j);\n                for (let enemyArr of enemies) {\n                    let enemy = enemyArr[1];\n                    let delta = [Math.abs(this.playerpos[0] - enemy.position[0]), Math.abs(this.playerpos[1] - enemy.position[1])];\n                    if (delta[0] < 0.5 && delta[1] < 0.5) {\n                        this.playerdead = true;\n                    }\n                }\n            }\n        }\n        if (this.termShockPos > this.playerpos[0] + 0.5) {\n            this.playerdead = true;\n        }\n        // check if the player can pick up a powerup\n        let layerNear = this.state.layer.getEnemiesAtCoordinate(playertile[0], playertile[1]);\n        if (layerNear.length > 0) {\n            for (let instArr of layerNear) {\n                let inst = instArr[1];\n                if (inst.type >= TileID_1.TileID.POWER_SPEED && inst.type <= TileID_1.TileID.POWER_RADIUS) {\n                    this.state.layer.delete(instArr[0]);\n                    this.handlePowerup(inst.type);\n                }\n            }\n        }\n        // purge layer instances which are behind the term shock\n        for (let inst of this.state.layer) {\n            if (inst[1].position[0] < (this.termShockPos - 2)) {\n                this.state.layer.delete(inst[0]);\n            }\n        }\n        // purge enemies which are behind the term shock\n        for (let enemy of this.state.enemy) {\n            if (enemy[1].position[0] < (this.termShockPos - 2)) {\n                this.state.enemy.delete(enemy[0]);\n            }\n        }\n        this.clearExplosions();\n    }\n    handlePowerup(type) {\n        switch (type) {\n            case TileID_1.TileID.POWER_BOMB:\n                this.maxBombCount++;\n                break;\n            case TileID_1.TileID.POWER_RADIUS:\n                this.radius++;\n                break;\n            case TileID_1.TileID.POWER_SPEED:\n                this.speed += BASE_SPEED_POWERUP;\n        }\n    }\n    stepInstance(init, velo, usePlayerBombCollision) {\n        let collisionIgnoreList = [];\n        if (Math.abs(velo[0]) > 0.5 || Math.abs(velo[1]) > 0.5) {\n            let denom = Math.ceil(Math.max(Math.abs(velo[1] * 6), Math.abs(velo[0] * 6)));\n            let velo_itr = [velo[0] / denom, velo[1] / denom];\n            let res;\n            for (let i = 0; i < denom; i++) {\n                res = this.stepInstance(init, velo_itr);\n            }\n            return res;\n        }\n        for (let inst of this.state.layer.entries()) {\n            let pos = inst[1].position;\n            let delta = [Math.abs(pos[0] - init[0]), Math.abs(pos[1] - init[1])];\n            if (usePlayerBombCollision && this.bombCollision.has(inst[0])) {\n                collisionIgnoreList.push([pos[0], pos[1]]);\n            }\n            if (delta[0] < 0.999 && delta[1] < 0.999) {\n                if (!usePlayerBombCollision) {\n                    collisionIgnoreList.push([pos[0], pos[1]]);\n                }\n            }\n            else if (usePlayerBombCollision) {\n                this.bombCollision.delete(inst[0]);\n            }\n        }\n        let res = [init[0], init[1]];\n        res[0] += velo[0];\n        res[1] += velo[1];\n        if (res[0] < 0) {\n            res[0] = 0;\n        }\n        if (res[1] < 0) {\n            res[1] = 0;\n        }\n        if (res[1] > this.state.dims[1] - 1) {\n            res[1] = this.state.dims[1] - 1;\n        }\n        let eTile = res.map(Math.round);\n        let tile = this.state.fetchTiles(eTile[0] - 1, eTile[1] - 1, 3, 3);\n        let signFloat = [eTile[0] - res[0], eTile[1] - res[1]];\n        let sign = [(signFloat[0] < 0 ? 1 : -1), (signFloat[1] < 0 ? 1 : -1)];\n        let curtile = tile.getTile(eTile[0], eTile[1]);\n        let checkX = [eTile[0] + sign[0], eTile[1]];\n        let checkY = [eTile[0], eTile[1] + sign[1]];\n        let checkXY = [eTile[0] + sign[0], eTile[1] + sign[1]];\n        let tileX = tile.getTile(checkX[0], checkX[1]);\n        let tileY = tile.getTile(checkY[0], checkY[1]);\n        if (curtile === TileID_1.TileID.CRATE || curtile === TileID_1.TileID.WALL) {\n            res[0] = Math.round(res[0] + sign[0]);\n        }\n        else {\n            if (tileX === TileID_1.TileID.CRATE || tileX === TileID_1.TileID.WALL) {\n                res[0] = Math.round(res[0]);\n            }\n            if (tileY === TileID_1.TileID.CRATE || tileY === TileID_1.TileID.WALL) {\n                res[1] = Math.round(res[1]);\n            }\n        }\n        // todo: use enemymap to greatly limit number of layers checked\n        for (let inst of this.state.layer.values()) {\n            if (inst.type !== TileID_1.TileID.BOMB && inst.type !== TileID_1.TileID.PIPE_BOMB) {\n                continue;\n            }\n            let pos = inst.position;\n            let check = (pos[0] === checkX[0] && pos[1] === checkX[1]);\n            check = check || (pos[0] === checkY[0] && pos[1] === checkY[1]);\n            check = check || (pos[0] === checkXY[0] && pos[1] === checkXY[1]);\n            if (!check) {\n                continue;\n            }\n            for (let ignore of collisionIgnoreList) {\n                if (pos[0] === ignore[0] && pos[1] === ignore[1]) {\n                    check = false;\n                    break;\n                }\n            }\n            if (!check) {\n                continue;\n            }\n            if ((pos[0] === checkX[0] && pos[1] === checkX[1])) {\n                res[0] = Math.round(res[0]);\n            }\n            if (pos[0] === checkY[0] && pos[1] === checkY[1]) {\n                res[1] = Math.round(res[1]);\n            }\n            // ignore this -- treat it like tiles!\n            if (!usePlayerBombCollision) {\n                if (pos[0] === checkXY[0] && pos[1] === checkXY[1]) {\n                    let signMag = signFloat.map(Math.abs);\n                    if (signMag[0] > signMag[1]) {\n                        res[1] = Math.round(res[1]);\n                    }\n                    else {\n                        res[0] = Math.round(res[0]);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    getScore() {\n        return this.playerpos[0] * 2;\n    }\n    getPositionAfterStep(inst, speed, delta) {\n        let velo = this.getSignFromDirection(inst.direction);\n        velo[0] *= speed * delta;\n        velo[1] *= speed * delta;\n        let fin = this.stepInstance([inst.position[0], inst.position[1]], velo);\n        return fin;\n    }\n    checkIfDetonated(key, inst, powerupcallback) {\n        let tileCoord = inst.position.map(Math.round);\n        let tile = this.state.getTile(tileCoord[0], tileCoord[1]);\n        if (tile === TileID_1.TileID.EXPLOSION) {\n            this.state.enemy.delete(key);\n            let power = new LayerInstance_1.LayerInstance();\n            power.type = powerupcallback();\n            power.position = tileCoord;\n            this.state.layer.set(this.state.nextID++, power);\n            return true;\n        }\n        return false;\n    }\n    moveKnight(delta, key, data) {\n        let pos = data.position;\n        let fin = this.getPositionAfterStep(data, 1.5, delta);\n        if (fin[0] === pos[0] && fin[1] === pos[1]) {\n            data.direction = this.pickFreeDirection(fin);\n        }\n        data.position[0] = fin[0];\n        data.position[1] = fin[1];\n        if (fin[0] < this.termShockPos) {\n            this.state.enemy.delete(key);\n            return;\n        }\n        this.state.enemy.set(key, data);\n        if (this.checkIfDetonated(key, data, this.getRandomKnightPowerup.bind(this))) {\n            this.knightKills++;\n        }\n    }\n    moveGoat(delta, key, goat) {\n        const speedT = Math.min(goat.runTime / GOAT_ACCEL_DUR, 1.0);\n        const speed = (speedT * GOAT_MAX_SPEED) + ((1.0 - speedT) * GOAT_BASE_SPEED);\n        if (goat.runTime > 0) {\n            goat.runTime += delta;\n        }\n        let pos = goat.position;\n        let fin = this.getPositionAfterStep(goat, speed, delta);\n        if (fin[0] === pos[0] && fin[1] === pos[1]) {\n            if (goat.runTime > 0) {\n                goat.runTime = 0;\n                goat.stunTime = GOAT_STUN_TIME;\n            }\n            else {\n                goat.direction = this.pickFreeDirection(fin.map(Math.round));\n            }\n        }\n        const finFloor = fin.map(Math.floor);\n        const posFloor = pos.map(Math.floor);\n        // detect new tile\n        let chargePass = (finFloor[0] !== posFloor[0] || finFloor[1] !== posFloor[1]);\n        const adjust = Math.max(Math.abs(fin[0] - pos[0]), Math.abs(fin[1] - pos[1]));\n        let dir = goat.direction;\n        if (goat.runTime <= 0) {\n            let playerTile = this.playerpos.map(Math.round);\n            let goatTile = goat.position.map(Math.round);\n            let playerDelta = [playerTile[0] - goatTile[0], playerTile[1] - goatTile[1]];\n            let playerDeltaRound = playerDelta.map(Math.round);\n            let signCurrent = this.getSignFromDirection(dir);\n            for (let i = 0; i < 2; i++) {\n                if (signCurrent[1 - i] !== 0 && playerDeltaRound[i] === 0) {\n                    chargePass = true;\n                }\n            }\n            if (chargePass && (playerDeltaRound[0] === 0 || playerDeltaRound[1] === 0) && (playerDeltaRound[0] !== playerDeltaRound[1])) {\n                let dirArray = playerDeltaRound.map(Math.sign);\n                let blocked = false;\n                let tile;\n                while (goatTile[0] !== playerTile[0] || goatTile[1] !== playerTile[1]) {\n                    // step goat tile in direction of sign\n                    tile = this.state.getTile(goatTile[0], goatTile[1]);\n                    if (tile === TileID_1.TileID.CRATE || tile === TileID_1.TileID.WALL) {\n                        blocked = true;\n                        break;\n                    }\n                    // check for bombs possibly in the way\n                    for (let layer of this.state.layer.getEnemiesAtCoordinate(goatTile[0], goatTile[1])) {\n                        if (layer[1].position[0] === goatTile[0] && layer[1].position[1] === goatTile[1]) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                    goatTile[0] += dirArray[0];\n                    goatTile[1] += dirArray[1];\n                }\n                if (!blocked) {\n                    if (playerDeltaRound[1] === 0) {\n                        if (playerDelta[0] > 0) {\n                            dir = PlayerInputState_1.PlayerInputState.MOVE_RIGHT;\n                        }\n                        else {\n                            dir = PlayerInputState_1.PlayerInputState.MOVE_LEFT;\n                        }\n                    }\n                    else {\n                        if (playerDelta[1] > 0) {\n                            dir = PlayerInputState_1.PlayerInputState.MOVE_DOWN;\n                        }\n                        else {\n                            dir = PlayerInputState_1.PlayerInputState.MOVE_UP;\n                        }\n                    }\n                    // non zero epsilon, so it's not equal to 0.\n                    goat.runTime = .00001;\n                }\n            }\n        }\n        if (dir !== goat.direction) {\n            let sign = this.getSignFromDirection(dir);\n            goat.direction = dir;\n            goat.position[0] = Math.round(fin[0]) + sign[0] * adjust;\n            goat.position[1] = Math.round(fin[1]) + sign[1] * adjust;\n        }\n        if (fin[0] < this.termShockPos) {\n            this.state.enemy.delete(key);\n            return;\n        }\n        goat.position[0] = fin[0];\n        goat.position[1] = fin[1];\n        this.state.enemy.set(key, goat);\n        if (this.checkIfDetonated(key, goat, this.getRandomKnightPowerup.bind(this))) {\n            this.goatKills++;\n        }\n    }\n    moveCrab(delta, key, data) {\n        let pos = data.position;\n        let fin = this.getPositionAfterStep(data, 1.5, delta);\n        let finround = fin.map(Math.round);\n        let floordif = [Math.floor(pos[0]) - Math.floor(fin[0]), Math.floor(pos[1]) - Math.floor(fin[1])];\n        if (fin[0] === pos[0] && fin[1] === pos[1]) {\n            data.direction = this.pickFreeDirection(finround);\n        }\n        else {\n            let dir = this.pickFreeDirection(finround);\n            if ((floordif[0] !== 0 || floordif[1] !== 0) && (Math.floor(exports.PLAYER_MOTION_STATES.indexOf(dir) / 2) !== Math.floor(exports.PLAYER_MOTION_STATES.indexOf(data.direction) / 2))) {\n                let tile = finround;\n                let del = [fin[0] - tile[0], fin[1] - tile[1]].map(Math.abs);\n                let deltaMax = Math.max(del[0], del[1]);\n                let sign = this.getSignFromDirection(dir);\n                data.direction = dir;\n                data.position = [Math.round(fin[0]) + (deltaMax * sign[0]), Math.round(fin[1]) + (deltaMax * sign[1]), data.position[2]];\n            }\n            else {\n                data.position[0] = fin[0];\n                data.position[1] = fin[1];\n            }\n        }\n        if (data.position[0] < this.termShockPos) {\n            this.state.enemy.delete(key);\n            return;\n        }\n        this.state.enemy.set(key, data);\n        if (this.checkIfDetonated(key, data, this.getRandomKnightPowerup.bind(this))) {\n            this.crabKills++;\n        }\n    }\n    // need to write a custom payload\n    // charge time as a var (= 0, handles speed ramp up)\n    // charge time will be re-zero'd when we hit a wall, and we'll also need a freeze time\n    // probably want to put the instance in a \"freeze\" state\n    // lastly: how do we control the eye texture?\n    // need some way to \"fish out\" the PBR material\n    // return the material, either instanced or uninstanced, via a scene func\n    // write it into the instance?\n    // separate the eye model, and swap it out as needed <-- this is the solution which works best with the engine :(\n    // we don't currently expose the scaffolding necessary for the client to reach in and customize each material attached to a PBR Model\n    // there's no way to really distinguish them from one another on load\n    // imo the best alternative is just to swap flat models, it makes sense for now :(\n    // OR\n    // we have the eyes up front as a separate model, and we fuck with their materials\n    // the one caveat is that we also might want to skin the eyes later, and so that might be a pain\n    // we want some executive control over their PBR material (texture) but we're also stuck with PBR\n    // load body, load eyes\n    // the eyes will have weights as well, so we can just use the same armature!\n    // we swap out the eyes, each of which is attached to that same armature\n    // models point to an animation wrapper which controls an armature\n    // the animation wrapper packages up the armature data into something which agrees w notions of joints and weights\n    // wrapper which associates model data with anim -- we can fetch everything from one class\n    // then we can just apply the model data to the models in shader and we're good :)\n    // attempts to find a free direction which the player can move in\n    pickFreeDirection(pos) {\n        let randDirInd = Math.floor(Math.random() * 4);\n        let randDir;\n        // check in that direction\n        let sign;\n        let tile;\n        let layers;\n        let tileCoord;\n        let i = -1;\n        do {\n            randDir = exports.PLAYER_MOTION_STATES[randDirInd % 4];\n            sign = this.getSignFromDirection(randDir);\n            tileCoord = [Math.floor(pos[0]) + sign[0], Math.floor(pos[1]) + sign[1]];\n            tile = this.state.getTile(tileCoord[0], tileCoord[1]);\n            i++;\n            randDirInd++;\n            layers = this.state.layer.getEnemiesAtCoordinate(tileCoord[0], tileCoord[1]);\n            // double check coords!!!\n            // note: we need a layer check here as well :(\n        } while ((\n        // tile is not full\n        (tile === TileID_1.TileID.CRATE || tile === TileID_1.TileID.WALL)\n            // still directions to check\n            // ensure we don't point oob\n            || pos[0] + sign[0] < 0\n            || (pos[1] + sign[1]) < 0\n            || (pos[1] + sign[1]) >= 11\n            // check for bombs\n            || this.blockingLayerExists(tileCoord, layers))\n            && i < 4);\n        if (i >= 4) {\n            randDir = PlayerInputState_1.PlayerInputState.MOVE_DOWN;\n        }\n        return randDir;\n    }\n    blockingLayerExists(pos, layers) {\n        // allows our free direction check to also ensure no bombs exist at a location\n        for (let l of layers) {\n            let layer = l[1];\n            if (layer.type === TileID_1.TileID.BOMB && layer.position[0] === pos[0] && layer.position[1] === pos[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getSignFromDirection(dir) {\n        switch (dir) {\n            case PlayerInputState_1.PlayerInputState.MOVE_LEFT:\n                return [-1, 0];\n            case PlayerInputState_1.PlayerInputState.MOVE_RIGHT:\n                return [1, 0];\n            case PlayerInputState_1.PlayerInputState.MOVE_UP:\n                return [0, -1];\n            case PlayerInputState_1.PlayerInputState.MOVE_DOWN:\n                return [0, 1];\n            default:\n                return [0, 0];\n        }\n    }\n    clearExplosions() {\n        for (let det of this.detonations) {\n            if (this.time - det.time > EXPLOSION_DUR) {\n                this.state.setTile(det.x, det.y, TileID_1.TileID.EMPTY);\n                this.detonations.delete(det);\n            }\n        }\n    }\n    sendInput(i) {\n        // if i is a movement command: log it as such\n        if (this.playerdead) {\n            return;\n        }\n        if (exports.PLAYER_MOTION_STATES.indexOf(i) !== -1) {\n            this.playermotion = i;\n            if (this.playermotion !== PlayerInputState_1.PlayerInputState.IDLE) {\n                this.playerdirection = this.playermotion;\n            }\n        }\n        else {\n            switch (i) {\n                case PlayerInputState_1.PlayerInputState.BOMB_PLACE:\n                    // place a bomb at the player's location\n                    this.handleBombPlace();\n                    break;\n                case PlayerInputState_1.PlayerInputState.PIPE_BOMB_PLACE:\n                    if (this.pipeBombInventory <= 0) {\n                        break;\n                    }\n                    // temp\n                    console.log(this.pipeBombInventory);\n                    if (this.handleBombPlace(TileID_1.TileID.PIPE_BOMB)) {\n                        this.pipeBombInventory--;\n                    }\n                    break;\n                case PlayerInputState_1.PlayerInputState.BOMB_DETONATE:\n                    this.handleBombDetonate();\n                    break;\n            }\n        }\n    }\n    getBombCount() {\n        return this.bombCount;\n    }\n    getBombMax() {\n        return this.maxBombCount;\n    }\n    getSpeed() {\n        return this.speed * 2;\n    }\n    getRadius() {\n        return this.radius;\n    }\n    getTermShock() {\n        return this.termShockPos;\n    }\n    getShockSpeed() {\n        return TERM_SHOCK_COEFF * 2 * this.time;\n    }\n    shockFunc(t) {\n        return (TERM_SHOCK_COEFF * t * t) + TERM_SHOCK_INIT_VELO * t - 25;\n    }\n    handleBombPlace(type) {\n        let bombType;\n        if (type === undefined) {\n            bombType = TileID_1.TileID.BOMB;\n        }\n        else {\n            bombType = type;\n        }\n        // max out\n        if (this.bombCount >= this.maxBombCount) {\n            return false;\n        }\n        let bombPos = [Math.round(this.playerpos[0]), Math.round(this.playerpos[1]), 0];\n        for (let id of this.state.layer.keys()) {\n            let inst = this.state.layer.get(id);\n            let pos = inst.position;\n            if (pos[0] === bombPos[0] && pos[1] === bombPos[1]) {\n                return false;\n            }\n        }\n        let id = this.state.nextID++;\n        let layer = new LayerInstance_1.LayerInstance();\n        layer.type = bombType;\n        layer.position = bombPos;\n        this.state.layer.set(id, layer);\n        this.bombCount++;\n        this.bombCollision.add(id);\n        return true;\n    }\n    handleBombDetonate() {\n        let bombIDs = [];\n        let pipeBombIDs = [];\n        for (let id of this.state.layer.keys()) {\n            let inst = this.state.layer.get(id);\n            switch (inst.type) {\n                case TileID_1.TileID.BOMB:\n                    bombIDs.push(id);\n                    break;\n                case TileID_1.TileID.PIPE_BOMB:\n                    pipeBombIDs.push(id);\n                    break;\n            }\n        }\n        let explosionTiles = [];\n        for (let id of bombIDs) {\n            let pos = this.state.layer.get(id).position;\n            let dist = 0;\n            while (dist <= this.radius) {\n                let bomb = [pos[0] - dist, pos[1]];\n                let det = this.createExplosion(bomb[0], bomb[1]);\n                if (det === 0) {\n                    break;\n                }\n                explosionTiles.push(bomb);\n                if (det === 1) {\n                    break;\n                }\n                dist++;\n            }\n            dist = 1;\n            while (dist <= this.radius) {\n                let bomb = [pos[0] + dist, pos[1]];\n                let det = this.createExplosion(bomb[0], bomb[1]);\n                if (det === 0) {\n                    break;\n                }\n                explosionTiles.push(bomb);\n                if (det === 1) {\n                    break;\n                }\n                dist++;\n            }\n            dist = 1;\n            while (dist <= this.radius) {\n                let bomb = [pos[0], pos[1] - dist];\n                let det = this.createExplosion(bomb[0], bomb[1]);\n                if (det === 0) {\n                    break;\n                }\n                explosionTiles.push(bomb);\n                if (det === 1) {\n                    break;\n                }\n                dist++;\n            }\n            dist = 1;\n            while (dist <= this.radius) {\n                let bomb = [pos[0], pos[1] + dist];\n                let det = this.createExplosion(bomb[0], bomb[1]);\n                if (det === 0) {\n                    break;\n                }\n                explosionTiles.push(bomb);\n                if (det === 1) {\n                    break;\n                }\n                dist++;\n            }\n            this.state.layer.delete(id);\n        }\n        let sign = [0, 0];\n        for (let id of pipeBombIDs) {\n            let pos = this.state.layer.get(id).position;\n            for (let i = 0; i < 4; i++) {\n                sign[0] = (i < 2 ? (i < 1 ? 1 : -1) : 0);\n                sign[1] = (i >= 2 ? (i < 3 ? 1 : -1) : 0);\n                for (let j = Math.min(i, 1); j <= this.radius; j++) {\n                    let explosionPos = [(sign[0] * j + pos[0]), (sign[1] * j + pos[1])];\n                    if (this.createExplosion(explosionPos[0], explosionPos[1]) === 0) {\n                        // ignores crates\n                        break;\n                    }\n                    else {\n                        explosionTiles.push(explosionPos);\n                    }\n                }\n            }\n            this.state.layer.delete(id);\n        }\n        for (let tile of explosionTiles) {\n            let delType = this.state.getTile(tile[0], tile[1]);\n            this.state.setTile(tile[0], tile[1], TileID_1.TileID.EXPLOSION);\n            this.detonations.add({\n                \"time\": this.time,\n                \"x\": tile[0],\n                \"y\": tile[1]\n            });\n            // TODO: item spawning?\n            if (delType === TileID_1.TileID.CRATE) {\n                if (Math.random() < CRATE_POWERUP_CHANCE) {\n                    let inst = new LayerInstance_1.LayerInstance();\n                    inst.type = this.getRandomCratePowerup();\n                    inst.position = [tile[0], tile[1], 0];\n                    this.state.layer.set(this.state.nextID++, inst);\n                }\n            }\n            else if (delType === TileID_1.TileID.EMPTY) {\n                let items = this.state.layer.getEnemiesAtCoordinate(tile[0], tile[1]);\n                for (let item of items) {\n                    if (POWERUP_IDS.indexOf(item[1].type) !== -1) {\n                        this.state.layer.delete(item[0]);\n                    }\n                }\n            }\n        }\n        this.bombCount = 0;\n        this.bombCollision.clear();\n    }\n    getRandomCratePowerup() {\n        let seed = Math.random();\n        if (seed > 0.9) {\n            return TileID_1.TileID.POWER_BOMB;\n        }\n        else if (seed > 0.7) {\n            return TileID_1.TileID.POWER_RADIUS;\n        }\n        else {\n            return TileID_1.TileID.POWER_SPEED;\n        }\n    }\n    getRandomKnightPowerup() {\n        let seed = Math.random();\n        if (seed > 0.925) {\n            return TileID_1.TileID.POWER_BOMB;\n        }\n        else {\n            return TileID_1.TileID.POWER_SPEED;\n        }\n    }\n    // return 2 for continue, 1 for crate, 0 for wall.\n    createExplosion(x, y) {\n        if (x < 0 || y < 0 || y >= 11) {\n            return 0;\n        }\n        let tile = this.state.getTile(x, y);\n        if (tile === TileID_1.TileID.WALL) {\n            return 0;\n        }\n        else {\n            return (tile !== TileID_1.TileID.CRATE ? 2 : 1);\n        }\n    }\n}\nexports.GameConnectionManagerSinglePlayer = GameConnectionManagerSinglePlayer;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/GameConnectionManagerSinglePlayer.ts?");

/***/ }),

/***/ "./client/ts/game/GameWorldManagerSinglePlayer.ts":
/*!********************************************************!*\
  !*** ./client/ts/game/GameWorldManagerSinglePlayer.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameWorldManagerSinglePlayer = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst FXAAFilter_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/filter/FXAAFilter */ \"./hingler-party/client/ts/engine/filter/FXAAFilter.ts\");\nconst GameCamera_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GameCamera */ \"./hingler-party/client/ts/engine/object/game/GameCamera.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst AmbientLightObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/light/AmbientLightObject */ \"./hingler-party/client/ts/engine/object/game/light/AmbientLightObject.ts\");\nconst SpotLightObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/light/SpotLightObject */ \"./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts\");\nconst GameConnectionManagerSinglePlayer_1 = __webpack_require__(/*! ./GameConnectionManagerSinglePlayer */ \"./client/ts/game/GameConnectionManagerSinglePlayer.ts\");\nconst FieldManagerSinglePlayer_1 = __webpack_require__(/*! ./manager/internal/FieldManagerSinglePlayer */ \"./client/ts/game/manager/internal/FieldManagerSinglePlayer.ts\");\nconst InputManagerImpl_1 = __webpack_require__(/*! ./manager/internal/InputManagerImpl */ \"./client/ts/game/manager/internal/InputManagerImpl.ts\");\nconst SkyboxManagerSinglePlayer_1 = __webpack_require__(/*! ./manager/internal/SkyboxManagerSinglePlayer */ \"./client/ts/game/manager/internal/SkyboxManagerSinglePlayer.ts\");\nconst TileManagerSinglePlayer_1 = __webpack_require__(/*! ./manager/internal/TileManagerSinglePlayer */ \"./client/ts/game/manager/internal/TileManagerSinglePlayer.ts\");\nconst MapManager_1 = __webpack_require__(/*! ./MapManager */ \"./client/ts/game/MapManager.ts\");\nconst Counter_1 = __webpack_require__(/*! ./ui/Counter */ \"./client/ts/game/ui/Counter.ts\");\nconst EnemyInfo_1 = __webpack_require__(/*! ./ui/EnemyInfo */ \"./client/ts/game/ui/EnemyInfo.ts\");\nconst MOVE_IMG = \"../res/img/chewingcharacter_animated.gif\";\nconst STILL_IMG = \"../res/img/charactermini_still.png\";\nconst GRASS_LEN = 1;\nconst BEACH_LEN = 1;\nconst BRIDGE_LEN = 25;\nconst MOUNTAIN_LEN = 11;\nconst LAVA_LEN = 15;\nconst GAMMA_POW = 2.2;\nvar FieldName;\n(function (FieldName) {\n    FieldName[FieldName[\"GRASS\"] = 0] = \"GRASS\";\n    FieldName[FieldName[\"BEACH\"] = 1] = \"BEACH\";\n    FieldName[FieldName[\"MOUNTAIN\"] = 2] = \"MOUNTAIN\";\n    FieldName[FieldName[\"LAVA\"] = 3] = \"LAVA\";\n})(FieldName || (FieldName = {}));\n;\nclass GameWorldManagerSinglePlayer extends GameObject_1.GameObject {\n    constructor(ctx, player) {\n        super(ctx);\n        this.deathDelta = 0;\n        this.resetState = true;\n        this.motionState = false;\n        this.animImage = document.getElementById(\"walk-image\");\n        let cam = new GameCamera_1.GameCamera(ctx);\n        let conn = new GameConnectionManagerSinglePlayer_1.GameConnectionManagerSinglePlayer(ctx);\n        this.conn = conn;\n        this.skybox = new SkyboxManagerSinglePlayer_1.SkyboxManagerSinglePlayer(ctx);\n        this.addChild(this.skybox);\n        // slow as fucking shit\n        // const water = new WaterField(ctx, 60, 240);\n        // water.setPosition(0, -3, 0);\n        // this.addChild(water);\n        this.skybox.fieldLength = GRASS_LEN * 48;\n        this.skybox.beachLength = (BEACH_LEN + 2.5) * 48;\n        this.statview = document.getElementById(\"stats-view\");\n        this.statRadius = document.getElementById(\"stat-radius\");\n        this.statBomb = document.getElementById(\"stat-maxbomb\");\n        this.statSpeed = document.getElementById(\"stat-speed\");\n        this.addRadius = document.getElementById(\"stat-contents-radius\").querySelector(\".stats-add\");\n        this.addSpeed = document.getElementById(\"stat-contents-speed\").querySelector(\".stats-add\");\n        this.addBomb = document.getElementById(\"stat-contents-maxbomb\").querySelector(\".stats-add\");\n        this.addRadius.style.filter = \"opacity(0)\";\n        this.addSpeed.style.filter = \"opacity(0)\";\n        this.addBomb.style.filter = \"opacity(0)\";\n        this.animateRadius = false;\n        this.animateBomb = false;\n        this.animateSpeed = false;\n        this.lastRadius = this.conn.getRadius();\n        this.lastBomb = this.conn.getBombMax();\n        this.lastSpeed = this.conn.getSpeed();\n        this.input = new InputManagerImpl_1.InputManagerImpl(ctx);\n        this.field = new FieldManagerSinglePlayer_1.FieldManagerSinglePlayer(ctx, 11);\n        this.tile = new TileManagerSinglePlayer_1.TileManagerSinglePlayer(ctx, cam, player, this.field);\n        this.field.setGrassLength(GRASS_LEN);\n        this.field.setBeachLength(BEACH_LEN);\n        conn.knightStart = 20;\n        conn.crabStart = GRASS_LEN * 24 + 2;\n        conn.goatStart = (GRASS_LEN + BEACH_LEN) * 24 + 2;\n        // set connection lengths as well\n        let mapmgr = new MapManager_1.MapManager(ctx, conn, this.input, this.tile);\n        this.mgr = mapmgr;\n        this.addChild(conn);\n        this.addChild(mapmgr);\n        this.addChild(cam);\n        cam.setAsActive();\n        const fxaa = new FXAAFilter_1.FXAAFilter(ctx);\n        cam.addFilter(fxaa);\n        // connection needs some awareness of when beach starts\n        // how best to provide that?\n        // - use mapmanager to handle that, instead of passing values to each component\n        //   mapmanager requires a reference to field, but thats nbd\n        //   i think this is a good route, considering that map manager is pretty lightweight atm\n        let spot = new SpotLightObject_1.SpotLightObject(ctx);\n        let amb = new AmbientLightObject_1.AmbientLightObject(ctx);\n        this.addChild(amb);\n        this.addChild(spot);\n        this.spotShadow = spot;\n        this.ambient = amb;\n        this.cam = cam;\n        this.resetObjectAttributes();\n        let final = document.getElementById(\"retry\");\n        final.addEventListener(\"click\", () => {\n            this.conn.reset();\n            document.getElementById(\"score-panel\").classList.add(\"hidden\");\n        });\n        this.counter = new Counter_1.Counter(8);\n        document.getElementById(\"score-display\").prepend(this.counter.getElement());\n        this.counter.getElement().id = \"score-counter\";\n        let enemyInfo = document.getElementById(\"enemy-info\");\n        this.knightKills = new EnemyInfo_1.EnemyInfo(\"../res/img/portrait_knight_final.png\");\n        enemyInfo.appendChild(this.knightKills.getElement());\n        this.crabKills = new EnemyInfo_1.EnemyInfo(\"../res/img/portrait_crab_final.png\");\n        enemyInfo.appendChild(this.crabKills.getElement());\n        this.goatKills = new EnemyInfo_1.EnemyInfo(\"../res/img/portrait_goat_final.png\");\n        enemyInfo.appendChild(this.goatKills.getElement());\n        this.scoreCounter = new Counter_1.Counter(8);\n        document.getElementById(\"score-counter-screen\").prepend(this.scoreCounter.getElement());\n    }\n    resetObjectAttributes() {\n        let spot = this.spotShadow;\n        let amb = this.ambient;\n        let cam = this.cam;\n        spot.setPosition(-115, 400, -80);\n        spot.fov = 12.0;\n        spot.near = 100.0;\n        spot.far = 10000.0;\n        spot.falloffRadius = 0.0001;\n        spot.atten_const = 1;\n        spot.atten_linear = 0;\n        spot.atten_quad = 0;\n        spot.intensity = 1.6;\n        spot.color = new Float32Array([1, 1, 1, 1]);\n        spot.setShadowDims(2048, 2048);\n        spot.setShadows(true);\n        spot.lookAt(0, 0, 0);\n        amb.color = [0.5, 0.5, 0.5, 1.0];\n        amb.intensity = 0.3;\n        cam.setPosition(0, 55.1, 36);\n        cam.fov = 21;\n        cam.near = 1.0;\n        cam.far = 250.0;\n        cam.lookAt(0, 0, 0);\n        this.deathDelta = 0;\n        this.mgr.clear();\n    }\n    colLerp(a, b, t) {\n        let res = gl_matrix_1.vec4.create();\n        gl_matrix_1.vec4.zero(res);\n        let btemp = gl_matrix_1.vec4.zero(gl_matrix_1.vec4.create());\n        gl_matrix_1.vec4.copy(res, a);\n        gl_matrix_1.vec4.scale(res, res, t);\n        gl_matrix_1.vec4.copy(btemp, b);\n        gl_matrix_1.vec4.scale(btemp, btemp, (1 - t));\n        gl_matrix_1.vec4.add(res, res, btemp);\n        return res;\n    }\n    update() {\n        let motion = this.input.getInputState();\n        let inmotion = false;\n        let score = this.conn.getScore();\n        this.skybox.updateSkyboxes(score);\n        let shock = this.conn.getTermShock();\n        this.tile.setTermShockPosition(shock);\n        let playerpos = this.conn.getPlayerList().get(1).position;\n        let shockDist = playerpos[0] - shock;\n        let tShock = Math.pow(Math.min(Math.max((shockDist - 5) / 15, 0.0), 1.0), GAMMA_POW);\n        let lightCol = this.colLerp([1, 1, 1, 1], [1, 0.1, 0, 1], tShock);\n        let ambIntensity = tShock * 0.3;\n        this.spotShadow.color = lightCol;\n        this.ambient.intensity = ambIntensity;\n        this.skybox.intensityMul = tShock;\n        // map distance from player to termshock\n        // 20 - like 4 or 5 : turn the screen redder, lower the ambient\n        if (this.lastBomb !== this.conn.getBombMax()) {\n            this.animateBomb = true;\n            this.addBombTime = 0;\n            this.addBomb.removeAttribute(\"time\");\n            let delta = (this.conn.getBombMax() - this.lastBomb);\n            this.addBomb.textContent = (delta >= 0 ? \"+\" : \"-\") + Math.abs(delta).toString();\n            this.lastBomb = this.conn.getBombMax();\n        }\n        if (this.lastRadius !== this.conn.getRadius()) {\n            this.animateRadius = true;\n            this.addRadiusTime = 0;\n            this.addRadius.removeAttribute(\"time\");\n            let delta = (this.conn.getRadius() - this.lastRadius);\n            this.addRadius.textContent = (delta >= 0 ? \"+\" : \"-\") + Math.abs(delta).toString();\n            this.lastRadius = this.conn.getRadius();\n        }\n        if (this.lastSpeed !== this.conn.getSpeed()) {\n            this.animateSpeed = true;\n            this.addSpeedTime = 0;\n            this.addSpeed.removeAttribute(\"time\");\n            let delta = (this.conn.getSpeed() - this.lastSpeed);\n            this.addSpeed.textContent = (delta >= 0 ? \"+\" : \"-\") + Math.abs(delta).toFixed(2).toString();\n            this.lastSpeed = this.conn.getSpeed();\n        }\n        if (this.animateBomb) {\n            this.addBombTime = this.animateAddText(this.addBomb, this.addBombTime);\n            this.animateBomb = (this.addBombTime <= 2.0);\n        }\n        if (this.animateRadius) {\n            this.addRadiusTime = this.animateAddText(this.addRadius, this.addRadiusTime);\n            this.animateRadius = (this.addRadiusTime <= 2.0);\n        }\n        if (this.animateSpeed) {\n            this.addSpeedTime = this.animateAddText(this.addSpeed, this.addSpeedTime);\n            this.animateSpeed = (this.addSpeedTime <= 2.0);\n        }\n        this.statRadius.textContent = this.conn.getRadius().toString();\n        this.statBomb.textContent = this.conn.getBombMax().toString();\n        this.statSpeed.textContent = this.conn.getSpeed().toFixed(2);\n        for (let input of GameConnectionManagerSinglePlayer_1.PLAYER_MOTION_STATES) {\n            inmotion = inmotion || motion.has(input);\n        }\n        if (inmotion !== this.motionState) {\n            if (inmotion) {\n                this.animImage.src = MOVE_IMG;\n            }\n            else {\n                this.animImage.src = STILL_IMG;\n            }\n        }\n        this.motionState = inmotion;\n        let scorebox = document.getElementById(\"score-counter-screen\");\n        this.scoreCounter.setValue(Math.floor(score));\n        if (scorebox.classList.contains(\"hidden\")) {\n            scorebox.classList.remove(\"hidden\");\n        }\n        let dist = score / 48;\n        let newfield;\n        if (dist > GRASS_LEN) {\n            newfield = FieldName.BEACH;\n        }\n        else {\n            newfield = FieldName.GRASS;\n        }\n        // how do we control skyboxes without too much coupling?\n        if (newfield !== this.curfield) {\n            let fg = document.getElementById(\"field-fg\");\n            let bg = document.getElementById(\"field-bg\");\n            switch (newfield) {\n                case FieldName.BEACH:\n                    fg.src = \"../res/img/fieldminis/beach_fg.png\";\n                    bg.src = \"../res/img/fieldminis/beach_bg.png\";\n                    break;\n                case FieldName.GRASS:\n                default:\n                    fg.src = \"../res/img/fieldminis/field_fg.png\";\n                    bg.src = \"../res/img/fieldminis/field_bg.png\";\n                    break;\n            }\n            this.curfield = newfield;\n        }\n        if (!this.conn.killerIsDead && this.statview.classList.contains(\"hidden\")) {\n            this.statview.classList.remove(\"hidden\");\n        }\n        if (this.conn.killerIsDead) {\n            // toggle a flicket which positions the player\n            // we need to figure out where the player is\n            let player = this.mgr.getPlayerPosition(1);\n            let delta = this.getContext().getDelta();\n            this.deathDelta += delta;\n            let final = document.getElementById(\"score-panel\");\n            if (this.deathDelta > 0.5) {\n                if (final.classList.contains(\"hidden\")) {\n                    final.classList.remove(\"hidden\");\n                    this.statview.classList.add(\"hidden\");\n                }\n                if (!scorebox.classList.contains(\"hidden\")) {\n                    scorebox.classList.add(\"hidden\");\n                }\n                let t = Math.pow(this.deathDelta - 0.5, 1.8);\n                let score = Math.min(Math.max(t * 300, 0), Math.floor(this.conn.getScore()));\n                this.counter.setValue(score);\n                let knightKills = Math.min(Math.max(t * 30, 0), this.conn.getKnightKillCount());\n                this.knightKills.setValue(knightKills);\n                let crabKills = Math.min(Math.max(t * 30, 0), this.conn.getCrabKillCount());\n                this.crabKills.setValue(crabKills);\n                let goatKills = Math.min(Math.max(t * 30, 0), this.conn.getGoatKillCount());\n                this.goatKills.setValue(goatKills);\n            }\n            this.resetState = false;\n            let t = 1.0 - Math.pow(0.1, delta);\n            let rot = this.cam.getRotation();\n            let pos = this.cam.getPosition();\n            this.cam.lookAt(player);\n            let rotDest = this.cam.getRotation();\n            let posDest = [player[0] + 4, player[1] + 12.5, player[2] + 3];\n            let posRes = this.vecLerp(pos, posDest, t);\n            this.cam.setPosition(posRes);\n            this.cam.setRotationQuat(this.slerp(rot, rotDest, t));\n            this.spotShadow.intensity = this.spotShadow.intensity * (1 - t);\n            this.cam.fov = this.cam.fov * (1 - t) + 35 * t;\n        }\n        else if (!this.resetState) {\n            this.resetState = true;\n            this.resetObjectAttributes();\n        }\n        // add counter to top of screen\n    }\n    vecLerp(a, b, t) {\n        let res = [0, 0, 0];\n        res[0] = (a[0] * (1 - t)) + (b[0] * t);\n        res[1] = (a[1] * (1 - t)) + (b[1] * t);\n        res[2] = (a[2] * (1 - t)) + (b[2] * t);\n        return res;\n    }\n    slerp(a, b, t) {\n        let dot = gl_matrix_1.quat.dot(a, b);\n        let res = gl_matrix_1.quat.create();\n        gl_matrix_1.quat.copy(res, a);\n        if (dot < 0) {\n            gl_matrix_1.quat.scale(res, res, -1);\n        }\n        gl_matrix_1.quat.invert(res, res);\n        gl_matrix_1.quat.multiply(res, res, b);\n        gl_matrix_1.quat.pow(res, res, t);\n        gl_matrix_1.quat.mul(res, a, res);\n        return res;\n    }\n    textfunc(t) {\n        return Math.max(Math.min(1.0 - (0.5 + (Math.pow(-(t - 1), 5) / 2)), 1.0), 0.0);\n    }\n    // returns true if the animation should continue, false otherwise\n    animateAddText(elem, t) {\n        t += this.getContext().getDelta();\n        let fade = this.textfunc(t);\n        elem.style.left = (80 + (fade * 160)) + \"px\";\n        elem.style.filter = \"opacity(\" + (1 * (1 - (2 * Math.abs(fade - 0.5)))) + \")\";\n        return t;\n    }\n}\nexports.GameWorldManagerSinglePlayer = GameWorldManagerSinglePlayer;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/GameWorldManagerSinglePlayer.ts?");

/***/ }),

/***/ "./client/ts/game/MapManager.ts":
/*!**************************************!*\
  !*** ./client/ts/game/MapManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MapManager = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst TileFactoryStub_1 = __webpack_require__(/*! ../../../test/stub/TileFactoryStub */ \"./test/stub/TileFactoryStub.ts\");\nconst InputManager_1 = __webpack_require__(/*! ./manager/InputManager */ \"./client/ts/game/manager/InputManager.ts\");\nconst InputManagerImpl_1 = __webpack_require__(/*! ./manager/internal/InputManagerImpl */ \"./client/ts/game/manager/internal/InputManagerImpl.ts\");\nconst TileManagerSinglePlayer_1 = __webpack_require__(/*! ./manager/internal/TileManagerSinglePlayer */ \"./client/ts/game/manager/internal/TileManagerSinglePlayer.ts\");\nconst PlayerInputState_1 = __webpack_require__(/*! ./PlayerInputState */ \"./client/ts/game/PlayerInputState.ts\");\n/**\n * Handles creation of components pertaining to game connection.\n * Should this also contain the connection manager? probably :)\n */\nclass MapManager extends GameObject_1.GameObject {\n    constructor(ctx, conn, input, tile) {\n        super(ctx);\n        this.conn = conn;\n        this.lastUpdate = null;\n        this.inputMap = new Map();\n        this.time = 0;\n        if (!tile) {\n            this.tilemgr = new TileManagerSinglePlayer_1.TileManagerSinglePlayer(ctx, null, null);\n        }\n        else {\n            this.tilemgr = tile;\n        }\n        if (!input) {\n            this.inputmgr = new InputManagerImpl_1.InputManagerImpl(ctx);\n        }\n        else {\n            this.inputmgr = input;\n        }\n        this.players = new Map();\n        this.addChild(this.tilemgr.root);\n        this.tilemgr.root.setPosition(0, 0, 0);\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.MOVE_UP, \"KeyW\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.MOVE_LEFT, \"KeyA\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.MOVE_RIGHT, \"KeyD\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.MOVE_DOWN, \"KeyS\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.BOMB_PLACE, \"KeyJ\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.PIPE_BOMB_PLACE, \"KeyI\");\n        this.inputmgr.setKey(PlayerInputState_1.PlayerInputState.BOMB_DETONATE, \"Space\");\n        switch (this.conn.getMapTitle()) {\n            case \"TEST_001\":\n                this.factory = new TileFactoryStub_1.TileFactoryStub(this.getContext());\n            default:\n                console.warn(\"what\");\n        }\n    }\n    clear() {\n        this.tilemgr.clear();\n    }\n    update() {\n        this.time += this.getContext().getDelta();\n        let state = this.conn.getMapState();\n        this.tilemgr.setTileOrigin([Math.max(-state.dims[0] + 1, -11), -state.dims[1] + 1]);\n        this.tilemgr.updateTiles(this.conn.getMapState(), this.conn.getPlayerList());\n        // get input manager state\n        let inputs = this.inputmgr.getInputState();\n        // create an array of inputs which are triggered as a \"delta\"\n        // for each one, duplicate this handling\n        if (inputs.has(PlayerInputState_1.PlayerInputState.BOMB_PLACE) && !this.inputMap.has(PlayerInputState_1.PlayerInputState.BOMB_PLACE)) {\n            this.conn.sendInput(PlayerInputState_1.PlayerInputState.BOMB_PLACE);\n        }\n        if (inputs.has(PlayerInputState_1.PlayerInputState.BOMB_DETONATE) && !this.inputMap.has(PlayerInputState_1.PlayerInputState.BOMB_DETONATE)) {\n            this.conn.sendInput(PlayerInputState_1.PlayerInputState.BOMB_DETONATE);\n        }\n        if (inputs.has(PlayerInputState_1.PlayerInputState.PIPE_BOMB_PLACE) && !this.inputMap.has(PlayerInputState_1.PlayerInputState.PIPE_BOMB_PLACE)) {\n            this.conn.sendInput(PlayerInputState_1.PlayerInputState.PIPE_BOMB_PLACE);\n        }\n        for (let input of inputs) {\n            if (this.inputMap.has(input)) {\n                continue;\n            }\n            this.inputMap.set(input, this.time);\n        }\n        let deletedInputs = [];\n        for (let input of this.inputMap.keys()) {\n            if (!inputs.has(input)) {\n                deletedInputs.push(input);\n            }\n        }\n        for (let input of deletedInputs) {\n            this.inputMap.delete(input);\n        }\n        // use time to sort inputs via a map\n        let time = -1;\n        let inputValue = PlayerInputState_1.PlayerInputState.IDLE;\n        for (let input of this.inputMap) {\n            // use most recent directional input\n            if (InputManager_1.MOTION_INPUT.indexOf(input[0]) !== -1 && time < input[1]) {\n                time = input[1];\n                inputValue = input[0];\n            }\n        }\n        this.conn.sendInput(inputValue);\n    }\n    getPlayerPosition(id) {\n        return this.tilemgr.getPlayerPosition(id);\n    }\n}\nexports.MapManager = MapManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/MapManager.ts?");

/***/ }),

/***/ "./client/ts/game/PlayerGameObject.ts":
/*!********************************************!*\
  !*** ./client/ts/game/PlayerGameObject.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayerGameObject = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst SpotLightObject_1 = __webpack_require__(/*! ../../../hingler-party/client/ts/engine/object/game/light/SpotLightObject */ \"./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts\");\nclass PlayerGameObject extends GameObject_1.GameObject {\n    constructor(ctx, char) {\n        super(ctx);\n        let player = new GamePBRModel_1.GamePBRModel(ctx, char);\n        let deathRotate = new GameObject_1.GameObject(ctx);\n        let spot = new SpotLightObject_1.SpotLightObject(ctx);\n        spot.setPosition(0.01, 11, 0.01);\n        spot.lookAt(0, 0, 0);\n        spot.intensity = 0;\n        spot.color = new Float32Array([1, 1, 1, 1]);\n        spot.fov = 28;\n        spot.atten_const = 1;\n        spot.atten_linear = 0.0;\n        spot.atten_quad = 0.0;\n        spot.falloffRadius = 0.1;\n        spot.near = 0.1;\n        spot.far = 100.0;\n        spot.setShadows(false);\n        this.addChild(spot);\n        deathRotate.addChild(player);\n        deathRotate.setPosition(-0.86, 0, 0);\n        player.setPosition(0.86, 0, 0);\n        this.addChild(deathRotate);\n        this.pivot = deathRotate;\n        this.spot = spot;\n        this.player = player;\n    }\n    getSpot() {\n        return this.spot;\n    }\n    // replace this with something like a death animation\n    // whatever idc\n    setPivotRotation(deg) {\n        this.pivot.setRotationEuler(deg, 0, 0);\n    }\n}\nexports.PlayerGameObject = PlayerGameObject;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/PlayerGameObject.ts?");

/***/ }),

/***/ "./client/ts/game/PlayerInputState.ts":
/*!********************************************!*\
  !*** ./client/ts/game/PlayerInputState.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayerInputState = void 0;\n/**\n * Represents an input which can be sent to the server.\n * Temporary, while io netcode is in place.\n */\nvar PlayerInputState;\n(function (PlayerInputState) {\n    PlayerInputState[PlayerInputState[\"IDLE\"] = 0] = \"IDLE\";\n    PlayerInputState[PlayerInputState[\"MOVE_LEFT\"] = 1] = \"MOVE_LEFT\";\n    PlayerInputState[PlayerInputState[\"MOVE_RIGHT\"] = 2] = \"MOVE_RIGHT\";\n    PlayerInputState[PlayerInputState[\"MOVE_UP\"] = 3] = \"MOVE_UP\";\n    PlayerInputState[PlayerInputState[\"MOVE_DOWN\"] = 4] = \"MOVE_DOWN\";\n    PlayerInputState[PlayerInputState[\"BOMB_PLACE\"] = 5] = \"BOMB_PLACE\";\n    PlayerInputState[PlayerInputState[\"PIPE_BOMB_PLACE\"] = 6] = \"PIPE_BOMB_PLACE\";\n    PlayerInputState[PlayerInputState[\"BOMB_DETONATE\"] = 7] = \"BOMB_DETONATE\";\n    PlayerInputState[PlayerInputState[\"STOP\"] = 8] = \"STOP\";\n})(PlayerInputState = exports.PlayerInputState || (exports.PlayerInputState = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/PlayerInputState.ts?");

/***/ }),

/***/ "./client/ts/game/TileAtlas.ts":
/*!*************************************!*\
  !*** ./client/ts/game/TileAtlas.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileAtlas = void 0;\n/**\n * Represents a range of tiles.\n */\nclass TileAtlas {\n    constructor(origin, dims, data) {\n        this.origin = origin;\n        this.dims = dims;\n        this.data = data;\n        if (this.data.length < this.dims[0] * this.dims[1]) {\n            throw Error(\"Data field length is of insufficient length!\");\n        }\n    }\n    /**\n     * Fetches a tile from the underlying game data and returns it.\n     * @param x - X coordinate of the tile in question.\n     * @param y - Y coordinate of the tile in question.\n     * @returns the ID associated with the desired tile, or `null` if the tile is not contained\n     *          within the bounds of this atlas.\n     */\n    getTile(x, y) {\n        if (x >= this.origin[0] && y >= this.origin[1] && x - this.origin[0] < this.dims[0] && y - this.origin[1] < this.dims[1]) {\n            return this.data[(y - this.origin[1]) * this.dims[0] + (x - this.origin[0])];\n        }\n        return null;\n    }\n}\nexports.TileAtlas = TileAtlas;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/TileAtlas.ts?");

/***/ }),

/***/ "./client/ts/game/TileGrid.ts":
/*!************************************!*\
  !*** ./client/ts/game/TileGrid.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileGrid = void 0;\nconst TileAtlas_1 = __webpack_require__(/*! ./TileAtlas */ \"./client/ts/game/TileAtlas.ts\");\n/**\n * Stores a read/write record of tiles which currently exist.\n */\nclass TileGrid {\n    constructor() {\n        this.store = [];\n        this.origin_ = [0, 0];\n        this.dims_ = [0, 0];\n    }\n    get dims() {\n        return this.dims_;\n    }\n    get origin() {\n        return this.origin_;\n    }\n    getTile(x, y) {\n        if (x < this.origin_[0] || y < this.origin_[1] || this.store[y - this.origin_[1]] === undefined) {\n            return undefined;\n        }\n        return this.store[y - this.origin_[1]][x - this.origin_[0]];\n    }\n    /**\n     * Sets the contents of a particular tile.\n     * @param x - the x coordinate of the tile being modified.\n     * @param y - the y coordinate of the tile being modified.\n     * @param value - the value which should be assigned to this tile.\n     */\n    setTile(x, y, value) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n        if (y < this.origin_[1]) {\n            this.dims_[1] += (this.origin_[1] - y);\n            this.setOriginY(y);\n        }\n        if (x < this.origin_[0]) {\n            this.dims_[0] += (this.origin_[0] - x);\n            this.setOriginX(x);\n        }\n        if (this.store[y] === undefined) {\n            this.store[y] = [];\n        }\n        this.store[y - this.origin_[1]][x - this.origin_[0]] = value;\n        this.dims_[0] = Math.max(this.dims_[0], (x - this.origin_[0]) + 1);\n        this.dims_[1] = Math.max(this.dims_[1], (y - this.origin_[1]) + 1);\n    }\n    setOriginX(x) {\n        for (let i = 0; i < this.store.length; i++) {\n            if (this.store[i] !== undefined) {\n                this.store[i] = this.adjustOrigin(this.store[i], x - this.origin_[0]);\n            }\n        }\n        this.origin_[0] = x;\n    }\n    setDimsX(x) {\n        for (let i = 0; i < this.store.length; i++) {\n            if (this.store[i] !== undefined) {\n                this.store[i] = this.store[i].slice(0, x);\n            }\n        }\n    }\n    setDimsY(y) {\n        this.store = this.store.slice(0, y);\n    }\n    setOriginY(y) {\n        this.store = this.adjustOrigin(this.store, (y - this.origin_[1]));\n        this.origin_[1] = y;\n    }\n    /**\n     * Sets the origin of this TileGrid.\n     * Any points with x/y coordinate below the origin will be truncated.\n     * @param x - new X origin.\n     * @param y - new Y origin.\n     */\n    setOrigin(x, y) {\n        let newDims = [this.dims_[0] - (x - this.origin_[0]), this.dims_[1] - (y - this.origin_[1])];\n        this.setOriginY(y);\n        this.setOriginX(x);\n        this.dims_[0] = Math.max(newDims[0], this.dims_[0]);\n        this.dims_[1] = Math.max(newDims[1], this.dims_[1]);\n    }\n    getOrigin() {\n        return Array.from(this.origin_);\n    }\n    setDims(x, y) {\n        if (y < this.dims_[1]) {\n            this.setDimsY(y);\n        }\n        if (x < this.dims_[0]) {\n            this.setDimsX(x);\n        }\n    }\n    /**\n     * @param a - array we are adjusting\n     * @param shift - number of values to shift origin forward (+) or backward (-)\n     */\n    adjustOrigin(a, shift) {\n        if (shift > 0) {\n            return a.slice(shift);\n        }\n        else if (shift < 0) {\n            let res = new Array(-shift);\n            res = res.fill(null, 0, -shift);\n            res = res.concat(a);\n            return res;\n        }\n        // shift === 0\n        return a;\n    }\n    /**\n     * Returns a slice of this TileGrid as a read-only TileAtlas.\n     * @param x - init x coord\n     * @param y - init y coord\n     * @param dx - width\n     * @param dy - height\n     */\n    slice(x, y, dx, dy) {\n        let xActual = Math.floor(Math.min(Math.max(this.origin_[0], x), this.dims_[0] + this.origin_[0]));\n        let yActual = Math.floor(Math.min(Math.max(this.origin_[1], y), this.dims_[1] + this.origin_[1]));\n        let dxActual = Math.floor(Math.max(Math.min(this.dims_[0] - (xActual - this.origin_[0]), dx), 0));\n        let dyActual = Math.floor(Math.max(Math.min(this.dims_[1] - (yActual - this.origin_[1]), dy), 0));\n        let originRes = [xActual, yActual];\n        let dimsRes = [dxActual, dyActual];\n        try {\n            // not sure why the oob error is happening (null or undefined or nan cropping up??? not sure where that could even be for the crabs)\n            let test = new Array(dxActual * dyActual);\n        }\n        catch (e) {\n            console.log(dimsRes);\n            console.log(`Params: ${x}, ${y} -- ${dx} by ${dy}`);\n            console.log(`Actuals: ${xActual}, ${yActual} -- ${dxActual} by ${dyActual}`);\n        }\n        let dataRes = new Array(dxActual * dyActual);\n        for (let j = 0; j < dyActual; j++) {\n            for (let i = 0; i < dxActual; i++) {\n                dataRes[j * dxActual + i] = this.store[j + yActual - this.origin_[1]][i + xActual - this.origin_[0]];\n            }\n        }\n        return new TileAtlas_1.TileAtlas(originRes, dimsRes, dataRes);\n    }\n}\nexports.TileGrid = TileGrid;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/TileGrid.ts?");

/***/ }),

/***/ "./client/ts/game/field/BeachGrassField.ts":
/*!*************************************************!*\
  !*** ./client/ts/game/field/BeachGrassField.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BeachGrassField = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GrassInstanceFactory_1 = __webpack_require__(/*! ../map/GrassInstanceFactory */ \"./client/ts/game/map/GrassInstanceFactory.ts\");\nconst random_1 = __webpack_require__(/*! nekogirl-valhalla/random */ \"./node_modules/nekogirl-valhalla/random/index.js\");\nconst GRASS_RADIUS_MIN = 0.8;\nconst GRASS_RADIUS_MAX = 1.1;\nconst GRASS_SCALE_CONST = 0.25;\nconst GRASS_ROT_AXIS = [0, 1, 0];\nconst GRASS_SCALE = [GRASS_SCALE_CONST, GRASS_SCALE_CONST, GRASS_SCALE_CONST];\nclass BeachGrassField extends GameObject_1.GameObject {\n    // arrange normally\n    // ideally it'll fade out when we get to the hill\n    constructor(ctx, field, grass, seed) {\n        super(ctx);\n        this.field = field;\n        this.grass = grass;\n        this.seed = seed;\n        this.matcache = null;\n        this.bladeCount = null;\n        this.instanceFac = new GrassInstanceFactory_1.GrassInstanceFactory(ctx, this.grass);\n    }\n    renderMaterial(rc) {\n        if (this.field.valid() && this.grass.valid()) {\n            const field = this.field.get();\n            const sourceMat = this.getTransformationMatrix();\n            field.drawPBR(sourceMat, rc);\n            if (!this.matcache) {\n                const center = gl_matrix_1.vec3.create();\n                const temp = gl_matrix_1.vec3.create();\n                this.matcachefloat = new Float32Array(36 * 128 * 16);\n                this.normcachefloat = new Float32Array(36 * 128 * 9);\n                let cur = 0;\n                let cur_n = 0;\n                // same for normals\n                (0, random_1.xorshift32_seed)(this.seed);\n                this.matcache = [];\n                this.bladeCount = 0;\n                for (let i = 0; i < 128; i++) {\n                    // pick a spot inside of our planes\n                    // +/- 11 - 25 out on y\n                    // -24 - 24 out on x\n                    // about 1m below origin\n                    center[0] = (0, random_1.xorshift32_float)() * 24 - 12;\n                    center[1] = 0;\n                    center[2] = (Math.pow((0, random_1.xorshift32_float)(), 2.0) * 5.0 + 12.9) * ((0, random_1.xorshift32_float)() > 0.5 ? 1 : -1);\n                    const bladeCount = Math.floor((0, random_1.xorshift32_float)() * 12 + 24);\n                    for (let j = 0; j < bladeCount; j++) {\n                        let grassmat = gl_matrix_1.mat4.identity(gl_matrix_1.mat4.create());\n                        gl_matrix_1.mat4.translate(grassmat, grassmat, center);\n                        // choose a theta and an r\n                        // rotate shift by theta\n                        const theta = (0, random_1.xorshift32_float)() * Math.PI * 2;\n                        const r = (0, random_1.xorshift32_float)() * (GRASS_RADIUS_MAX - GRASS_RADIUS_MIN) + GRASS_RADIUS_MIN;\n                        temp[0] = Math.cos(theta) * r;\n                        temp[1] = 0;\n                        temp[2] = Math.sin(theta) * r;\n                        gl_matrix_1.mat4.translate(grassmat, grassmat, temp);\n                        gl_matrix_1.mat4.rotate(grassmat, grassmat, theta, GRASS_ROT_AXIS);\n                        gl_matrix_1.mat4.scale(grassmat, grassmat, GRASS_SCALE);\n                        this.matcache.push(grassmat);\n                        for (let k = 0; k < 16; k++) {\n                            this.matcachefloat[cur++] = grassmat[k];\n                        }\n                        const norm = gl_matrix_1.mat3.create();\n                        gl_matrix_1.mat3.fromMat4(norm, grassmat);\n                        gl_matrix_1.mat3.transpose(norm, norm);\n                        gl_matrix_1.mat3.invert(norm, norm);\n                        for (let k = 0; k < 9; k++) {\n                            this.normcachefloat[cur_n++] = norm[k];\n                        }\n                        this.bladeCount++;\n                    }\n                }\n            }\n            const parentMat = this.getTransformationMatrix();\n            this.instanceFac.parentMat = parentMat;\n            // this.instanceFac.drawManyInstanced(this.matcachefloat, this.normcachefloat, this.bladeCount, rc);\n        }\n    }\n}\nexports.BeachGrassField = BeachGrassField;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/field/BeachGrassField.ts?");

/***/ }),

/***/ "./client/ts/game/field/TerminationShock.ts":
/*!**************************************************!*\
  !*** ./client/ts/game/field/TerminationShock.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TerminationShock = void 0;\nconst GameModel_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/game/GameModel */ \"./hingler-party/client/ts/engine/object/game/GameModel.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst ExplosionFilter_1 = __webpack_require__(/*! ../filter/ExplosionFilter */ \"./client/ts/game/filter/ExplosionFilter.ts\");\nclass TerminationShock extends GameModel_1.GameModel {\n    constructor(ctx, init, cam) {\n        super(ctx, init);\n        let center = new GameObject_1.GameObject(ctx);\n        center.setPosition(-64, 0, 0);\n        this.addChild(center);\n        this.filter = new ExplosionFilter_1.ExplosionFilter(ctx, this, center);\n        cam.addFilter(this.filter);\n    }\n    setBlur(dist) {\n        this.filter.blurMag = dist;\n    }\n}\nexports.TerminationShock = TerminationShock;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/field/TerminationShock.ts?");

/***/ }),

/***/ "./client/ts/game/filter/ExplosionFilter.ts":
/*!**************************************************!*\
  !*** ./client/ts/game/filter/ExplosionFilter.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExplosionFilter = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ColorFramebuffer_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/internal/ColorFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst PostProcessingFilter_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/material/PostProcessingFilter */ \"./hingler-party/client/ts/engine/material/PostProcessingFilter.ts\");\nconst RadialBlur_1 = __webpack_require__(/*! ./RadialBlur */ \"./client/ts/game/filter/RadialBlur.ts\");\nconst model_1 = __webpack_require__(/*! nekogirl-valhalla/model */ \"./node_modules/nekogirl-valhalla/model/index.js\");\nconst gradientCols = [\n    [0.004985, 0.001524, 0.0, 1.0],\n    [0.027342, 0.002434, 0.0, 1.0],\n    [0.588432, 0.062403, 0.0, 1.0],\n    [0.885711, 0.613466, 0.220887, 1.0]\n];\nconst gradientStops = [\n    0.0,\n    0.440909,\n    0.513637,\n    0.818182\n];\nclass ExplosionFilter extends PostProcessingFilter_1.PostProcessingFilter {\n    // blur 8x8 = 64, run 3 times for effectively smooth steps in 24 texfetches\n    constructor(ctx, explosion, explosionCenter) {\n        super(ctx);\n        this.explosion = explosion;\n        this.explosionCenter = explosionCenter;\n        this.explosionFramebuffer = new ColorFramebuffer_1.ColorFramebuffer(ctx, ctx.getScreenDims());\n        this.explosionSwap = new ColorFramebuffer_1.ColorFramebuffer(ctx, ctx.getScreenDims());\n        this.blur = new RadialBlur_1.RadialBlur(ctx);\n        this.blurMag = 0.55;\n        this.glowShader = null;\n        this.explosionColorShader = null;\n        // load model from res\n        // either way we have to draw our explosion twice (?)\n        // how about we implement the render func elsewhere and expose this one separately?\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/explosionglow/explosionglow.vert\")\n            .withFragmentShader(\"../glsl/game/explosionglow/explosionglow.frag\")\n            .build()\n            .then(this.bindUniformsGlow.bind(this));\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/termshock/termshock.vert\")\n            .withFragmentShader(\"../glsl/game/termshock/termshock.frag\")\n            .build()\n            .then(this.bindUniformsColor.bind(this));\n    }\n    bindUniformsGlow(prog) {\n        this.glowShader = prog;\n        let gl = this.getContext().getGLContext();\n        this.posLoc = gl.getAttribLocation(prog, \"aPosition\");\n        this.colUnif = gl.getUniformLocation(prog, \"uColor\");\n        this.depthUnif = gl.getUniformLocation(prog, \"uDepth\");\n        this.explosionUnif = gl.getUniformLocation(prog, \"uExplosion\");\n        this.glowCenter = gl.getUniformLocation(prog, \"glowCenter\");\n        this.blurDist = gl.getUniformLocation(prog, \"dist\");\n    }\n    bindUniformsColor(prog) {\n        this.explosionColorShader = prog;\n        let gl = this.getContext().getGLContext();\n        const ctx = this.getContext().getGL();\n        ctx.useProgram(prog);\n        for (let i = 0; i < 4; i++) {\n            gl.uniform4fv(gl.getUniformLocation(this.explosionColorShader, \"gradientCols[\" + i + \"]\"), gradientCols[i]);\n            gl.uniform1f(gl.getUniformLocation(this.explosionColorShader, \"gradientStops[\" + i + \"]\"), gradientStops[i]);\n        }\n        this.posLocColor = gl.getAttribLocation(prog, \"aPosition\");\n        this.modelMatUnif = gl.getUniformLocation(prog, \"model_matrix\");\n        this.vpMatUnif = gl.getUniformLocation(prog, \"vp_matrix\");\n        this.resolutionUnif = gl.getUniformLocation(prog, \"resolution\");\n        this.depthUnifCol = gl.getUniformLocation(prog, \"uDepth\");\n        this.explosionZ = gl.getUniformLocation(prog, \"explosionZ\");\n    }\n    runFilter(src, dst, rc) {\n        const timer = this.getContext().getGPUTimer();\n        const id = timer.startQuery();\n        if (this.explosionColorShader !== null && this.glowShader !== null) {\n            let gl = this.getContext().getGLContext();\n            gl.disable(gl.CULL_FACE);\n            let oldDims = this.explosionFramebuffer.dims;\n            let newDims = this.getContext().getScreenDims();\n            if (oldDims[0] !== newDims[0] || oldDims[1] !== newDims[1]) {\n                this.explosionFramebuffer.setFramebufferSize(newDims);\n                this.explosionSwap.setFramebufferSize(newDims);\n            }\n            gl.viewport(0, 0, newDims[0], newDims[1]);\n            this.explosionFramebuffer.bindFramebuffer(gl.FRAMEBUFFER);\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            // render our explosion object to the explosion framebuffer\n            this.vpMat = rc.getActiveCameraInfo().vpMatrix;\n            this.tex = src.getDepthTexture();\n            // enable pos\n            this.explosion.drawModel(rc, this);\n            gl.disable(gl.BLEND);\n            // use a model object to accomplish that\n            // explosion fb now contains our explosion w depth acc'd for\n            this.drawToFramebuffer(src, dst, rc);\n        }\n        timer.stopQueryAndLog(id, \"ExplosionFilter\", performanceanalytics_1.RenderType.POST);\n    }\n    drawMaterial(model) {\n        let gl = this.getContext().getGLContext();\n        const ctx = this.getContext().getGL();\n        ctx.useProgram(this.explosionColorShader);\n        gl.uniformMatrix4fv(this.modelMatUnif, false, this.explosion.getTransformationMatrix());\n        gl.uniformMatrix4fv(this.vpMatUnif, false, this.vpMat);\n        gl.uniform2fv(this.resolutionUnif, this.getContext().getScreenDims());\n        // some weird shit when z is less than 0\n        gl.uniform1f(this.explosionZ, this.explosion.getPosition()[0] + 50);\n        this.tex.bindToUniform(this.depthUnifCol, 1);\n        model.bindAttribute(model_1.AttributeType.POSITION, this.posLocColor);\n        model.draw();\n    }\n    drawToFramebuffer(src, dst, rc) {\n        // bind explosion texture\n        const EXPLOSION_SIZE = 0.55;\n        let gl = this.getContext().getGLContext();\n        const wrap = this.getContext().getGL();\n        let explosionCenterCoord = gl_matrix_1.vec4.create();\n        let explosionCenterPos = this.explosionCenter.getGlobalPosition();\n        explosionCenterCoord = gl_matrix_1.vec4.fromValues(explosionCenterPos[0], explosionCenterPos[1], explosionCenterPos[2], 1.0);\n        gl_matrix_1.vec4.transformMat4(explosionCenterCoord, explosionCenterCoord, this.vpMat);\n        explosionCenterCoord = explosionCenterCoord.map((val) => ((val / explosionCenterCoord[3]) + 1) / 2);\n        this.blur.center = [explosionCenterCoord[0], explosionCenterCoord[1]];\n        this.blur.sampleCount = 8;\n        this.blur.size = this.blurMag;\n        this.blur.runFilter(this.explosionFramebuffer, this.explosionSwap, rc);\n        this.blur.size = this.blurMag / 8;\n        this.blur.runFilter(this.explosionSwap, this.explosionFramebuffer, rc);\n        wrap.useProgram(this.glowShader);\n        dst.bindFramebuffer(gl.FRAMEBUFFER);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        let buf = this.getScreenBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, buf);\n        gl.vertexAttribPointer(this.posLoc, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(this.posLoc);\n        // bind fb texture\n        src.getColorTexture().bindToUniform(this.colUnif, 1);\n        src.getDepthTexture().bindToUniform(this.depthUnif, 2);\n        this.explosionFramebuffer.getColorTexture().bindToUniform(this.explosionUnif, 3);\n        // src to swap, swap to src, then run the rest\n        gl.uniform2fv(this.glowCenter, explosionCenterCoord.slice(0, 2));\n        wrap.uniform1f(this.blurDist, this.blurMag / 64);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        gl.disableVertexAttribArray(this.posLoc);\n    }\n}\nexports.ExplosionFilter = ExplosionFilter;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/filter/ExplosionFilter.ts?");

/***/ }),

/***/ "./client/ts/game/filter/RadialBlur.ts":
/*!*********************************************!*\
  !*** ./client/ts/game/filter/RadialBlur.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// radial blur filter\n// accept two framebuffers, and perform a radial blur on them\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RadialBlur = void 0;\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst PostProcessingFilter_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/material/PostProcessingFilter */ \"./hingler-party/client/ts/engine/material/PostProcessingFilter.ts\");\nclass RadialBlur extends PostProcessingFilter_1.PostProcessingFilter {\n    constructor(ctx) {\n        super(ctx);\n        this.prog = null;\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/radialblur/radialblur.vert\")\n            .withFragmentShader(\"../glsl/game/radialblur/radialblur.frag\")\n            .build()\n            .then(this.prepareUniforms.bind(this));\n    }\n    prepareUniforms(prog) {\n        let gl = this.getContext().getGLContext();\n        this.prog = prog;\n        this.aPosition = gl.getAttribLocation(prog, \"aPosition\");\n        this.uBlurColor = gl.getUniformLocation(prog, \"uBlurColor\");\n        this.glowCenter = gl.getUniformLocation(prog, \"glowCenter\");\n        this.samples = gl.getUniformLocation(prog, \"samples\");\n        this.blurSize = gl.getUniformLocation(prog, \"blurSize\");\n    }\n    runFilter(src, dst, rc) {\n        if (this.prog !== null) {\n            let gl = this.getContext().getGLContext();\n            // copy src to dst\n            // return boolean if any work done? i dont want to have to copy the fb over :(\n            dst.bindFramebuffer(gl.FRAMEBUFFER);\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            const wrap = this.getContext().getGL();\n            wrap.useProgram(this.prog);\n            src.getColorTexture().bindToUniform(this.uBlurColor, 1);\n            gl.uniform2fv(this.glowCenter, this.center);\n            wrap.uniform1i(this.samples, this.sampleCount);\n            wrap.uniform1f(this.blurSize, this.size);\n            let buf = this.getScreenBuffer();\n            wrap.bindBuffer(gl.ARRAY_BUFFER, buf);\n            gl.vertexAttribPointer(this.aPosition, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.aPosition);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.aPosition);\n        }\n    }\n}\nexports.RadialBlur = RadialBlur;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/filter/RadialBlur.ts?");

/***/ }),

/***/ "./client/ts/game/manager/InputManager.ts":
/*!************************************************!*\
  !*** ./client/ts/game/manager/InputManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MOTION_INPUT = exports.InputType = void 0;\nconst PlayerInputState_1 = __webpack_require__(/*! ../PlayerInputState */ \"./client/ts/game/PlayerInputState.ts\");\nvar InputType;\n(function (InputType) {\n    InputType[InputType[\"MOVE_LEFT\"] = 0] = \"MOVE_LEFT\";\n    InputType[InputType[\"MOVE_RIGHT\"] = 1] = \"MOVE_RIGHT\";\n    InputType[InputType[\"MOVE_UP\"] = 2] = \"MOVE_UP\";\n    InputType[InputType[\"MOVE_DOWN\"] = 3] = \"MOVE_DOWN\";\n})(InputType = exports.InputType || (exports.InputType = {}));\n;\nexports.MOTION_INPUT = [PlayerInputState_1.PlayerInputState.MOVE_DOWN, PlayerInputState_1.PlayerInputState.MOVE_LEFT, PlayerInputState_1.PlayerInputState.MOVE_RIGHT, PlayerInputState_1.PlayerInputState.MOVE_UP];\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/InputManager.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/EnemyMap.ts":
/*!*****************************************************!*\
  !*** ./client/ts/game/manager/internal/EnemyMap.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EnemyMap = void 0;\nclass EnemyMapIterator {\n    constructor(map) {\n        this.keys = map.keys();\n        this.map = map;\n    }\n    next() {\n        let temp = this.keys.next();\n        // return copies!!! :D\n        return {\n            done: temp.done,\n            value: [temp.value, this.map.get(temp.value)]\n        };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nclass EnemyMap {\n    constructor() {\n        this.map = new Map();\n        this.positionToId = new Map();\n    }\n    hashCoordinate(x, y) {\n        return Math.round(y) + Math.round(x) * 32;\n    }\n    get size() {\n        return this.map.size;\n    }\n    entries() {\n        return this.map.entries();\n    }\n    keys() {\n        return this.map.keys();\n    }\n    values() {\n        return this.map.values();\n    }\n    getEnemiesAtCoordinate(x, y) {\n        let hash = this.hashCoordinate(x, y);\n        if (this.positionToId.has(hash)) {\n            let ret = [];\n            let res = this.positionToId.get(hash);\n            for (let enemyID of res) {\n                ret.push([enemyID, this.map.get(enemyID).copyInstance()]);\n            }\n            return ret;\n        }\n        return [];\n    }\n    getTilesInRange(minX, minY, maxX, maxY) {\n        let ret = [];\n        for (let x = minX; x <= maxX; x++) {\n            for (let y = minY; y <= maxY; y++) {\n                ret.concat(this.getEnemiesAtCoordinate(x, y));\n            }\n        }\n        return ret;\n    }\n    [Symbol.iterator]() {\n        // note: this is a risky vector\n        // would like some way to return copies instead of the real deal since it muddies\n        // our internal state\n        // whatever i'll do it later\n        return new EnemyMapIterator(this);\n    }\n    get [Symbol.toStringTag]() {\n        return this.map[Symbol.toStringTag];\n    }\n    clear() {\n        this.map.clear();\n        this.positionToId.clear();\n    }\n    delete(key) {\n        if (this.map.has(key)) {\n            let e = this.map.get(key);\n            let hash = this.hashCoordinate(Math.round(e.position[0]), Math.round(e.position[1]));\n            if (!this.positionToId.has(hash) || !this.positionToId.get(hash).has(key)) {\n                const err = \"Invariant violated: entity does not have entry in posToID!\";\n                throw Error(err);\n            }\n            this.positionToId.get(hash).delete(key);\n            this.map.delete(key);\n            return true;\n        }\n        return false;\n    }\n    forEach(callbackfn, thisArg) {\n        for (let key of this.map.keys()) {\n            callbackfn.bind((thisArg ? thisArg : this))(this.map.get(key), key, this.map);\n        }\n        this.positionToId.clear();\n        // assume data has been modified, rehash.\n        // assume hashes might clash, but we have a guarantee that everything at a coordinate is in a hash value.\n        for (let entry of this.map.keys()) {\n            this.insertInstanceToPID(entry[0], entry[1]);\n        }\n    }\n    insertInstanceToPID(id, inst) {\n        let hash = this.hashCoordinate(Math.round(inst.position[0]), Math.round(inst.position[1]));\n        if (!this.positionToId.has(hash)) {\n            this.positionToId.set(hash, new Set());\n        }\n        this.positionToId.get(hash).add(id);\n    }\n    get(key) {\n        let res = this.map.get(key);\n        if (res !== undefined) {\n            return res.copyInstance();\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    set(key, value) {\n        let old = this.map.get(key);\n        if (old !== undefined) {\n            let oldRecord = this.positionToId.get(this.hashCoordinate(old.position[0], old.position[1]));\n            if (!oldRecord || !oldRecord.has(key)) {\n                throw Error(\"Invalidated invariant: entry not associated with position!\");\n            }\n            oldRecord.delete(key);\n        }\n        this.insertInstanceToPID(key, value);\n        this.map.set(key, value);\n        return this;\n    }\n}\nexports.EnemyMap = EnemyMap;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/EnemyMap.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/FieldManagerSinglePlayer.ts":
/*!*********************************************************************!*\
  !*** ./client/ts/game/manager/internal/FieldManagerSinglePlayer.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FieldManagerSinglePlayer = void 0;\nconst GrassFieldManager_1 = __webpack_require__(/*! ./fieldmgr/GrassFieldManager */ \"./client/ts/game/manager/internal/fieldmgr/GrassFieldManager.ts\");\nconst LavaFieldManager_1 = __webpack_require__(/*! ./fieldmgr/LavaFieldManager */ \"./client/ts/game/manager/internal/fieldmgr/LavaFieldManager.ts\");\nconst BeachFieldManager_1 = __webpack_require__(/*! ./fieldmgr/BeachFieldManager */ \"./client/ts/game/manager/internal/fieldmgr/BeachFieldManager.ts\");\nconst MountainFieldManager_1 = __webpack_require__(/*! ./fieldmgr/MountainFieldManager */ \"./client/ts/game/manager/internal/fieldmgr/MountainFieldManager.ts\");\nconst BridgeFieldManager_1 = __webpack_require__(/*! ./fieldmgr/BridgeFieldManager */ \"./client/ts/game/manager/internal/fieldmgr/BridgeFieldManager.ts\");\nclass FieldManagerSinglePlayer {\n    constructor(ctx, width) {\n        this.width = width;\n        this.grassmgr = new GrassFieldManager_1.GrassFieldManager(ctx, this.width);\n        this.lavamgr = new LavaFieldManager_1.LavaFieldManager(ctx, this.width);\n        this.beachmgr = new BeachFieldManager_1.BeachFieldManager(ctx, this.width);\n        this.bridgemgr = new BridgeFieldManager_1.BridgeFieldManager(ctx, this.width);\n        this.mountmgr = new MountainFieldManager_1.MountainFieldManager(ctx, this.width);\n        this.grassLen = 10;\n        this.beachLen = 10;\n    }\n    getFieldModel(n) {\n        // let field managers take care of it\n        // delegate responsibility for transitional fields to the next field\n        // start from 0 at tx point\n        if (n < this.grassLen) {\n            return this.grassmgr.getFieldModel(n);\n        }\n        else if (n < (this.grassLen + this.beachLen)) {\n            return this.beachmgr.getFieldModel(n - this.grassLen);\n        }\n        else {\n            return this.bridgemgr.getFieldModel(n - (this.grassLen + this.beachLen));\n        }\n    }\n    setFieldSeed(n) {\n        this.seed = n;\n        this.grassmgr.setFieldSeed(n);\n        this.lavamgr.setFieldSeed(n);\n        this.beachmgr.setFieldSeed(n);\n        this.mountmgr.setFieldSeed(n);\n    }\n    setGrassLength(n) {\n        this.grassLen = n;\n    }\n    setBeachLength(n) {\n        this.beachLen = n;\n    }\n}\nexports.FieldManagerSinglePlayer = FieldManagerSinglePlayer;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/FieldManagerSinglePlayer.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/InputManagerImpl.ts":
/*!*************************************************************!*\
  !*** ./client/ts/game/manager/internal/InputManagerImpl.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InputManagerImpl = void 0;\nconst PlayerInputState_1 = __webpack_require__(/*! ../../PlayerInputState */ \"./client/ts/game/PlayerInputState.ts\");\nclass InputManagerImpl {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.keyToInput = new Map();\n        this.inputToKey = new Map();\n        this.listeners = new Map();\n        this.listenerCount = 0;\n        this.pressedKeys = new Set();\n        this.touchMap = new Map();\n        this.dirTouch = -1;\n        this.touchDir = PlayerInputState_1.PlayerInputState.IDLE;\n        this.bomb = false;\n        this.detonate = false;\n        this.bombID = -1;\n        this.detonateID = -1;\n        this.touchImg = document.getElementById(\"touch-direction\");\n        addEventListener(\"keydown\", this.handlekeydown_.bind(this));\n        addEventListener(\"keyup\", this.handlekeyup_.bind(this));\n        document.body.addEventListener(\"touchstart\", this.handletouchstart_.bind(this), { capture: true, passive: true });\n        // add touch listeners to our buttons\n        let dir = this.touchImg;\n        dir.addEventListener(\"touchstart\", this.handletouchdirinput_.bind(this), { capture: true, passive: true });\n        document.body.addEventListener(\"touchmove\", this.updatetouchids_.bind(this), { capture: true, passive: false });\n        document.body.addEventListener(\"touchend\", this.removetouchids_.bind(this), true);\n        document.getElementById(\"touch-detonate\").addEventListener(\"touchstart\", (e) => { console.log(\"register touch start\"); this.detonate = true; for (let t of e.changedTouches) {\n            this.detonateID = t.identifier;\n        } }, { capture: true, passive: true });\n        document.getElementById(\"touch-bomb\").addEventListener(\"touchstart\", (e) => { console.log(\"register touch start\"); this.bomb = true; for (let t of e.changedTouches) {\n            this.bombID = t.identifier;\n        } }, { capture: true, passive: true });\n        if (this.ctx.mobile) {\n            document.getElementById(\"touch-controls\").classList.remove(\"hidden\");\n        }\n    }\n    handletouchstart_(e) {\n        document.getElementById(\"touch-controls\").classList.remove(\"hidden\");\n        for (let touch of e.changedTouches) {\n            this.touchMap.set(touch.identifier, touch);\n        }\n    }\n    handletouchdirinput_(e) {\n        // if they're simultaneous, just grab one\n        console.log(\"this is the body touch start -- might be the issue?\");\n        for (let touch of e.changedTouches) {\n            this.dirTouch = touch.identifier;\n            this.setTouchZone(touch);\n        }\n    }\n    updatetouchids_(e) {\n        e.preventDefault();\n        for (let touch of e.changedTouches) {\n            this.touchMap.set(touch.identifier, touch);\n            if (this.dirTouch === touch.identifier) {\n                this.handleDirTouch_(touch);\n            }\n        }\n    }\n    handleDirTouch_(e) {\n        this.setTouchZone(e);\n    }\n    setTouchZone(e) {\n        let rect = this.touchImg.getBoundingClientRect();\n        let center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n        let dist = [e.clientX - center[0], e.clientY - center[1]];\n        const ONE_SQRT_TWO = 1.0 / Math.sqrt(2);\n        const M_PI_2 = Math.PI / 2;\n        // rotate 45 degrees to make math easier\n        dist = [ONE_SQRT_TWO * dist[0] - ONE_SQRT_TWO * dist[1], ONE_SQRT_TWO * dist[0] + ONE_SQRT_TWO * dist[1]];\n        let theta = Math.atan2(dist[1], dist[0]);\n        if ((Math.pow(dist[0], 2) + Math.pow(dist[1], 2)) > 400) {\n            // 20 px radius dead zone\n            if (theta < -M_PI_2) {\n                this.touchDir = PlayerInputState_1.PlayerInputState.MOVE_LEFT;\n            }\n            else if (theta < 0) {\n                this.touchDir = PlayerInputState_1.PlayerInputState.MOVE_UP;\n            }\n            else if (theta < M_PI_2) {\n                this.touchDir = PlayerInputState_1.PlayerInputState.MOVE_RIGHT;\n            }\n            else {\n                this.touchDir = PlayerInputState_1.PlayerInputState.MOVE_DOWN;\n            }\n        }\n    }\n    removetouchids_(e) {\n        for (let touch of e.changedTouches) {\n            this.touchMap.delete(touch.identifier);\n            if (this.dirTouch === touch.identifier) {\n                this.dirTouch = -1;\n                this.touchDir = PlayerInputState_1.PlayerInputState.IDLE;\n            }\n            else if (this.bombID === touch.identifier) {\n                this.bombID = -1;\n                this.bomb = false;\n            }\n            else if (this.detonateID === touch.identifier) {\n                this.detonateID = -1;\n                this.detonate = false;\n            }\n        }\n    }\n    handlekeydown_(e) {\n        document.getElementById(\"touch-controls\").classList.add(\"hidden\");\n        this.pressedKeys.add(e.code);\n    }\n    handlekeyup_(e) {\n        this.pressedKeys.delete(e.code);\n    }\n    setKey(input, keycode) {\n        this.keyToInput.set(keycode, input);\n        if (!this.inputToKey.has(input)) {\n            this.inputToKey.set(input, new Set());\n        }\n        this.inputToKey.get(input).add(keycode);\n    }\n    unsetKey(keycode) {\n        if (this.keyToInput.has(keycode)) {\n            let input = this.keyToInput.get(keycode);\n            this.keyToInput.delete(keycode);\n            if (!this.inputToKey.has(input) || !this.inputToKey.get(input).has(keycode)) {\n                throw Error(\"Invariant invalidated\");\n            }\n            this.inputToKey.get(input).delete(keycode);\n        }\n    }\n    getKeyBindings(input) {\n        if (this.inputToKey.has(input)) {\n            let res = new Set();\n            for (let i of this.inputToKey.get(input)) {\n                res.add(i);\n            }\n            return res;\n        }\n        return new Set();\n    }\n    getKeyState(keycode) {\n        return this.pressedKeys.has(keycode);\n    }\n    getInputState() {\n        let res = new Set();\n        if (this.touchDir !== PlayerInputState_1.PlayerInputState.IDLE) {\n            res.add(this.touchDir);\n        }\n        if (this.bomb) {\n            res.add(PlayerInputState_1.PlayerInputState.BOMB_PLACE);\n        }\n        if (this.detonate) {\n            res.add(PlayerInputState_1.PlayerInputState.BOMB_DETONATE);\n        }\n        for (let key of this.pressedKeys) {\n            if (this.keyToInput.has(key)) {\n                res.add(this.keyToInput.get(key));\n            }\n        }\n        return res;\n    }\n    registerKeyListener(func) {\n        let id = this.listenerCount++;\n        this.listeners.set(id, func);\n        return id;\n    }\n    removeKeyListener(l) {\n        if (this.listeners.has(l)) {\n            this.listeners.delete(l);\n        }\n    }\n}\nexports.InputManagerImpl = InputManagerImpl;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/InputManagerImpl.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/SinglePlayerMapState.ts":
/*!*****************************************************************!*\
  !*** ./client/ts/game/manager/internal/SinglePlayerMapState.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// how to construct\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SinglePlayerMapState = void 0;\nconst GameConnectionManagerSinglePlayer_1 = __webpack_require__(/*! ../../GameConnectionManagerSinglePlayer */ \"./client/ts/game/GameConnectionManagerSinglePlayer.ts\");\nconst LayerInstance_1 = __webpack_require__(/*! ../../tile/LayerInstance */ \"./client/ts/game/tile/LayerInstance.ts\");\nconst TileID_1 = __webpack_require__(/*! ../../tile/TileID */ \"./client/ts/game/tile/TileID.ts\");\nconst GridTileGenerator_1 = __webpack_require__(/*! ../../tilegen/GridTileGenerator */ \"./client/ts/game/tilegen/GridTileGenerator.ts\");\nconst TileGrid_1 = __webpack_require__(/*! ../../TileGrid */ \"./client/ts/game/TileGrid.ts\");\nconst EnemyMap_1 = __webpack_require__(/*! ./EnemyMap */ \"./client/ts/game/manager/internal/EnemyMap.ts\");\nclass SinglePlayerMapState {\n    constructor(len) {\n        this.gen = new GridTileGenerator_1.GridTileGenerator(len);\n        this.len = len;\n        this.cache = new TileGrid_1.TileGrid();\n        this.cache.setOrigin(0, 0);\n        this.cache.setDims(128, len);\n        this.layer = new EnemyMap_1.EnemyMap();\n        this.enemy = new EnemyMap_1.EnemyMap();\n        this.nextID = 0;\n    }\n    get dims() {\n        return [Number.MAX_SAFE_INTEGER, this.len];\n    }\n    fetchTiles(x, y, dx, dy) {\n        // generate tiles up to our desired value and add them to the cache\n        this.generateTiles(x + dx + 1);\n        return this.cache.slice(x, y, dx, dy);\n    }\n    getTile(x, y) {\n        this.generateTiles(x + 1);\n        return this.cache.getTile(x, y);\n    }\n    setTile(x, y, id) {\n        this.generateTiles(x + 1);\n        if (y < 0 || y > this.len || x < 0) {\n            console.warn(\"Attempting to set a tile which should not be defined!\");\n        }\n        this.cache.setTile(x, y, id);\n    }\n    generateTiles(xMax) {\n        for (let i = (this.cache.origin[0] + this.cache.dims[0]); i < xMax; i++) {\n            let genTiles = this.gen.generateColumn();\n            for (let j = 0; j < this.len; j++) {\n                this.cache.setTile(i, j, genTiles[j]);\n                // for a random generated tile, set some probability of placing an enemy\n                // as newer enemies appear, decrement the probability of older enemies appearing\n                // use the distance from the last zone start to set the odds of enemies spawning\n                // determine that we need to spawn an enemy\n                // for all enemy types, run down the list (right now: crab > knight)\n                // start with base, introduce 66 percent chance of upgrading\n                // set \n                if (genTiles[j] === TileID_1.TileID.EMPTY && i > this.knightStart && (Math.random() < 0.03)) {\n                    // tracking ID :(\n                    let type;\n                    if (i > (this.goatStart)) {\n                        type = TileID_1.TileID.ENEMY_GOAT;\n                    }\n                    else if (i > (this.crabStart)) {\n                        type = TileID_1.TileID.ENEMY_CRAB;\n                    }\n                    else {\n                        type = TileID_1.TileID.ENEMY_KNIGHT;\n                    }\n                    // 25 percent chance of \"downgrading\" to previous enemy type\n                    // 75 pct cur zone\n                    // 18.75 pct last zone\n                    // 4.5625 pct of zone before that\n                    // 1.140625 pct even earlier... etc\n                    while (type > TileID_1.TileID.ENEMY_KNIGHT && Math.random() < 0.25) {\n                        type--;\n                    }\n                    let enemy;\n                    switch (type) {\n                        case TileID_1.TileID.ENEMY_GOAT:\n                            enemy = new LayerInstance_1.GoatInstance();\n                            break;\n                        case TileID_1.TileID.ENEMY_CRAB:\n                        case TileID_1.TileID.ENEMY_KNIGHT:\n                            enemy = new LayerInstance_1.EnemyInstance();\n                            break;\n                    }\n                    enemy.type = type;\n                    enemy.position = [i, j, 0];\n                    enemy.direction = GameConnectionManagerSinglePlayer_1.PLAYER_MOTION_STATES[Math.floor(Math.random() * 4)];\n                    if (enemy.type === TileID_1.TileID.ENEMY_GOAT) {\n                        let enemyGoat = enemy;\n                        enemyGoat.runTime = 0;\n                        enemyGoat.stunTime = 0;\n                        console.log(enemyGoat);\n                        // :sade:\n                        this.enemy.set(this.nextID++, enemyGoat);\n                    }\n                    else {\n                        this.enemy.set(this.nextID++, enemy);\n                    }\n                }\n            }\n        }\n    }\n}\nexports.SinglePlayerMapState = SinglePlayerMapState;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/SinglePlayerMapState.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/SkyboxManagerSinglePlayer.ts":
/*!**********************************************************************!*\
  !*** ./client/ts/game/manager/internal/SkyboxManagerSinglePlayer.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SkyboxManagerSinglePlayer = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst SkyboxObject_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/object/game/SkyboxObject */ \"./hingler-party/client/ts/engine/object/game/SkyboxObject.ts\");\nconst BASE_FIELD_INTENSITY = 1.0;\nconst BASE_BEACH_INTENSITY = 0.8;\nconst BASE_BRIDGE_INTENSITY = 1.0;\n// just deal with the coupling in later implementations\nclass SkyboxManagerSinglePlayer extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        this.fieldSkybox = new SkyboxObject_1.SkyboxObject(ctx, \"../res/hdr/hdr_field_1k.hdr\");\n        this.beachSkybox = new SkyboxObject_1.SkyboxObject(ctx, \"../res/hdr/hdr_beach_1k.hdr\");\n        this.bridgeSkybox = new SkyboxObject_1.SkyboxObject(ctx, \"../res/hdr/hdr_bridge_1k.hdr\");\n        this.intensityMul = 1.0;\n        this.addChild(this.fieldSkybox);\n        this.addChild(this.beachSkybox);\n        this.addChild(this.bridgeSkybox);\n    }\n    updateSkyboxes(len) {\n        if (len > (this.fieldLength + this.beachLength)) {\n            const t = (len - (this.beachLength + this.fieldLength)) / 48;\n            this.fieldSkybox.intensity = 0;\n            this.beachSkybox.intensity = Math.max(1.0 - t, 0.0) * BASE_BEACH_INTENSITY * this.intensityMul;\n            this.bridgeSkybox.intensity = Math.min(1.0, t) * BASE_BRIDGE_INTENSITY * this.intensityMul;\n        }\n        else if (len > this.fieldLength) {\n            const t = (len - this.fieldLength) / 48;\n            this.fieldSkybox.intensity = Math.max(1.0 - t, 0.0) * BASE_FIELD_INTENSITY * this.intensityMul;\n            this.beachSkybox.intensity = Math.min(1.0, t) * BASE_BEACH_INTENSITY * this.intensityMul;\n            this.bridgeSkybox.intensity = 0;\n        }\n        else {\n            this.fieldSkybox.intensity = BASE_FIELD_INTENSITY * this.intensityMul;\n            this.beachSkybox.intensity = 0;\n            this.bridgeSkybox.intensity = 0;\n        }\n    }\n}\nexports.SkyboxManagerSinglePlayer = SkyboxManagerSinglePlayer;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/SkyboxManagerSinglePlayer.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/TileManagerSinglePlayer.ts":
/*!********************************************************************!*\
  !*** ./client/ts/game/manager/internal/TileManagerSinglePlayer.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileManagerSinglePlayer = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst TileFactoryStub_1 = __webpack_require__(/*! ../../../../../test/stub/TileFactoryStub */ \"./test/stub/TileFactoryStub.ts\");\nconst TerminationShock_1 = __webpack_require__(/*! ../../field/TerminationShock */ \"./client/ts/game/field/TerminationShock.ts\");\nconst PlayerGameObject_1 = __webpack_require__(/*! ../../PlayerGameObject */ \"./client/ts/game/PlayerGameObject.ts\");\nconst PlayerInputState_1 = __webpack_require__(/*! ../../PlayerInputState */ \"./client/ts/game/PlayerInputState.ts\");\nconst LavaTileFactory_1 = __webpack_require__(/*! ../../tile/instancefactory/LavaTileFactory */ \"./client/ts/game/tile/instancefactory/LavaTileFactory.ts\");\nconst TileGrid_1 = __webpack_require__(/*! ../../TileGrid */ \"./client/ts/game/TileGrid.ts\");\nconst FieldManagerSinglePlayer_1 = __webpack_require__(/*! ./FieldManagerSinglePlayer */ \"./client/ts/game/manager/internal/FieldManagerSinglePlayer.ts\");\nconst TILES_PER_FIELD = 24;\nconst LAVA_BARRIER = 240;\n// todo: lots of redundancy between this and what the multiplayer ver would look like\n// before creating a multiplayer, factor it out!\nclass TileManagerSinglePlayer {\n    constructor(ctx, cam, player, field) {\n        this.ctx = ctx;\n        this.eep = player;\n        this.shockLoc = -100;\n        // :sade:\n        if (field) {\n            this.fieldmgr = field;\n        }\n        else {\n            this.fieldmgr = new FieldManagerSinglePlayer_1.FieldManagerSinglePlayer(ctx, 11);\n        }\n        this.root = new GameObject_1.GameObject(ctx);\n        let shockScene = ctx.getGLTFLoader().loadAsGLTFScene(\"../res/terminationshock.glb\");\n        let shockSceneTask = new Task_1.Task();\n        shockScene.then(scene => {\n            shockSceneTask.resolve(scene.getModel(\"explosion\"));\n        });\n        this.termShock = new TerminationShock_1.TerminationShock(ctx, shockSceneTask.getFuture(), cam);\n        this.root.addChild(this.termShock);\n        this.tilesDestroying = new Set();\n        this.fieldPieces = new Array(3);\n        this.fieldIndex = -1;\n        this.deathDelta = 0;\n        // bombs should probably be instanced but i dont care right now\n        this.lastUpdateGrid = new TileGrid_1.TileGrid();\n        this.tilesCurrentGrid = new TileGrid_1.TileGrid();\n        this.xOffset = 0;\n        this.players = new Map();\n        this.layerInstances = new Map();\n        this.factory = new TileFactoryStub_1.TileFactoryStub(ctx);\n        this.factoryLava = new LavaTileFactory_1.LavaTileFactory(ctx);\n    }\n    clear() {\n        for (let inst of this.layerInstances) {\n            this.root.removeChild(inst[1].getId());\n        }\n        this.layerInstances.clear();\n        this.lastUpdateGrid = new TileGrid_1.TileGrid();\n        // todo: make tilegrid iterable\n        for (let tile of this.tilesDestroying) {\n            this.root.removeChild(tile.getId());\n        }\n        this.tilesDestroying.clear();\n    }\n    setTileOrigin(origin) {\n        this.origin = origin;\n        // adjust position of all tiles\n    }\n    getPlayerPosition(id) {\n        if (this.players.has(id)) {\n            return this.players.get(id).getGlobalPosition();\n        }\n        return [0, 0, 0];\n    }\n    setTermShockPosition(pos) {\n        this.shockLoc = pos;\n    }\n    updateTiles(state, players) {\n        // figure out where the player is (later)\n        // fetch only the tiles around them\n        // update those\n        // drop the rest on some even ratio\n        let offset = gl_matrix_1.vec2.create();\n        let playerInfo = players.get(1);\n        if (!players.has(1)) {\n            throw Error(\"Single player not available :(\");\n        }\n        if (!this.players.has(1)) {\n            let guy = new PlayerGameObject_1.PlayerGameObject(this.ctx, this.eep);\n            this.players.set(1, guy);\n            this.root.addChild(guy);\n        }\n        // configure our blur effect\n        this.termShock.setPosition(this.shockLoc * 2 + this.origin[0], 0, 0);\n        let blurMag = 1.0 - Math.min(Math.max((playerInfo.position[0] - this.shockLoc - 5) / 10, 0), 1);\n        this.termShock.setBlur(0.05 + (blurMag * 0.5));\n        let playerObject = this.players.get(1);\n        offset[0] = (2 * playerInfo.position[0]) + this.origin[0];\n        offset[1] = (2 * playerInfo.position[1]) + this.origin[1];\n        if (playerInfo.dead) {\n            playerObject.setRotationEuler(0, 90, 0);\n        }\n        else {\n            switch (playerInfo.lastInput) {\n                case PlayerInputState_1.PlayerInputState.MOVE_DOWN:\n                    playerObject.setRotationEuler(0, 0, 0);\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_LEFT:\n                    playerObject.setRotationEuler(0, 270, 0);\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_UP:\n                    playerObject.setRotationEuler(0, 180, 0);\n                    break;\n                case PlayerInputState_1.PlayerInputState.MOVE_RIGHT:\n                default:\n                    playerObject.setRotationEuler(0, 90, 0);\n            }\n        }\n        playerObject.setPosition(offset[0], 0, offset[1]);\n        if (playerInfo.dead) {\n            playerObject.getSpot().intensity = Math.min(this.deathDelta * 4, 1);\n            if (this.shockLoc - (playerInfo.position[0]) > 4.0) {\n                playerObject.getSpot().intensity = 0;\n            }\n            this.deathDelta += this.ctx.getDelta();\n            playerObject.setPivotRotation(Math.min(this.deathDelta * 90, 90));\n        }\n        else {\n            this.deathDelta = 0;\n            playerObject.getSpot().intensity = 0;\n            playerObject.setPivotRotation(0);\n        }\n        // read around player\n        let tiles = state.fetchTiles(Math.floor(playerInfo.position[0] - 25), Math.floor(playerInfo.position[1] - 25), 50, 50);\n        // fetch only around the player\n        // clear outside of a range\n        let xOrigin = tiles.origin[0];\n        let yOrigin = tiles.origin[1];\n        let xDims = tiles.dims[0] + xOrigin;\n        let yDims = tiles.dims[1] + yOrigin;\n        for (let i = xOrigin; i < xDims; i++) {\n            for (let j = yOrigin; j < yDims; j++) {\n                let tileID = tiles.getTile(i, j);\n                if (tileID !== this.lastUpdateGrid.getTile(i, j)) {\n                    let tile = this.tilesCurrentGrid.getTile(i, j);\n                    if (tile) {\n                        console.log(\"the moment\");\n                        tile.destroyTile();\n                        this.tilesDestroying.add(tile);\n                    }\n                    let offset = [i * 2 + this.origin[0], j * 2 + this.origin[1]];\n                    // origin is center of (0, 0)\n                    // we want to place our tiles at the corner of (5, 5) and (6, 6)\n                    let newTile = this.factory.getTileFromID(tileID);\n                    if (newTile !== null) {\n                        newTile.setPosition(offset[0], 0, offset[1]);\n                        this.root.addChild(newTile);\n                    }\n                    this.tilesCurrentGrid.setTile(i, j, newTile);\n                    this.lastUpdateGrid.setTile(i, j, tileID);\n                }\n            }\n        }\n        let clearOrigin = this.tilesCurrentGrid.getOrigin();\n        for (let i = clearOrigin[0]; i < xOrigin; i++) {\n            for (let j = 0; j < tiles.dims[1]; j++) {\n                let tileCur = this.tilesCurrentGrid.getTile(i, j);\n                if (tileCur) {\n                    this.root.removeChild(tileCur.getId());\n                }\n                this.tilesCurrentGrid.setTile(i, j, null);\n                this.lastUpdateGrid.setTile(i, j, 0);\n            }\n        }\n        // all tiles which fall outside the range specified by the tile manager should be cleared\n        // the issue right now is that we're clearing things which we don't expect to i think\n        // on set, the size of our game field is increased\n        let gridMax = this.tilesCurrentGrid.dims[0] + clearOrigin[0];\n        for (let i = xDims; i < gridMax; i++) {\n            for (let j = 0; j < this.tilesCurrentGrid.dims[1]; j++) {\n                let tileCurFar = this.tilesCurrentGrid.getTile(i, j);\n                if (tileCurFar) {\n                    this.root.removeChild(tileCurFar.getId());\n                }\n                this.tilesCurrentGrid.setTile(i, j, null);\n                this.lastUpdateGrid.setTile(i, j, 0);\n            }\n        }\n        this.tilesCurrentGrid.setOrigin(xOrigin, yOrigin);\n        this.lastUpdateGrid.setOrigin(xOrigin, yOrigin);\n        this.tilesCurrentGrid.setDims(tiles.dims[0], tiles.dims[1]);\n        this.lastUpdateGrid.setDims(tiles.dims[0], tiles.dims[1]);\n        for (let layerID of state.layer.keys()) {\n            let inst = state.layer.get(layerID);\n            let dist = Math.abs(inst.position[0] - playerInfo.position[0]);\n            if (dist < 30) {\n                if (!this.layerInstances.has(layerID)) {\n                    let tile = this.factory.getTileFromID(inst.type);\n                    this.layerInstances.set(layerID, tile);\n                    this.root.addChild(tile);\n                }\n                let obj = this.layerInstances.get(layerID);\n                let offset = [inst.position[0] * 2 + this.origin[0], inst.position[1] * 2 + this.origin[1]];\n                obj.setPosition(offset[0], inst.position[2], offset[1]);\n            }\n        }\n        for (let enemyID of state.enemy.keys()) {\n            let inst = state.enemy.get(enemyID);\n            let dist = Math.abs(inst.position[0] - playerInfo.position[0]);\n            if (dist < 30) {\n                if (!this.layerInstances.has(enemyID)) {\n                    let tile = this.factory.getTileFromID(inst.type);\n                    this.layerInstances.set(enemyID, tile);\n                    this.root.addChild(tile);\n                }\n                let obj = this.layerInstances.get(enemyID);\n                let offset = [inst.position[0] * 2 + this.origin[0], inst.position[1] * 2 + this.origin[1]];\n                obj.setPosition(offset[0], inst.position[2], offset[1]);\n                switch (inst.direction) {\n                    case PlayerInputState_1.PlayerInputState.MOVE_LEFT:\n                        obj.setRotationEuler(0, 180, 0);\n                        break;\n                    case PlayerInputState_1.PlayerInputState.MOVE_RIGHT:\n                        obj.setRotationEuler(0, 0, 0);\n                        break;\n                    case PlayerInputState_1.PlayerInputState.MOVE_UP:\n                        obj.setRotationEuler(0, 90, 0);\n                        break;\n                    case PlayerInputState_1.PlayerInputState.MOVE_DOWN:\n                    default:\n                        obj.setRotationEuler(0, 270, 0);\n                        break;\n                }\n            }\n        }\n        let delID = [];\n        for (let id of this.layerInstances.keys()) {\n            if (!state.layer.has(id) && !state.enemy.has(id)) {\n                delID.push(id);\n            }\n            else {\n                // todo: avoid simulating enemies which are outside of some visible range (40 tiles?)\n                // having the tiled map will help with this a ton\n                let inst = (state.layer.has(id) ? state.layer.get(id) : state.enemy.get(id));\n                let dist = Math.abs(inst.position[0] - playerInfo.position[0]);\n                if (dist > 31) {\n                    delID.push(id);\n                }\n            }\n        }\n        for (let id of delID) {\n            let inst = this.layerInstances.get(id);\n            this.tilesDestroying.add(inst);\n            this.layerInstances.delete(id);\n            inst.destroyTile();\n        }\n        // i want to set the origin on these to something more reasonable\n        // because its too fucking many tiles to sort through lol\n        let deadTiles = [];\n        for (let tile of this.tilesDestroying) {\n            if (tile.isClean()) {\n                this.root.removeChild(tile.getId());\n                deadTiles.push(tile);\n            }\n        }\n        for (let tile of deadTiles) {\n            this.tilesDestroying.delete(tile);\n        }\n        // expect the player to have ID 1\n        // if that ID isn't there, something is wrong.\n        // (codependency: whatever dude idc)\n        // create tiles based on player position\n        // dependence on delta cycle which may not reliably update\n        // we could allow a get sys time function and calculate it ourselves\n        if (this.xOffset > 0 || offset[0] > 0) {\n            let t = 1.0 - Math.pow(0.01, this.ctx.getDelta());\n            if (Math.abs(this.xOffset - Math.max(offset[0])) > 12) {\n                this.xOffset = Math.max(offset[0], 0);\n            }\n            else {\n                this.xOffset += (Math.max(offset[0], 0) - this.xOffset) * t;\n            }\n            this.root.setPosition(-this.xOffset, 0, 0);\n        }\n        this.handleFloorTiles(playerInfo.position);\n        this.handleFieldTiles(playerInfo.position, -tiles.dims[1], tiles.dims[1]);\n    }\n    handleFieldTiles(playerPos, yTop, yBottom) {\n        // this normally preps everything at once\n        // now we need to initialize it the first time through\n        let fieldIndex = Math.max(Math.round(playerPos[0] / 24) - 1, 0);\n        // update only the one which just popped in\n        if (this.fieldIndex === -1) {\n            for (let i = 0; i < this.fieldPieces.length; i++) {\n                const index = i;\n                const offset = i;\n                this.handleFieldTile(index, offset);\n            }\n        }\n        else if (fieldIndex !== this.fieldIndex) {\n            // update models, update positions\n            let delta = fieldIndex - this.fieldIndex;\n            if (delta < 0) {\n                // we've slipped back\n                let rShift = Math.abs(delta);\n                for (let i = 0; i < rShift; i++) {\n                    this.root.removeChild(this.fieldPieces[this.fieldPieces.length - 1 - i].getId());\n                }\n                for (let i = this.fieldPieces.length - 1; i >= rShift; i--) {\n                    this.fieldPieces[i] = this.fieldPieces[i - rShift];\n                }\n                for (let i = 0; i < rShift; i++) {\n                    const index = i;\n                    const offset = fieldIndex + i;\n                    this.handleFieldTile(index, offset);\n                }\n            }\n            else {\n                // delta > 0\n                for (let i = 0; i < delta; i++) {\n                    this.root.removeChild(this.fieldPieces[i].getId());\n                }\n                for (let i = 0; i < delta; i++) {\n                    this.fieldPieces[i] = this.fieldPieces[i + 1];\n                }\n                for (let i = 0; i < delta; i++) {\n                    const index = this.fieldPieces.length - 1 - i;\n                    const offset = fieldIndex + index;\n                    this.handleFieldTile(index, offset);\n                }\n            }\n        }\n        this.fieldIndex = fieldIndex;\n    }\n    handleFieldTile(index, offset) {\n        const piece = this.fieldmgr.getFieldModel(offset);\n        this.root.addChild(piece);\n        this.fieldPieces[index] = piece;\n        piece.setPosition(offset * 48.0 + this.origin[0] - 1, 0, 0);\n    }\n    handleFloorTiles(playerPos) {\n        // figure out floor tile :3\n        // disjoint between floor tiles and field tiles\n        // delegate responsibility to field tiles???\n        // let minTile = Math.max(Math.floor((playerPos[0] - 24) / 12), 0);\n        // for (let i = 0; i < 5; i++) {\n        //   this.floorPieces[i].setPosition(this.origin[0] + 11 + (minTile * 24), 0, this.origin[1] + 10);\n        //   minTile++;\n        // }\n    }\n}\nexports.TileManagerSinglePlayer = TileManagerSinglePlayer;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/TileManagerSinglePlayer.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/fieldmgr/BeachFieldManager.ts":
/*!***********************************************************************!*\
  !*** ./client/ts/game/manager/internal/fieldmgr/BeachFieldManager.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BeachFieldManager = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst beachTileNames = [\n    \"tile_grass\",\n    \"tile_grass_beach\",\n    \"tile_beach\"\n];\nconst beachFieldNames = [\n    \"field_grass_beach\",\n    \"field_beach\"\n];\nconst beachResourceNames = [\n    \"bucket\",\n    \"sand_pile\",\n    \"sandcastle\",\n    \"umbrella\"\n];\nclass BeachFieldManager {\n    constructor(ctx, width) {\n        this.ctx = ctx;\n        this.seed = Math.floor(Math.random() * 4294967295);\n        this.tilemodels = [];\n        this.fieldmodels = [];\n        this.resources = [];\n        for (let i = 0; i < beachTileNames.length; i++) {\n            this.tilemodels.push(new Task_1.Task());\n        }\n        for (let i = 0; i < beachFieldNames.length; i++) {\n            this.fieldmodels.push(new Task_1.Task());\n        }\n        for (let i = 0; i < beachResourceNames.length; i++) {\n            this.resources.push(new Task_1.Task());\n        }\n        let loader = ctx.getGLTFLoader();\n        loader.loadAsGLTFScene(\"../res/beachworld.glb\")\n            .then(this.loadAllModels.bind(this));\n    }\n    getFieldModel(n) {\n        let origin = new GameObject_1.GameObject(this.ctx);\n        let tileNear;\n        let tileFar;\n        let field;\n        if (n === 0) {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[0].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n            field = new GamePBRModel_1.GamePBRModel(this.ctx, this.fieldmodels[0].getFuture());\n        }\n        else {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[2].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[2].getFuture());\n            field = new GamePBRModel_1.GamePBRModel(this.ctx, this.fieldmodels[1].getFuture());\n        }\n        origin.addChild(tileNear);\n        origin.addChild(tileFar);\n        origin.addChild(field);\n        tileNear.setPosition(-12, 0, 0);\n        tileFar.setPosition(12, 0, 0);\n        field.setPosition(0, 0, 0);\n        return origin;\n    }\n    loadAllModels(scene) {\n        for (let i = 0; i < beachTileNames.length; i++) {\n            this.tilemodels[i].resolve(scene.getPBRModel(beachTileNames[i]));\n        }\n        for (let i = 0; i < beachFieldNames.length; i++) {\n            this.fieldmodels[i].resolve(scene.getPBRModel(beachFieldNames[i]));\n        }\n        for (let i = 0; i < beachResourceNames.length; i++) {\n            this.resources[i].resolve(scene.getPBRModel(beachResourceNames[i]));\n        }\n    }\n    setFieldSeed(seed) {\n        // nop for now\n    }\n}\nexports.BeachFieldManager = BeachFieldManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/fieldmgr/BeachFieldManager.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/fieldmgr/BridgeFieldManager.ts":
/*!************************************************************************!*\
  !*** ./client/ts/game/manager/internal/fieldmgr/BridgeFieldManager.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BridgeFieldManager = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst Task_1 = __webpack_require__(/*! ../../../../../../hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst BeachGrassField_1 = __webpack_require__(/*! ../../../field/BeachGrassField */ \"./client/ts/game/field/BeachGrassField.ts\");\nconst bridgeFieldNames = [\n    \"field_beach_grass\",\n    \"field_beach_hill\"\n];\nconst bridgeTileNames = [\n    \"tile_beach\",\n    \"tile_bridge\"\n];\nconst grassResource = \"grass_blade\";\nclass BridgeFieldManager {\n    constructor(ctx, width) {\n        this.ctx = ctx;\n        this.fieldmodels = [];\n        this.tilemodels = [];\n        this.grassBlade = new Task_1.Task();\n        this.grassInstance = new Task_1.Task();\n        for (let i = 0; i < bridgeFieldNames.length; i++) {\n            this.fieldmodels.push(new Task_1.Task());\n        }\n        for (let i = 0; i < bridgeTileNames.length; i++) {\n            this.tilemodels.push(new Task_1.Task());\n        }\n        const loader = ctx.getGLTFLoader();\n        loader.loadAsGLTFScene(\"../res/bridgeworld.glb\")\n            .then(this.loadAllModels.bind(this));\n    }\n    getFieldModel(n) {\n        const origin = new GameObject_1.GameObject(this.ctx);\n        let tileNear;\n        let tileFar;\n        let field;\n        if (n < 3) {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[0].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[0].getFuture());\n        }\n        else {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n        }\n        if (n < 2) {\n            field = new BeachGrassField_1.BeachGrassField(this.ctx, this.fieldmodels[0].getFuture(), this.grassInstance.getFuture(), n);\n        }\n        else if (n < 3) {\n            field = new GamePBRModel_1.GamePBRModel(this.ctx, this.fieldmodels[1].getFuture());\n        }\n        else {\n            field = null;\n        }\n        origin.addChild(tileNear);\n        origin.addChild(tileFar);\n        tileNear.setPosition(-12, 0, 0);\n        tileFar.setPosition(12, 0, 0);\n        if (field !== null) {\n            origin.addChild(field);\n            field.setPosition(0, 0, 0);\n        }\n        return origin;\n    }\n    setFieldSeed(n) {\n        // nop\n    }\n    loadAllModels(scene) {\n        for (let i = 0; i < bridgeFieldNames.length; i++) {\n            this.fieldmodels[i].resolve(scene.getPBRModel(bridgeFieldNames[i]));\n        }\n        for (let i = 0; i < bridgeTileNames.length; i++) {\n            this.tilemodels[i].resolve(scene.getPBRModel(bridgeTileNames[i]));\n        }\n        this.grassBlade.resolve(scene.getPBRInstanceFactory(grassResource));\n        this.grassInstance.resolve(scene.getInstancedModel(grassResource));\n    }\n}\nexports.BridgeFieldManager = BridgeFieldManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/fieldmgr/BridgeFieldManager.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/fieldmgr/GrassFieldManager.ts":
/*!***********************************************************************!*\
  !*** ./client/ts/game/manager/internal/fieldmgr/GrassFieldManager.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GrassFieldManager = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst random_1 = __webpack_require__(/*! nekogirl-valhalla/random */ \"./node_modules/nekogirl-valhalla/random/index.js\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst grassFieldNames = [\n    \"field_grass\",\n    \"field_rock\",\n    \"tile_grass\",\n    \"field_pit\"\n];\nclass GrassFieldManager {\n    constructor(ctx, width) {\n        this.seed = Math.floor(Math.random() * 4294967295);\n        this.models = [];\n        this.ctx = ctx;\n        this.width = width;\n        this.tilemodel = new Task_1.Task();\n        for (let i = 0; i < grassFieldNames.length; i++) {\n            this.models.push(new Task_1.Task());\n        }\n        let loader = ctx.getGLTFLoader();\n        loader.loadAsGLTFScene(\"../res/grassworld_new.glb\")\n            .then(scene => {\n            for (let i = 0; i < grassFieldNames.length; i++) {\n                this.models[i].resolve(scene.getPBRModel(grassFieldNames[i]));\n            }\n        });\n        loader.loadAsGLTFScene(\"../res/grassworld.glb\")\n            .then(scene => {\n            this.tilemodel.resolve(scene.getPBRModel(0));\n        });\n    }\n    getFieldModel(n) {\n        let origin = new GameObject_1.GameObject(this.ctx);\n        // dummy number, avoid this behavior for now\n        if (n === -15) {\n            let child = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[2].getFuture());\n            origin.addChild(child);\n            child.setPosition(0, 0, -this.width);\n            let tile = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodel.getFuture());\n            tile.setPosition(12, 0, 0);\n            origin.addChild(tile);\n            return origin;\n        }\n        else {\n            (0, random_1.xorshift32_seed)(this.seed + n);\n            let prob = (0, random_1.xorshift32_float)();\n            if (prob > 0.8) {\n                let rock = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[3].getFuture());\n                rock.setPosition(0, 0, 0);\n                origin.addChild(rock);\n            }\n            else {\n                let fieldNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[0].getFuture());\n                let fieldFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[0].getFuture());\n                fieldNear.setPosition(-12, 0, 0);\n                fieldFar.setPosition(12, 0, 0);\n                origin.addChild(fieldNear);\n                origin.addChild(fieldFar);\n            }\n        }\n        let tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[2].getFuture());\n        let tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.models[2].getFuture());\n        tileNear.setPosition(-12, 0, 0);\n        tileFar.setPosition(12, 0, 0);\n        origin.addChild(tileNear);\n        origin.addChild(tileFar);\n        return origin;\n    }\n    setFieldSeed(n) {\n        this.seed = n;\n    }\n}\nexports.GrassFieldManager = GrassFieldManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/fieldmgr/GrassFieldManager.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/fieldmgr/LavaFieldManager.ts":
/*!**********************************************************************!*\
  !*** ./client/ts/game/manager/internal/fieldmgr/LavaFieldManager.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LavaFieldManager = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst lavaFloorNames = [\n    \"grass_to_lava\",\n    \"lava\"\n];\nclass LavaFieldManager {\n    constructor(ctx, width) {\n        this.seed = Math.floor(Math.random() * 4294967295);\n        this.tilemodels = [];\n        for (let i = 0; i < lavaFloorNames.length; i++) {\n            this.tilemodels.push(new Task_1.Task());\n        }\n        let loader = ctx.getGLTFLoader();\n        loader.loadAsGLTFScene(\"../res/lavaworld.glb\")\n            .then(scene => {\n            for (let i = 0; i < lavaFloorNames.length; i++) {\n                this.tilemodels[i].resolve(scene.getPBRModel(lavaFloorNames[i]));\n            }\n        });\n    }\n    getFieldModel(n) {\n        let origin = new GameObject_1.GameObject(this.ctx);\n        let tileNear;\n        let tileFar;\n        if (n === 0) {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[0].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n        }\n        else {\n            tileNear = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n            tileFar = new GamePBRModel_1.GamePBRModel(this.ctx, this.tilemodels[1].getFuture());\n        }\n        origin.addChild(tileNear);\n        origin.addChild(tileFar);\n        tileNear.setPosition(-12, 0, 0);\n        tileFar.setPosition(12, 0, 0);\n        return origin;\n    }\n    setFieldSeed(seed) {\n        this.seed = seed;\n    }\n}\nexports.LavaFieldManager = LavaFieldManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/fieldmgr/LavaFieldManager.ts?");

/***/ }),

/***/ "./client/ts/game/manager/internal/fieldmgr/MountainFieldManager.ts":
/*!**************************************************************************!*\
  !*** ./client/ts/game/manager/internal/fieldmgr/MountainFieldManager.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MountainFieldManager = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst mountainResourceNames = [\n    \"field_beach\",\n    \"tile_beach\",\n    \"bridge\",\n    \"water\",\n    \"mountain\"\n];\nclass MountainFieldManager {\n    constructor(ctx, width) {\n        this.ctx = ctx;\n        this.seed = Math.floor(Math.random() * 4294967295);\n        this.models = [];\n        for (let i = 0; i < mountainResourceNames.length; i++) {\n            this.models.push(new Task_1.Task());\n        }\n        ctx.getGLTFLoader().loadAsGLTFScene(\"../res/mountainworld.glb\")\n            .then(this.loadAllModels.bind(this));\n    }\n    getModel(ind) {\n        return new GamePBRModel_1.GamePBRModel(this.ctx, this.models[ind].getFuture());\n    }\n    getFieldModel(n) {\n        let origin = new GameObject_1.GameObject(this.ctx);\n        if (n === 0) {\n            let tileNear = this.getModel(1);\n            let tileFar = this.getModel(1);\n            let field = this.getModel(0);\n            origin.addChild(tileNear);\n            origin.addChild(tileFar);\n            origin.addChild(field);\n            tileNear.setPosition(-12, 0, 0);\n            tileFar.setPosition(12, 0, 0);\n            field.setPosition(0, 0, 0);\n        }\n        else if (n === 1) {\n            let tileNear = this.getModel(2);\n            let tileFar = this.getModel(4);\n            let water = this.getModel(3);\n            origin.addChild(tileNear);\n            origin.addChild(tileFar);\n            origin.addChild(water);\n            tileNear.setPosition(-12, 0, 0);\n            tileFar.setPosition(12, 0, 0);\n            water.setPosition(-12, -24, 0);\n        }\n        else {\n            let tileNear = this.getModel(4);\n            let tileFar = this.getModel(4);\n            origin.addChild(tileNear);\n            origin.addChild(tileFar);\n            tileNear.setPosition(-12, 0, 0);\n            tileFar.setPosition(12, 0, 0);\n        }\n        return origin;\n    }\n    setFieldSeed(seed) {\n        this.seed = seed;\n    }\n    loadAllModels(scene) {\n        for (let i = 0; i < mountainResourceNames.length; i++) {\n            this.models[i].resolve(scene.getPBRModel(mountainResourceNames[i]));\n        }\n    }\n}\nexports.MountainFieldManager = MountainFieldManager;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/manager/internal/fieldmgr/MountainFieldManager.ts?");

/***/ }),

/***/ "./client/ts/game/map/GrassInstanceFactory.ts":
/*!****************************************************!*\
  !*** ./client/ts/game/map/GrassInstanceFactory.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// draw all matrices at once\n// returned instances should support a callback...\n// but the intended impl should be that we pass a large array of local transforms\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GrassInstanceFactory = void 0;\nconst PBRInstanceImpl_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/model/internal/PBRInstanceImpl */ \"./hingler-party/client/ts/engine/model/internal/PBRInstanceImpl.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst InstancedGrassMaterial_1 = __webpack_require__(/*! ../material/grass/InstancedGrassMaterial */ \"./client/ts/game/material/grass/InstancedGrassMaterial.ts\");\n// note also that we need to customize the mat here\n// alter the material on this instance and make sure that it flushes :D\nconst MAT_CHILD_INDEX = 3;\nconst MAT_NORMAL_INDEX = 4;\nclass GrassInstanceFactory {\n    constructor(ctx, model) {\n        this.ctx = ctx;\n        // if (model instanceof Future) {\n        //   this.model = model;\n        // } else {\n        //   const t = new Task<InstancedModel>();\n        //   t.resolve(model);\n        //   this.model = t.getFuture();\n        // }\n        this.mat = new InstancedGrassMaterial_1.InstancedGrassMaterial(ctx);\n        this.mat.modelMatrixChildIndex = MAT_CHILD_INDEX;\n        this.mat.normalMatrixChildIndex = MAT_NORMAL_INDEX;\n        // need a new shadowmat for the child thing\n        this.currentPass = RenderContext_1.RenderPass.FINAL;\n    }\n    set parentMat(res) {\n        this.mat.modelMatParent = res;\n    }\n    getInstance() {\n        return new PBRInstanceImpl_1.PBRInstanceImpl(this.callbackfunc.bind(this));\n    }\n    drawManyInstanced(mats, norms, count, rc) {\n        if (mats.length < (count * 16) || norms.length < (count * 9)) {\n            throw Error(\"Not enough data provided to draw grass instances!\");\n        }\n        if (this.model.valid()) {\n            const model = this.model.get();\n            model.setInstancedMaterial(this.mat);\n            const matsActive = mats.slice(0, count * 16);\n            const normsActive = norms.slice(0, count * 9);\n            const pass = rc.getRenderPass();\n            if (this.currentPass !== pass) {\n                this.currentPass = pass;\n                model.clearInstances();\n            }\n            model.appendInstanceData(MAT_CHILD_INDEX, matsActive);\n            model.appendInstanceData(MAT_NORMAL_INDEX, normsActive);\n            // model.drawManyInstanced(count);\n        }\n    }\n    callbackfunc(mat, rc) {\n        if (this.model.valid()) {\n            const model = this.model.get();\n            let pass = rc.getRenderPass();\n            if (this.currentPass !== pass) {\n                this.currentPass = pass;\n                model.clearInstances();\n            }\n            // const norm = mat3.fromMat4(mat3.create(), mat);\n            // mat3.transpose(norm, norm);\n            // mat3.invert(norm, norm);\n            // model.appendInstanceData(MAT_CHILD_INDEX, mat);\n            // model.appendInstanceData(MAT_NORMAL_INDEX, norm);\n            // model.drawInstanced();\n        }\n    }\n}\nexports.GrassInstanceFactory = GrassInstanceFactory;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/map/GrassInstanceFactory.ts?");

/***/ }),

/***/ "./client/ts/game/material/InstancedExplosionMaterial.ts":
/*!***************************************************************!*\
  !*** ./client/ts/game/material/InstancedExplosionMaterial.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstancedExplosionMaterial = void 0;\nconst GLProgramWrap_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/internal/GLProgramWrap */ \"./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst TextureDummy_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/material/TextureDummy */ \"./hingler-party/client/ts/engine/material/TextureDummy.ts\");\nconst model_1 = __webpack_require__(/*! nekogirl-valhalla/model */ \"./node_modules/nekogirl-valhalla/model/index.js\");\nclass InstancedExplosionMaterial {\n    constructor(ctx) {\n        this.instanceIndices = {\n            modelMat: -1,\n            threshold: -1,\n            color: -1,\n            noise_offset: -1\n        };\n        this.ctx = ctx;\n        this.prog = null;\n        this.progWrap = null;\n        this.placeholder = new TextureDummy_1.TextureDummy(ctx);\n        this.tex = null;\n        ctx.getGLTFLoader().loadTexture(\"../res/explosiontex.png\").then((tex) => {\n            this.tex = tex;\n        });\n        // no way to load textures yet lol\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/explosion/explosion.vert\")\n            .withFragmentShader(\"../glsl/game/explosion/explosion.frag\")\n            .build()\n            .then(this.configureProgram.bind(this))\n            .catch(console.error.bind(console));\n    }\n    configureProgram(prog) {\n        let gl = this.ctx.getGLContext();\n        this.prog = prog;\n        this.progWrap = new GLProgramWrap_1.GLProgramWrap(gl, this.prog);\n        this.locs = {\n            camera_matrix: gl.getUniformLocation(prog, \"camera_matrix\"),\n            noise_texture: gl.getUniformLocation(prog, \"noise_texture\")\n        };\n        this.attribs = {\n            position: gl.getAttribLocation(prog, \"position\"),\n            texcoord: gl.getAttribLocation(prog, \"texcoord\"),\n            model_matrix: gl.getAttribLocation(prog, \"model_matrix\"),\n            threshold: gl.getAttribLocation(prog, \"threshold\"),\n            color: gl.getAttribLocation(prog, \"color\"),\n            noise_offset: gl.getAttribLocation(prog, \"noise_offset\")\n        };\n    }\n    prepareAttributes(model, instances, rc) {\n        let gl = this.ctx.getGLContext();\n        if (this.prog !== null) {\n            const ctx = this.ctx.getGL();\n            ctx.useProgram(this.prog);\n            gl.uniformMatrix4fv(this.locs.camera_matrix, false, rc.getActiveCameraInfo().vpMatrix);\n            model.bindAttribute(model_1.AttributeType.POSITION, this.attribs.position);\n            model.bindAttribute(model_1.AttributeType.TEXCOORD, this.attribs.texcoord);\n            if (this.tex !== null) {\n                this.tex.bindToUniform(this.locs.noise_texture, 6);\n            }\n            else {\n                this.placeholder.bindToUniform(this.locs.noise_texture, 6);\n            }\n            for (let i = 0; i < 4; i++) {\n                let loc = this.attribs.model_matrix + i;\n                let byteOffset = i * 16;\n                model.instanceAttribPointer(this.instanceIndices.modelMat, loc, 4, gl.FLOAT, false, 96, byteOffset);\n            }\n            // todo: add params for offset, stride, etc. if necessary\n            model.instanceAttribPointer(this.instanceIndices.modelMat, this.attribs.threshold, 1, gl.FLOAT, false, 96, 64);\n            model.instanceAttribPointer(this.instanceIndices.modelMat, this.attribs.color, 4, gl.FLOAT, false, 96, 68);\n            model.instanceAttribPointer(this.instanceIndices.modelMat, this.attribs.noise_offset, 3, gl.FLOAT, false, 96, 84);\n        }\n    }\n    cleanUpAttributes() { }\n}\nexports.InstancedExplosionMaterial = InstancedExplosionMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/material/InstancedExplosionMaterial.ts?");

/***/ }),

/***/ "./client/ts/game/material/InstancedPowerupMaterial.ts":
/*!*************************************************************!*\
  !*** ./client/ts/game/material/InstancedPowerupMaterial.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// a: modelmat (64)\n// b: normmat (36)\n// c: color (16)\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstancedPowerupMaterial = void 0;\nconst GLBufferImpl_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/internal/GLBufferImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst CalculateNormalMatrixFromBuffer_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer */ \"./hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer.ts\");\nconst model_1 = __webpack_require__(/*! nekogirl-valhalla/model */ \"./node_modules/nekogirl-valhalla/model/index.js\");\nclass InstancedPowerupMaterial {\n    constructor(ctx) {\n        this.prog = null;\n        this.ctx = ctx;\n        this.normBuffer = new GLBufferImpl_1.GLBufferImpl(this.ctx);\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/powerup/powerup.vert\")\n            .withFragmentShader(\"../glsl/game/powerup/powerup.frag\")\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    configureProgram(prog) {\n        let gl = this.ctx.getGLContext();\n        this.prog = prog;\n        this.attribs = {\n            aPosition: gl.getAttribLocation(prog, \"aPosition\"),\n            aNormal: gl.getAttribLocation(prog, \"aNormal\"),\n            aColor: gl.getAttribLocation(prog, \"aColor\"),\n            aModelMat: gl.getAttribLocation(prog, \"aModelMat\"),\n            aNormalMat: gl.getAttribLocation(prog, \"aNormalMat\")\n        };\n        this.uniforms = {\n            vpMat: gl.getUniformLocation(prog, \"vpMat\"),\n            camPos: gl.getUniformLocation(prog, \"camPos\")\n        };\n    }\n    prepareAttributes(model, instances, rc) {\n        let gl = this.ctx.getGLContext();\n        if (this.prog !== null) {\n            const ctx = this.ctx.getGL();\n            ctx.useProgram(this.prog);\n            let info = rc.getActiveCameraInfo();\n            gl.uniformMatrix4fv(this.uniforms.vpMat, false, info.vpMatrix);\n            gl.uniform3fv(this.uniforms.camPos, info.cameraPosition);\n            model.bindAttribute(model_1.AttributeType.POSITION, this.attribs.aPosition);\n            model.bindAttribute(model_1.AttributeType.NORMAL, this.attribs.aNormal);\n            let modelMat = model.getReadOnlyBuffer(this.modelMatrixIndex);\n            (0, CalculateNormalMatrixFromBuffer_1.CalculateNormalMatrixFromBuffer)(modelMat, this.normBuffer, instances, 0, 0);\n            // calculate normals\n            for (let i = 0; i < 4; i++) {\n                const loc = this.attribs.aModelMat + i;\n                const byteOffset = i * 16;\n                model.instanceAttribPointer(this.modelMatrixIndex, loc, 4, gl.FLOAT, false, 64, byteOffset);\n            }\n            for (let i = 0; i < 3; i++) {\n                const loc = this.attribs.aNormalMat + i;\n                const byteOffset = i * 12;\n                this.normBuffer.bindToInstancedVertexAttribute(loc, 3, gl.FLOAT, false, 36, byteOffset);\n            }\n            model.instanceAttribPointer(this.colorIndex, this.attribs.aColor, 4, gl.FLOAT, false, 0, 0);\n        }\n    }\n    cleanUpAttributes() {\n        for (let i = 0; i < 3; i++) {\n            this.normBuffer.disableInstancedVertexAttribute(this.attribs.aNormalMat + i);\n        }\n    }\n}\nexports.InstancedPowerupMaterial = InstancedPowerupMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/material/InstancedPowerupMaterial.ts?");

/***/ }),

/***/ "./client/ts/game/material/grass/InstancedGrassMaterial.ts":
/*!*****************************************************************!*\
  !*** ./client/ts/game/material/grass/InstancedGrassMaterial.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstancedGrassMaterial = void 0;\nconst ColorCubemap_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/gl/ColorCubemap */ \"./hingler-party/client/ts/engine/gl/ColorCubemap.ts\");\nconst GLProgramWrap_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/gl/internal/GLProgramWrap */ \"./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst model_1 = __webpack_require__(/*! nekogirl-valhalla/model */ \"./node_modules/nekogirl-valhalla/model/index.js\");\nclass InstancedGrassMaterial {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.modelMatrixChildIndex = -1;\n        this.normalMatrixChildIndex = -1;\n        this.prog = null;\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(\"../glsl/game/grass/grass.vert\")\n            .withFragmentShader(\"../glsl/game/grass/grass.frag\")\n            .build()\n            .then(this.configureProgram.bind(this));\n        this.placeholderDiffuse = [];\n        this.shadowDummy = [];\n        for (let i = 0; i < 2; i++) {\n            this.placeholderDiffuse.push(new ColorCubemap_1.ColorCubemap(ctx, 1));\n            // this.shadowDummy.push(new TextureDummy(ctx));\n        }\n    }\n    configureProgram(prog) {\n        const gl = this.ctx.getGLContext();\n        this.prog = prog;\n        this.wrap = new GLProgramWrap_1.GLProgramWrap(gl, this.prog);\n        this.unifs = {\n            modelMatParent: gl.getUniformLocation(prog, \"modelMatParent\"),\n            vpMat: gl.getUniformLocation(prog, \"vpMat\"),\n            spotlightCount: gl.getUniformLocation(prog, \"spotlightCount\"),\n            spotlightCount_noShadow: gl.getUniformLocation(prog, \"spotlightCount_noShadow\"),\n            camPos: gl.getUniformLocation(prog, \"camPos\"),\n            skyboxDiffuse: [],\n            skyboxDiffuseIntensity: []\n        };\n        for (let i = 0; i < 2; i++) {\n            this.unifs.skyboxDiffuse.push(gl.getUniformLocation(prog, `skyboxDiffuse[${i}]`));\n            this.unifs.skyboxDiffuseIntensity.push(gl.getUniformLocation(prog, `skyboxDiffuseIntensity[${i}]`));\n        }\n        this.locs = {\n            aPosition: gl.getAttribLocation(prog, \"aPosition\"),\n            aNormal: gl.getAttribLocation(prog, \"aNormal\"),\n            modelMatChild: gl.getAttribLocation(prog, \"modelMatChild\"),\n            normalMatChild: gl.getAttribLocation(prog, \"normalMatChild\")\n        };\n    }\n    prepareAttributes(model, instances, rc) {\n        if (this.modelMatrixChildIndex < 0 || this.normalMatrixChildIndex < 0) {\n            const err = \"Model mat locations unbound -- cannot draw\";\n            throw Error(err);\n        }\n        if (this.prog !== null) {\n            const gl = this.ctx.getGLContext();\n            const sky = rc.getSkybox();\n            const cam = rc.getActiveCameraInfo();\n            const amb = rc.getAmbientLightInfo();\n            const spot = rc.getSpotLightInfo();\n            const wrap = this.ctx.getGL();\n            wrap.useProgram(this.prog);\n            gl.uniformMatrix4fv(this.unifs.modelMatParent, false, this.modelMatParent);\n            gl.uniformMatrix4fv(this.unifs.vpMat, false, cam.vpMatrix);\n            let spotCount = 0;\n            let noShadowSpotCount = 0;\n            for (let light of spot) {\n                if (spotCount < 4 && light.hasShadow()) {\n                    light.setShadowTextureIndex(spotCount + 4);\n                    light.bindToUniformByName(this.wrap, `spotlight[${spotCount++}]`, true);\n                }\n                else if (noShadowSpotCount < 4) {\n                    light.bindToUniformByName(this.wrap, `spotlight_noShadow[${noShadowSpotCount++}]`, false);\n                }\n            }\n            wrap.uniform1i(this.unifs.spotlightCount, spotCount);\n            wrap.uniform1i(this.unifs.spotlightCount_noShadow, noShadowSpotCount);\n            gl.uniform3fv(this.unifs.camPos, cam.cameraPosition);\n            const diffuseArray = [\n                (sky !== null && sky.length > 0 ? sky[0].irridance : this.placeholderDiffuse[0]),\n                (sky !== null && sky.length > 1 ? sky[1].irridance : this.placeholderDiffuse[1])\n            ];\n            const intensityArray = [\n                (sky !== null && sky.length > 0 ? sky[0].intensity : 0),\n                (sky !== null && sky.length > 1 ? sky[1].intensity : 0)\n            ];\n            diffuseArray[0].bindToUniform(this.unifs.skyboxDiffuse[0], 8);\n            diffuseArray[1].bindToUniform(this.unifs.skyboxDiffuse[1], 9);\n            wrap.uniform1f(this.unifs.skyboxDiffuseIntensity[0], intensityArray[0]);\n            wrap.uniform1f(this.unifs.skyboxDiffuseIntensity[1], intensityArray[1]);\n            model.bindAttribute(model_1.AttributeType.POSITION, this.locs.aPosition);\n            model.bindAttribute(model_1.AttributeType.NORMAL, this.locs.aNormal);\n            for (let i = 0; i < 4; i++) {\n                const loc = this.locs.modelMatChild + i;\n                const byteOffset = i * 16;\n                model.instanceAttribPointer(this.modelMatrixChildIndex, loc, 4, gl.FLOAT, false, 64, byteOffset);\n            }\n            for (let i = 0; i < 3; i++) {\n                const loc = this.locs.normalMatChild + i;\n                const byteOffset = i * 12;\n                model.instanceAttribPointer(this.normalMatrixChildIndex, loc, 3, gl.FLOAT, false, 36, byteOffset);\n            }\n        }\n    }\n    cleanUpAttributes() {\n        // nop -- everything in model\n    }\n}\nexports.InstancedGrassMaterial = InstancedGrassMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/material/grass/InstancedGrassMaterial.ts?");

/***/ }),

/***/ "./client/ts/game/splashscreen/SplashScreen.ts":
/*!*****************************************************!*\
  !*** ./client/ts/game/splashscreen/SplashScreen.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SplashScreenScene = void 0;\nconst Scene_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/scene/Scene */ \"./hingler-party/client/ts/engine/object/scene/Scene.ts\");\nconst SplashScreenObject_1 = __webpack_require__(/*! ./SplashScreenObject */ \"./client/ts/game/splashscreen/SplashScreenObject.ts\");\nclass SplashScreenScene extends Scene_1.Scene {\n    // super simple\n    // we'll set up the bg as a component which can be faded in and out\n    // that component will handle scene loading\n    // first touch skips fade in anim (if playing, otherwise skip)\n    // second touch starts game\n    // 1s fade in\n    // lets jump straight into it for now\n    // todo: add pause screen for main game\n    // come up with some way to pass a distinct time value down the hierarchy (just a game object whose delta we can fetch?)\n    // use that time value everywhere delta is used\n    initialize(ctx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let root = this.getGameObjectRoot();\n            root.addChild(new SplashScreenObject_1.SplashScreenObject(ctx));\n        });\n    }\n}\nexports.SplashScreenScene = SplashScreenScene;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/splashscreen/SplashScreen.ts?");

/***/ }),

/***/ "./client/ts/game/splashscreen/SplashScreenObject.ts":
/*!***********************************************************!*\
  !*** ./client/ts/game/splashscreen/SplashScreenObject.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SplashScreenObject = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst mapscenetest_1 = __webpack_require__(/*! ../../../../test/mapscenetest */ \"./test/mapscenetest.ts\");\nclass SplashScreenObject extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        this.delta = 0;\n        this.swapGood = false;\n        this.bg = new Image();\n        this.bg.src = \"../res/splashscreen.jpg\";\n        this.bg.classList.add(\"splash-screen\");\n        document.getElementById(\"overlay\").appendChild(this.bg);\n        this.starttext = document.createElement(\"p\");\n        this.starttext.classList.add(\"start-text\");\n        this.starttext.textContent = \"PRESS START\";\n        document.body.appendChild(this.starttext);\n        this.windowcb = this.handleSceneSwap.bind(this);\n        this.swap = this.getContext().loadNewScene(new mapscenetest_1.MapSceneTest());\n        // handle click and touch\n        window.addEventListener(\"click\", this.windowcb);\n        window.addEventListener(\"touchstart\", this.windowcb);\n    }\n    update() {\n        this.delta += this.getContext().getDelta();\n        // probably do this better :(\n        if (!this.ready) {\n            console.log(this.delta);\n            this.bg.style.filter = `opacity(${Math.min(this.delta, 1.0)})`;\n            this.ready = this.ready || (this.delta >= 1.0);\n        }\n        if (this.swapGood && this.swap.getFractionLoaded() > 0.999) {\n            this.swap.swap().then(() => {\n                window.removeEventListener(\"click\", this.windowcb);\n                window.removeEventListener(\"touchstart\", this.windowcb);\n                document.body.removeChild(this.starttext);\n            });\n        }\n    }\n    handleSceneSwap() {\n        if (!this.ready) {\n            this.ready = true;\n            this.bg.style.filter = \"opacity(1)\";\n        }\n        else if (this.ready) {\n            // touch to start\n            document.getElementById(\"hud\").classList.remove(\"hidden\");\n            console.log(\"swap is ready to go once loaded\");\n            this.swapGood = true;\n        }\n    }\n}\nexports.SplashScreenObject = SplashScreenObject;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/splashscreen/SplashScreenObject.ts?");

/***/ }),

/***/ "./client/ts/game/tile/GameTile.ts":
/*!*****************************************!*\
  !*** ./client/ts/game/tile/GameTile.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameTile = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../../../hingler-party/client/ts/engine/object/game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\n/**\n * Represents a single game tile. (note: since we don't have multiple inheritance,\n * model-like behavior will probably be implemented by a nested child)\n */\nclass GameTile extends GameObject_1.GameObject {\n    /**\n     * Called by parent to start destroying this tile.\n     */\n    destroyTile() {\n        this.destroy();\n    }\n    /**\n     * @returns true if the tile is clean, false otherwise.\n     */\n    isClean() {\n        return this.clean;\n    }\n    /**\n     * Called by implementers once the tile's destroy behavior is complete.\n     * Denotes that the tile can be removed from the object hierarchy.\n     */\n    markAsClean() {\n        this.clean = true;\n    }\n}\nexports.GameTile = GameTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/GameTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/LayerInstance.ts":
/*!**********************************************!*\
  !*** ./client/ts/game/tile/LayerInstance.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoatInstance = exports.EnemyInstance = exports.LayerInstance = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nclass LayerInstance {\n    // add copy function?\n    copyInstance() {\n        let res = new LayerInstance();\n        res.type = this.type;\n        res.position = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), this.position);\n        return res;\n    }\n}\nexports.LayerInstance = LayerInstance;\nclass EnemyInstance extends LayerInstance {\n    // enemies which are \"plucked\" are dead (for now)\n    copyInstance() {\n        let res = new EnemyInstance();\n        res.position = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), this.position);\n        res.type = this.type;\n        res.direction = this.direction;\n        return res;\n    }\n}\nexports.EnemyInstance = EnemyInstance;\nclass GoatInstance extends EnemyInstance {\n    // indicates how long the goat has been stunned for\n    copyInstance() {\n        // lots of redundant code :(\n        let goat = new GoatInstance();\n        goat.position = gl_matrix_1.vec3.copy(gl_matrix_1.vec3.create(), this.position);\n        goat.type = this.type;\n        goat.direction = this.direction;\n        goat.runTime = this.runTime;\n        goat.stunTime = this.stunTime;\n        return goat;\n    }\n}\nexports.GoatInstance = GoatInstance;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/LayerInstance.ts?");

/***/ }),

/***/ "./client/ts/game/tile/TileID.ts":
/*!***************************************!*\
  !*** ./client/ts/game/tile/TileID.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileID = void 0;\nvar TileID;\n(function (TileID) {\n    TileID[TileID[\"EMPTY\"] = 0] = \"EMPTY\";\n    TileID[TileID[\"CRATE\"] = 1] = \"CRATE\";\n    TileID[TileID[\"EXPLOSION\"] = 2] = \"EXPLOSION\";\n    TileID[TileID[\"WALL\"] = 3] = \"WALL\";\n    TileID[TileID[\"BOMB\"] = 16] = \"BOMB\";\n    TileID[TileID[\"PIPE_BOMB\"] = 17] = \"PIPE_BOMB\";\n    TileID[TileID[\"ENEMY_KNIGHT\"] = 32] = \"ENEMY_KNIGHT\";\n    TileID[TileID[\"ENEMY_CRAB\"] = 33] = \"ENEMY_CRAB\";\n    TileID[TileID[\"ENEMY_GOAT\"] = 34] = \"ENEMY_GOAT\";\n    TileID[TileID[\"POWER_SPEED\"] = 64] = \"POWER_SPEED\";\n    TileID[TileID[\"POWER_BOMB\"] = 65] = \"POWER_BOMB\";\n    TileID[TileID[\"POWER_RADIUS\"] = 66] = \"POWER_RADIUS\";\n})(TileID = exports.TileID || (exports.TileID = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/TileID.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/BombTile.ts":
/*!*************************************************!*\
  !*** ./client/ts/game/tile/generic/BombTile.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BombTile = void 0;\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nclass BombTile extends GameTile_1.GameTile {\n    constructor(ctx, inst) {\n        super(ctx);\n        this.instance = inst;\n    }\n    renderMaterial(rc) {\n        if (this.instance.valid()) {\n            let inst = this.instance.get();\n            inst.modelMat = this.getTransformationMatrix();\n            inst.draw(rc);\n        }\n    }\n    destroy() {\n        this.markAsClean();\n        // add some animation maybe?\n    }\n}\nexports.BombTile = BombTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/BombTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/CrateTile.ts":
/*!**************************************************!*\
  !*** ./client/ts/game/tile/generic/CrateTile.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CrateTile = void 0;\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nclass CrateTile extends GameTile_1.GameTile {\n    constructor(ctx, inst) {\n        super(ctx);\n        this.instance = inst;\n    }\n    renderMaterial(rc) {\n        if (this.instance.valid()) {\n            let inst = this.instance.get();\n            inst.modelMat = this.getTransformationMatrix();\n            inst.draw(rc);\n        }\n    }\n    destroy() {\n        this.markAsClean();\n    }\n}\nexports.CrateTile = CrateTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/CrateTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/ExplosionTile.ts":
/*!******************************************************!*\
  !*** ./client/ts/game/tile/generic/ExplosionTile.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExplosionTile = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst RenderContext_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nclass ExplosionTile extends GameTile_1.GameTile {\n    constructor(ctx, inst) {\n        super(ctx);\n        this.instance = inst;\n        this.time = 0;\n        this.thresh = 0.45;\n        this.explosionScale = 0.65;\n        this.startDestroy = false;\n    }\n    update() {\n        let delta = this.getContext().getDelta();\n        this.time += delta;\n        // update time\n        let targetValue = (this.startDestroy ? 1.05 : 0.705);\n        // current approach looks like shit when we drop frames\n        let t = 1.0 - Math.pow(0.1, delta);\n        let tScale = 1.0 - Math.pow(0.01, delta);\n        this.explosionScale += (1.0 - this.explosionScale) * tScale;\n        this.thresh += (targetValue - this.thresh) * t;\n        if (this.thresh > 1.00) {\n            this.markAsClean();\n        }\n        this.setScale(this.explosionScale, this.explosionScale / 2.0, this.explosionScale);\n    }\n    // update: do something with time, handle lerp shit\n    renderMaterial(rc) {\n        // three concentric hemispheres\n        // slightly different noise offsets, thresholds, and colors\n        if (rc.getRenderPass() === RenderContext_1.RenderPass.FINAL && this.instance.valid()) {\n            let inst = this.instance.get();\n            let mat = gl_matrix_1.mat4.copy(gl_matrix_1.mat4.create(), this.getTransformationMatrix());\n            inst.modelMat = mat;\n            inst.threshold = this.thresh + 0.075;\n            inst.color = [1.0, 0.0, 0.0, 1.0];\n            inst.noiseOffset = [0.0, this.time * 3.1, 0.0];\n            inst.noiseScale = [1.5, 1.5, 1.5];\n            inst.draw(rc);\n            gl_matrix_1.mat4.scale(mat, mat, [0.96, 0.96, 0.96]);\n            gl_matrix_1.mat4.rotateY(mat, mat, 2.0941);\n            inst.modelMat = mat;\n            inst.threshold -= 0.05;\n            inst.color = [1.0, 0.5, 0.0, 1.0];\n            inst.noiseOffset[1] += 1.0;\n            inst.noiseOffset[1] *= 0.7;\n            inst.draw(rc);\n            gl_matrix_1.mat4.scale(mat, mat, [0.96, 0.96, 0.96]);\n            inst.modelMat = mat;\n            inst.threshold -= 0.025;\n            inst.color = [1.0, 1.0, 0.0, 1.0];\n            inst.noiseOffset[1] += 1.0;\n            inst.noiseOffset[1] *= 2.1;\n            inst.draw(rc);\n        }\n    }\n    destroy() {\n        this.startDestroy = true;\n    }\n}\nexports.ExplosionTile = ExplosionTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/ExplosionTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/KnightTile.ts":
/*!***************************************************!*\
  !*** ./client/ts/game/tile/generic/KnightTile.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KnightTile = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst RenderContext_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nclass KnightTile extends GameTile_1.GameTile {\n    constructor(ctx, inst) {\n        super(ctx);\n        this.instance = inst;\n        this.time = 0;\n        this.frame = 0;\n        this.destroyed = false;\n    }\n    update() {\n        if (this.destroyed) {\n            this.time += this.getContext().getDelta();\n            this.setRotationEuler(0, Math.pow(this.time, 2.4) * 1080, 0);\n            if (this.time > 1.5) {\n                this.markAsClean();\n            }\n        }\n    }\n    renderMaterial(rc) {\n        // epilepsy issue -- dissolving with dithering would be better,\n        // but i'd need to work it into the pbr shader somehow :(\n        if (this.frame % 2 === 0 && this.instance.valid()) {\n            let mat = this.getTransformationMatrix();\n            let res = gl_matrix_1.mat4.identity(gl_matrix_1.mat4.create());\n            gl_matrix_1.mat4.translate(res, res, [0, Math.pow(this.time, 2.4) * 4.5, 0]);\n            gl_matrix_1.mat4.mul(res, res, mat);\n            let inst = this.instance.get();\n            inst.modelMat = res;\n            inst.draw(rc);\n        }\n        if (rc.getRenderPass() === RenderContext_1.RenderPass.FINAL && this.destroyed) {\n            this.frame++;\n        }\n    }\n    destroy() {\n        this.destroyed = true;\n    }\n}\nexports.KnightTile = KnightTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/KnightTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/PowerupTile.ts":
/*!****************************************************!*\
  !*** ./client/ts/game/tile/generic/PowerupTile.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PowerupTile = void 0;\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nconst TileID_1 = __webpack_require__(/*! ../TileID */ \"./client/ts/game/tile/TileID.ts\");\nclass PowerupTile extends GameTile_1.GameTile {\n    constructor(ctx, base, power, id) {\n        super(ctx);\n        this.base = base;\n        this.power = power;\n        switch (id) {\n            case TileID_1.TileID.POWER_BOMB:\n                this.col = [0.0, 0.15, .75, 1.0];\n                break;\n            case TileID_1.TileID.POWER_RADIUS:\n                this.col = [.75, 0.0, 0.0, 1.0];\n                break;\n            case TileID_1.TileID.POWER_SPEED:\n                this.col = [.75, 0.21, 0.00, 1.0];\n        }\n        this.time = 0;\n    }\n    update() {\n        this.time += this.getContext().getDelta();\n        this.setRotationEuler(0, this.time * 144, 0);\n    }\n    renderMaterial(rc) {\n        let mat = this.getTransformationMatrix();\n        if (this.base.valid()) {\n            let base = this.base.get();\n            base.modelMat = mat;\n            base.color = this.col;\n            base.draw(rc);\n        }\n        if (this.power.valid()) {\n            let power = this.power.get();\n            power.modelMat = mat;\n            power.draw(rc);\n        }\n    }\n    destroy() {\n        this.markAsClean();\n    }\n}\nexports.PowerupTile = PowerupTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/PowerupTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/generic/WallTile.ts":
/*!*************************************************!*\
  !*** ./client/ts/game/tile/generic/WallTile.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WallTile = void 0;\nconst GameTile_1 = __webpack_require__(/*! ../GameTile */ \"./client/ts/game/tile/GameTile.ts\");\nclass WallTile extends GameTile_1.GameTile {\n    constructor(ctx, inst) {\n        super(ctx);\n        this.instance = inst;\n    }\n    renderMaterial(rc) {\n        if (this.instance.valid()) {\n            let inst = this.instance.get();\n            inst.modelMat = this.getTransformationMatrix();\n            inst.draw(rc);\n        }\n    }\n    destroy() {\n        this.markAsClean();\n    }\n}\nexports.WallTile = WallTile;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/generic/WallTile.ts?");

/***/ }),

/***/ "./client/ts/game/tile/instancefactory/ExplosionInstanceFactory.ts":
/*!*************************************************************************!*\
  !*** ./client/ts/game/tile/instancefactory/ExplosionInstanceFactory.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExplosionInstanceFactory = exports.NOISE_OFFSET_INDEX = exports.NOISE_SCALE_INDEX = exports.COLOR_INDEX = exports.THRESHOLD_INDEX = exports.MODEL_MAT_INDEX = void 0;\nconst RenderContext_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst InstancedExplosionMaterial_1 = __webpack_require__(/*! ../../material/InstancedExplosionMaterial */ \"./client/ts/game/material/InstancedExplosionMaterial.ts\");\nconst ExplosionInstanceImpl_1 = __webpack_require__(/*! ./instance/internal/ExplosionInstanceImpl */ \"./client/ts/game/tile/instancefactory/instance/internal/ExplosionInstanceImpl.ts\");\nexports.MODEL_MAT_INDEX = 4;\nexports.THRESHOLD_INDEX = 5;\nexports.COLOR_INDEX = 6;\nexports.NOISE_SCALE_INDEX = 7;\nexports.NOISE_OFFSET_INDEX = 8;\nclass ExplosionInstanceFactory {\n    // todo: write instanced material\n    // have it handle shadows and others\n    constructor(ctx, model) {\n        this.ctx = ctx;\n        this.model = model;\n        this.mat = new InstancedExplosionMaterial_1.InstancedExplosionMaterial(ctx);\n        this.currentPass = RenderContext_1.RenderPass.FINAL;\n        this.mat.instanceIndices = {\n            modelMat: exports.MODEL_MAT_INDEX,\n            threshold: exports.MODEL_MAT_INDEX,\n            color: exports.MODEL_MAT_INDEX,\n            noise_offset: exports.MODEL_MAT_INDEX\n        };\n        this.model.setInstancedMaterial(this.mat);\n    }\n    getInstance() {\n        let inst = new ExplosionInstanceImpl_1.ExplosionInstanceImpl(this.callbackfunc.bind(this));\n        return inst;\n    }\n    callbackfunc(inst, rc) {\n        let pass = rc.getRenderPass();\n        if (this.currentPass !== pass) {\n            this.currentPass = pass;\n            this.model.clearInstances();\n        }\n        this.model.appendInstanceData(exports.MODEL_MAT_INDEX, inst.modelMat); // 64\n        this.model.appendInstanceData(exports.MODEL_MAT_INDEX, inst.threshold); // 68\n        this.model.appendInstanceData(exports.MODEL_MAT_INDEX, inst.color); // 84\n        this.model.appendInstanceData(exports.MODEL_MAT_INDEX, inst.noiseOffset); // 96\n        this.model.drawInstanced();\n    }\n}\nexports.ExplosionInstanceFactory = ExplosionInstanceFactory;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/instancefactory/ExplosionInstanceFactory.ts?");

/***/ }),

/***/ "./client/ts/game/tile/instancefactory/LavaTileFactory.ts":
/*!****************************************************************!*\
  !*** ./client/ts/game/tile/instancefactory/LavaTileFactory.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LavaTileFactory = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst TileFactoryStub_1 = __webpack_require__(/*! ../../../../../test/stub/TileFactoryStub */ \"./test/stub/TileFactoryStub.ts\");\nconst WallTile_1 = __webpack_require__(/*! ../generic/WallTile */ \"./client/ts/game/tile/generic/WallTile.ts\");\nconst TileID_1 = __webpack_require__(/*! ../TileID */ \"./client/ts/game/tile/TileID.ts\");\nclass LavaTileFactory extends TileFactoryStub_1.TileFactoryStub {\n    constructor(ctx) {\n        super(ctx);\n        this.lavaCrateFactory = new Task_1.Task();\n        ctx.getGLTFLoader().loadAsGLTFScene(\"../res/crate3d_lava.glb\").then(this.configureLavaFactory.bind(this));\n    }\n    configureLavaFactory(scene) {\n        this.lavaCrateFactory.resolve(scene.getPBRInstanceFactory(\"wall_lava\"));\n    }\n    getTileFromID(id) {\n        if (id === TileID_1.TileID.WALL) {\n            return new WallTile_1.WallTile(this.ctx, this.loadInstanceFromFactory(this.lavaCrateFactory.getFuture()));\n        }\n        return super.getTileFromID(id);\n    }\n    getLavaCrate() {\n    }\n}\nexports.LavaTileFactory = LavaTileFactory;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/instancefactory/LavaTileFactory.ts?");

/***/ }),

/***/ "./client/ts/game/tile/instancefactory/PowerupInstanceFactory.ts":
/*!***********************************************************************!*\
  !*** ./client/ts/game/tile/instancefactory/PowerupInstanceFactory.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PowerupInstanceFactory = void 0;\nconst RenderContext_1 = __webpack_require__(/*! ../../../../../hingler-party/client/ts/engine/render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst InstancedPowerupMaterial_1 = __webpack_require__(/*! ../../material/InstancedPowerupMaterial */ \"./client/ts/game/material/InstancedPowerupMaterial.ts\");\nconst ExplosionInstanceImpl_1 = __webpack_require__(/*! ./instance/internal/ExplosionInstanceImpl */ \"./client/ts/game/tile/instancefactory/instance/internal/ExplosionInstanceImpl.ts\");\nconst MODEL_MAT_INDEX = 9;\nconst COLOR_INDEX = 10;\nclass PowerupInstanceFactory {\n    constructor(ctx, model) {\n        this.ctx = ctx;\n        this.model = model;\n        this.mat = new InstancedPowerupMaterial_1.InstancedPowerupMaterial(ctx);\n        this.currentPass = RenderContext_1.RenderPass.FINAL;\n        this.mat.modelMatrixIndex = MODEL_MAT_INDEX;\n        this.mat.colorIndex = COLOR_INDEX;\n        this.model.setInstancedMaterial(this.mat);\n    }\n    getInstance() {\n        return new ExplosionInstanceImpl_1.ExplosionInstanceImpl(this.callbackfunc.bind(this));\n    }\n    callbackfunc(inst, rc) {\n        let pass = rc.getRenderPass();\n        if (this.currentPass !== pass) {\n            this.currentPass = pass;\n            this.model.clearInstances();\n        }\n        this.model.appendInstanceData(MODEL_MAT_INDEX, inst.modelMat);\n        this.model.appendInstanceData(COLOR_INDEX, inst.color);\n        this.model.drawInstanced();\n    }\n}\nexports.PowerupInstanceFactory = PowerupInstanceFactory;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/instancefactory/PowerupInstanceFactory.ts?");

/***/ }),

/***/ "./client/ts/game/tile/instancefactory/instance/ExplosionInstance.ts":
/*!***************************************************************************!*\
  !*** ./client/ts/game/tile/instancefactory/instance/ExplosionInstance.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExplosionInstance = void 0;\nconst ModelInstance_1 = __webpack_require__(/*! ../../../../../../hingler-party/client/ts/engine/model/ModelInstance */ \"./hingler-party/client/ts/engine/model/ModelInstance.ts\");\nclass ExplosionInstance extends ModelInstance_1.ModelInstance {\n}\nexports.ExplosionInstance = ExplosionInstance;\n;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/instancefactory/instance/ExplosionInstance.ts?");

/***/ }),

/***/ "./client/ts/game/tile/instancefactory/instance/internal/ExplosionInstanceImpl.ts":
/*!****************************************************************************************!*\
  !*** ./client/ts/game/tile/instancefactory/instance/internal/ExplosionInstanceImpl.ts ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExplosionInstanceImpl = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ExplosionInstance_1 = __webpack_require__(/*! ../ExplosionInstance */ \"./client/ts/game/tile/instancefactory/instance/ExplosionInstance.ts\");\nclass ExplosionInstanceImpl extends ExplosionInstance_1.ExplosionInstance {\n    constructor(callback) {\n        super();\n        this.callback = callback;\n        this.modelMat = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.identity(this.modelMat);\n        this.threshold = 0.0;\n        this.color = gl_matrix_1.vec4.create();\n        this.noiseScale = gl_matrix_1.vec3.create();\n        this.noiseOffset = gl_matrix_1.vec3.create();\n    }\n    draw(rc) {\n        this.callback(this, rc);\n    }\n}\nexports.ExplosionInstanceImpl = ExplosionInstanceImpl;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tile/instancefactory/instance/internal/ExplosionInstanceImpl.ts?");

/***/ }),

/***/ "./client/ts/game/tilegen/GridTileGenerator.ts":
/*!*****************************************************!*\
  !*** ./client/ts/game/tilegen/GridTileGenerator.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GridTileGenerator = void 0;\nconst TileID_1 = __webpack_require__(/*! ../tile/TileID */ \"./client/ts/game/tile/TileID.ts\");\nclass GridTileGenerator {\n    /**\n     * Creates a new GridTileGenerator.\n     * @param len - length of each column, in number of tiles.\n     */\n    constructor(len) {\n        this.len = len;\n        this.num = 0;\n    }\n    generateColumn() {\n        let res = new Array(this.len);\n        if (this.num % 2 === 1) {\n            for (let i = 0; i < this.len; i++) {\n                if (i % 2 === 1) {\n                    res[i] = TileID_1.TileID.WALL;\n                }\n                else {\n                    res[i] = TileID_1.TileID.EMPTY;\n                }\n            }\n        }\n        for (let i = 0; i < this.len; i++) {\n            let cratechance = Math.random();\n            if (res[i] !== TileID_1.TileID.WALL) {\n                if (cratechance < 0.25) {\n                    // todo: convert these over t osomething better >:)\n                    res[i] = TileID_1.TileID.CRATE;\n                }\n                else {\n                    res[i] = TileID_1.TileID.EMPTY;\n                }\n            }\n        }\n        this.num++;\n        return res;\n    }\n}\nexports.GridTileGenerator = GridTileGenerator;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/tilegen/GridTileGenerator.ts?");

/***/ }),

/***/ "./client/ts/game/ui/Counter.ts":
/*!**************************************!*\
  !*** ./client/ts/game/ui/Counter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Counter = void 0;\nconst CounterDigit_1 = __webpack_require__(/*! ./CounterDigit */ \"./client/ts/game/ui/CounterDigit.ts\");\nclass Counter {\n    constructor(width) {\n        this.animate = true;\n        this.digits = new Array(width);\n        this.digitContainer = document.createElement(\"div\");\n        this.init = false;\n        for (let i = width - 1; i >= 0; i--) {\n            this.digits[i] = new CounterDigit_1.CounterDigit();\n            this.digits[i].appendTo(this.digitContainer);\n        }\n        this.setValue(0);\n    }\n    toggleAnimation(animate) {\n        for (let digit of this.digits) {\n            digit.toggleAnimation(animate);\n        }\n        this.animate = animate;\n    }\n    setValue(val) {\n        if (!this.animate) {\n            val = Math.floor(val);\n        }\n        if (val !== this.value || !this.init) {\n            this.init = true;\n            this.value = val;\n            let valueMod = val;\n            // store offset of last digit\n            // if it's about to slide over (> 9), add to ours\n            // offset should be floored\n            // ensures that the first digit rolls over correctly\n            let offsetLast = (this.animate ? 9 + (val % 1) : 0);\n            let offsetCur;\n            for (let i = 0; i < this.digits.length; i++) {\n                offsetCur = Math.floor(valueMod % 10);\n                if (offsetLast > 9) {\n                    offsetCur += (offsetLast - 9);\n                }\n                this.digits[i].setValue(offsetCur);\n                offsetLast = offsetCur;\n                valueMod = valueMod / 10;\n            }\n        }\n    }\n    getElement() {\n        this.init = false;\n        return this.digitContainer;\n    }\n}\nexports.Counter = Counter;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/ui/Counter.ts?");

/***/ }),

/***/ "./client/ts/game/ui/CounterDigit.ts":
/*!*******************************************!*\
  !*** ./client/ts/game/ui/CounterDigit.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CounterDigit = void 0;\nclass CounterDigit {\n    /**\n     *\n     * @param parent - selector identifying initial parent.\n     */\n    constructor() {\n        this.digitStyle = document.createElement(\"div\");\n        this.digitStyle.textContent = \"0\";\n        this.digitContainer = document.createElement(\"div\");\n        this.digitTop = document.createElement(\"div\");\n        this.digitMiddle = document.createElement(\"div\");\n        this.digitBottom = document.createElement(\"div\");\n        this.digitContainer.appendChild(this.digitTop);\n        this.digitContainer.appendChild(this.digitMiddle);\n        this.digitContainer.appendChild(this.digitBottom);\n        this.digitContainer.classList.add(\"counter-container\");\n        this.digitStyle.classList.add(\"counter\");\n        this.digitStyle.appendChild(this.digitContainer);\n        this.animate = true;\n        this.value = 0;\n        this.anchor = 0;\n        window.addEventListener(\"resize\", () => {\n            // assume that we'll only have to resize counters when the window fucks up\n            this.heightCache = 0;\n        });\n        this.updateDigitState();\n    }\n    toggleAnimation(animate) {\n        this.animate = animate;\n        if (!animate) {\n            this.digitContainer.style.top = (this.heightCache * -1) + \"px\";\n        }\n    }\n    updateDigitState() {\n        let low = (this.anchor + 9) % 10;\n        let mid = this.anchor % 10;\n        let hi = (this.anchor + 1) % 10;\n        // might be really slow :(\n        this.digitTop.textContent = low.toString();\n        this.digitMiddle.textContent = mid.toString();\n        this.digitBottom.textContent = hi.toString();\n        let offset = this.value - this.anchor;\n        if (this.animate) {\n            if (this.heightCache <= 0) {\n                this.heightCache = (this.digitMiddle.clientHeight);\n            }\n            let offsetHTML = this.heightCache * (-1 - offset);\n            this.digitContainer.style.top = offsetHTML + \"px\";\n        }\n        else if (this.heightCache <= 0) {\n            this.heightCache = this.digitMiddle.clientHeight;\n            this.digitContainer.style.top = (this.heightCache * -1) + \"px\";\n        }\n    }\n    appendTo(elem) {\n        if (this.digitStyle.parentNode) {\n            this.digitStyle.parentNode.removeChild(this.digitStyle);\n        }\n        elem.appendChild(this.digitStyle);\n        this.heightCache = this.digitMiddle.clientHeight;\n        this.updateDigitState();\n    }\n    updateDigitSize() {\n        this.digitContainer.style.height = this.digitMiddle.clientHeight + \"px\";\n        console.log(this.digitMiddle.clientHeight);\n    }\n    setValue(val) {\n        val = (val < 0 ? -val : val);\n        let res = val % 10;\n        this.value = res;\n        this.anchor = Math.round(this.value);\n        this.updateDigitState();\n    }\n}\nexports.CounterDigit = CounterDigit;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/ui/CounterDigit.ts?");

/***/ }),

/***/ "./client/ts/game/ui/EnemyInfo.ts":
/*!****************************************!*\
  !*** ./client/ts/game/ui/EnemyInfo.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EnemyInfo = void 0;\nconst Counter_1 = __webpack_require__(/*! ./Counter */ \"./client/ts/game/ui/Counter.ts\");\nclass EnemyInfo {\n    constructor(imageURL) {\n        this.img = new Image();\n        this.img.src = imageURL;\n        this.counter = new Counter_1.Counter(4);\n        this.counter.setValue(0);\n        this.wrapper = document.createElement(\"div\");\n        this.wrapper.appendChild(this.img);\n        this.wrapper.appendChild(this.counter.getElement());\n        this.wrapper.classList.add(\"enemy\");\n        this.counter.getElement().classList.add(\"enemy-counter\");\n    }\n    getElement() {\n        return this.wrapper;\n    }\n    toggleAnimation(animate) {\n        this.counter.toggleAnimation(animate);\n    }\n    setValue(val) {\n        this.counter.setValue(val);\n    }\n}\nexports.EnemyInfo = EnemyInfo;\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/game/ui/EnemyInfo.ts?");

/***/ }),

/***/ "./client/ts/maptest.ts":
/*!******************************!*\
  !*** ./client/ts/maptest.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EngineContext_1 = __webpack_require__(/*! ../../hingler-party/client/ts/engine/internal/EngineContext */ \"./hingler-party/client/ts/engine/internal/EngineContext.ts\");\nconst SplashScreen_1 = __webpack_require__(/*! ./game/splashscreen/SplashScreen */ \"./client/ts/game/splashscreen/SplashScreen.ts\");\nwindow.addEventListener(\"load\", main);\nlet canvas;\nlet engine;\nfunction main() {\n    canvas = document.getElementById(\"canvas\");\n    window.addEventListener(\"resize\", resizeCanvas);\n    // prevent right click, long press\n    window.addEventListener(\"contextmenu\", (event) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    });\n    resizeCanvas();\n    configureEngine();\n}\nfunction resizeCanvas() {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n}\nfunction configureEngine() {\n    engine = new EngineContext_1.EngineContext(canvas, new SplashScreen_1.SplashScreenScene());\n    engine.deployContext();\n}\n\n\n//# sourceURL=webpack://hingler-online/./client/ts/maptest.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/animation/GLTFAnimationBuilder.ts":
/*!**************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/animation/GLTFAnimationBuilder.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFAnimationBuilder = void 0;\nconst gltfTypes_1 = __webpack_require__(/*! ../loaders/internal/gltfTypes */ \"./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts\");\nconst LinearVectorSampler_1 = __webpack_require__(/*! nekogirl-valhalla/animation/samplers/LinearVectorSampler */ \"./node_modules/nekogirl-valhalla/animation/samplers/LinearVectorSampler.js\");\nconst LinearQuatSampler_1 = __webpack_require__(/*! nekogirl-valhalla/animation/samplers/LinearQuatSampler */ \"./node_modules/nekogirl-valhalla/animation/samplers/LinearQuatSampler.js\");\nconst GLTFAnimationManager_1 = __webpack_require__(/*! ./internal/GLTFAnimationManager */ \"./hingler-party/client/ts/engine/animation/internal/GLTFAnimationManager.ts\");\nclass GLTFAnimationBuilder {\n    static buildAnimationManager(data, anim, buffers) {\n        const transformSamplers = new Map();\n        const rotationSamplers = new Map();\n        const scaleSamplers = new Map();\n        for (let channel of anim.channels) {\n            const sampler = this.convertChannelToSampler(data, anim, channel, buffers);\n            // note: this will not work if we need to implement different types\n            // workaround: implement different methods for TS and R\n            switch (channel.target.path) {\n                case gltfTypes_1.GLTFTargetPathType.TRANSLATION:\n                    if (!(sampler instanceof LinearVectorSampler_1.LinearVectorSampler)) {\n                        const err = \"Translation target must be vec3!\";\n                        throw Error(err);\n                    }\n                    transformSamplers.set(channel.target.node, sampler);\n                    break;\n                case gltfTypes_1.GLTFTargetPathType.SCALE:\n                    if (!(sampler instanceof LinearVectorSampler_1.LinearVectorSampler)) {\n                        const err = \"Scale target must be vec3!\";\n                        throw Error(err);\n                    }\n                    scaleSamplers.set(channel.target.node, sampler);\n                    break;\n                case gltfTypes_1.GLTFTargetPathType.ROTATION:\n                    if (!(sampler instanceof LinearQuatSampler_1.LinearQuatSampler)) {\n                        const err = \"Rotation target must be quat!\";\n                        throw Error(err);\n                    }\n                    rotationSamplers.set(channel.target.node, sampler);\n            }\n        }\n        return new GLTFAnimationManager_1.GLTFAnimationManager(transformSamplers, rotationSamplers, scaleSamplers);\n    }\n    static convertChannelToSampler(data, anim, channel, buffers) {\n        const samplerIndex = channel.sampler;\n        const sampler = anim.samplers[samplerIndex];\n        if (!sampler) {\n            const err = `Sampler ${samplerIndex} not found!`;\n            throw Error(err);\n        }\n        // input should always be scalars\n        // output should almost always be vec3 or vec4\n        if (sampler.interpolation !== gltfTypes_1.GLTFSamplerInterpolation.LINEAR) {\n            const err = `Cannot currently handle sampler interpolation types other than LINEAR`;\n            throw Error(err);\n        }\n        const typeOut = channel.target.path;\n        const [bufIn, offsetIn, strideIn, countIn, accessorTypeIn] = this.getBufferFromSamplerParameter(data, sampler.input, buffers);\n        const [bufOut, offsetOut, strideOut, countOut, accessorTypeOut] = this.getBufferFromSamplerParameter(data, sampler.output, buffers);\n        // ensure that the broadcasted output type and the accessor output type agree\n        if (((typeOut === gltfTypes_1.GLTFTargetPathType.ROTATION) && accessorTypeOut !== gltfTypes_1.GLTFAccessorType.VEC4)\n            || (typeOut !== gltfTypes_1.GLTFTargetPathType.ROTATION && accessorTypeOut !== gltfTypes_1.GLTFAccessorType.VEC3)) {\n            const err = `Node type and accessor type for output on channel do not agree -- typeOut ${typeOut}, accessorTypeOut ${accessorTypeOut}`;\n            throw Error(err);\n        }\n        if (accessorTypeIn !== gltfTypes_1.GLTFAccessorType.SCALAR) {\n            const error = `Expected accessor for input to be of type \"SCALAR\"`;\n            throw Error(error);\n        }\n        switch (sampler.interpolation) {\n            case gltfTypes_1.GLTFSamplerInterpolation.LINEAR:\n                if (countIn !== countOut) {\n                    const err = \"Expected number of inputs and outputs to be equal!\";\n                    throw Error(err);\n                }\n                if (accessorTypeOut === gltfTypes_1.GLTFAccessorType.VEC3) {\n                    return this.createLinearSamplerVec3(bufIn, offsetIn, strideIn, bufOut, offsetOut, strideOut, countIn);\n                }\n                else {\n                    return this.createLinearSamplerQuat(bufIn, offsetIn, strideIn, bufOut, offsetOut, strideOut, countIn);\n                }\n        }\n    }\n    static getBufferFromSamplerParameter(data, accessorIndex, buffers) {\n        if (!data.accessors) {\n            const err = \"No accessors present on GLTF file!\";\n            throw Error(err);\n        }\n        const inputAccessor = data.accessors[accessorIndex];\n        if (!inputAccessor) {\n            const err = `Referenced accessor ${accessorIndex} in sampler not found!`;\n            throw Error(err);\n        }\n        if (!data.bufferViews) {\n            const err = \"No buffer views present on GLTF file!\";\n            throw Error(err);\n        }\n        const inputBufferView = data.bufferViews[inputAccessor.bufferView];\n        if (!inputBufferView) {\n            const err = `Referenced buffer view in accessor ${accessorIndex} not found!`;\n            throw Error(err);\n        }\n        const buf = buffers[inputBufferView.buffer];\n        if (!buf) {\n            const err = `inputBufferView referenced nonexistent buffer ${inputBufferView.buffer}!`;\n            throw Error(err);\n        }\n        const offset = (inputBufferView.byteOffset || 0) + (inputAccessor.byteOffset || 0);\n        const stride = inputBufferView.byteStride || 4 * (this.getComponentCount(inputAccessor.type));\n        return [buf, offset, stride, inputAccessor.count, inputAccessor.type];\n    }\n    static getComponentCount(type) {\n        switch (type) {\n            case gltfTypes_1.GLTFAccessorType.SCALAR:\n                return 1;\n            case gltfTypes_1.GLTFAccessorType.VEC3:\n                return 3;\n            case gltfTypes_1.GLTFAccessorType.VEC4:\n                return 4;\n            default:\n                console.warn(\"!!!!!!\");\n                return 0;\n        }\n    }\n    static createLinearSamplerVec3(bufIn, offsetIn, strideIn, bufOut, offsetOut, strideOut, count) {\n        const output = new LinearVectorSampler_1.LinearVectorSampler();\n        for (let i = 0; i < count; i++) {\n            const sampleTime = bufIn.getFloat32(offsetIn + strideIn * i, true);\n            const sampleVal = bufOut.getFloat32Array(offsetOut + strideOut * i, 3);\n            output.insert(sampleTime, sampleVal);\n        }\n        return output;\n    }\n    static createLinearSamplerQuat(bufIn, offsetIn, strideIn, bufOut, offsetOut, strideOut, count) {\n        const output = new LinearQuatSampler_1.LinearQuatSampler();\n        for (let i = 0; i < count; i++) {\n            const sampleTime = bufIn.getFloat32(offsetIn + strideIn * i, true);\n            const sampleVal = bufOut.getFloat32Array(offsetOut + strideOut * i, 4);\n            output.insert(sampleTime, sampleVal);\n        }\n        return output;\n    }\n}\nexports.GLTFAnimationBuilder = GLTFAnimationBuilder;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/animation/GLTFAnimationBuilder.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/animation/internal/GLTFAnimationManager.ts":
/*!***********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/animation/internal/GLTFAnimationManager.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFAnimationManager = void 0;\nclass GLTFAnimationManager {\n    constructor(positions, rotations, scales) {\n        this.positions = positions;\n        this.rotations = rotations;\n        this.scales = scales;\n    }\n    sample(nodeID, time) {\n        const posSampler = this.positions.get(nodeID);\n        const rotSampler = this.rotations.get(nodeID);\n        const scaSampler = this.scales.get(nodeID);\n        const res = {};\n        if (posSampler) {\n            res.position = posSampler.sample(time, []);\n        }\n        if (rotSampler) {\n            res.rotation = rotSampler.sample(time, []);\n        }\n        if (scaSampler) {\n            res.scale = scaSampler.sample(time, []);\n        }\n        return res;\n    }\n}\nexports.GLTFAnimationManager = GLTFAnimationManager;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/animation/internal/GLTFAnimationManager.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/component/ComponentType.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/component/ComponentType.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComponentType = void 0;\nvar ComponentType;\n(function (ComponentType) {\n    ComponentType[\"MODEL\"] = \"model\";\n    ComponentType[\"ALPHATEXTURE\"] = \"alphatexture\";\n})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/component/ComponentType.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/component/impl/AlphaTextureComponent.ts":
/*!********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/component/impl/AlphaTextureComponent.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlphaTextureComponent = void 0;\nconst ComponentType_1 = __webpack_require__(/*! ../ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nclass AlphaTextureComponent {\n    constructor() {\n        this.type = ComponentType_1.ComponentType.ALPHATEXTURE;\n    }\n}\nexports.AlphaTextureComponent = AlphaTextureComponent;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/component/impl/AlphaTextureComponent.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/component/impl/ModelComponent.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/component/impl/ModelComponent.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelComponent = void 0;\nconst ComponentType_1 = __webpack_require__(/*! ../ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nclass ModelComponent {\n    constructor() {\n        this.type = ComponentType_1.ComponentType.MODEL;\n    }\n}\nexports.ModelComponent = ModelComponent;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/component/impl/ModelComponent.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/component/internal/ComponentManager.ts":
/*!*******************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/component/internal/ComponentManager.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComponentManager = void 0;\nconst ComponentType_1 = __webpack_require__(/*! ../ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nconst AlphaTextureComponent_1 = __webpack_require__(/*! ../impl/AlphaTextureComponent */ \"./hingler-party/client/ts/engine/component/impl/AlphaTextureComponent.ts\");\nconst ModelComponent_1 = __webpack_require__(/*! ../impl/ModelComponent */ \"./hingler-party/client/ts/engine/component/impl/ModelComponent.ts\");\nclass ComponentManager {\n    static getComponent(type) {\n        switch (type) {\n            case ComponentType_1.ComponentType.MODEL:\n                return new ModelComponent_1.ModelComponent();\n            case ComponentType_1.ComponentType.ALPHATEXTURE:\n                return new AlphaTextureComponent_1.AlphaTextureComponent();\n        }\n    }\n}\nexports.ComponentManager = ComponentManager;\n// makes sense to organize components here\n// if we go full ECS, we'll store components here statically\n// our context will fetch from this manager...\n// and clear it when relevant\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/component/internal/ComponentManager.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/filter/FXAAFilter.ts":
/*!*************************************************************!*\
  !*** ./hingler-party/client/ts/engine/filter/FXAAFilter.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FXAAFilter = void 0;\nconst ColorFramebuffer_1 = __webpack_require__(/*! ../gl/internal/ColorFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst PostProcessingFilter_1 = __webpack_require__(/*! ../material/PostProcessingFilter */ \"./hingler-party/client/ts/engine/material/PostProcessingFilter.ts\");\nclass FXAAFilter extends PostProcessingFilter_1.PostProcessingFilter {\n    constructor(ctx) {\n        super(ctx);\n        this.lumaFramebuffer = new ColorFramebuffer_1.ColorFramebuffer(ctx, ctx.getScreenDims());\n        this.aaShader = null;\n        this.lumaShader = null;\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/fxaa/fxaa.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/fxaa/fxaa.frag\"))\n            .build()\n            .then(this.bindUniforms.bind(this));\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/texturexfer/texturexfer.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/lum/lum.frag\"))\n            .build()\n            .then(this.bindUniformsLuma.bind(this));\n    }\n    bindUniforms(res) {\n        this.aaShader = res;\n        const gl = this.getContext().getGLContext();\n        this.locs = {\n            aPosition: gl.getAttribLocation(this.aaShader, \"aPosition\")\n        };\n        this.unifs = {\n            col: gl.getUniformLocation(this.aaShader, \"col\"),\n            lum: gl.getUniformLocation(this.aaShader, \"lum\"),\n            resolution: gl.getUniformLocation(this.aaShader, \"resolution\")\n        };\n    }\n    bindUniformsLuma(res) {\n        this.lumaShader = res;\n        const gl = this.getContext().getGLContext();\n        this.lumaPos = gl.getAttribLocation(this.lumaShader, \"aPosition\");\n        this.lumaTex = gl.getUniformLocation(this.lumaShader, \"disp\");\n    }\n    runFilter(src, dst, rc) {\n        const timer = this.getContext().getGPUTimer();\n        const id = timer.startQuery();\n        if (this.aaShader !== null && this.lumaShader !== null) {\n            const gl = this.getContext().getGLContext();\n            const wrap = this.getContext().getGL();\n            const oldDims = this.lumaFramebuffer.dims;\n            const newDims = this.getContext().getScreenDims();\n            if (oldDims[0] !== newDims[0] || oldDims[1] !== newDims[1]) {\n                this.lumaFramebuffer.setFramebufferSize(newDims);\n            }\n            gl.viewport(0, 0, newDims[0], newDims[1]);\n            wrap.useProgram(this.lumaShader);\n            this.lumaFramebuffer.bindFramebuffer(gl.FRAMEBUFFER);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n            src.getColorTexture().bindToUniform(this.lumaTex, 1);\n            const buf = this.getScreenBuffer();\n            wrap.bindBuffer(gl.ARRAY_BUFFER, buf);\n            gl.vertexAttribPointer(this.lumaPos, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.lumaPos);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.lumaPos);\n            wrap.useProgram(this.aaShader);\n            dst.bindFramebuffer(gl.FRAMEBUFFER);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            this.lumaFramebuffer.getColorTexture().bindToUniform(this.unifs.lum, 0);\n            src.getColorTexture().bindToUniform(this.unifs.col, 1);\n            gl.uniform2fv(this.unifs.resolution, newDims);\n            gl.vertexAttribPointer(this.locs.aPosition, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.locs.aPosition);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.locs.aPosition);\n        }\n        timer.stopQueryAndLog(id, \"FXAAFilter\", performanceanalytics_1.RenderType.POST);\n    }\n}\nexports.FXAAFilter = FXAAFilter;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/filter/FXAAFilter.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/ColorCubemap.ts":
/*!***********************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/ColorCubemap.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorCubemap = void 0;\nconst Texture_1 = __webpack_require__(/*! ./Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\n// would be nice to poll texture support?\nclass ColorCubemap {\n    /**\n     * Creates a new Cubemap\n     * @param ctx - gamecontext\n     * @param dims - size of each cube face\n     */\n    constructor(ctx, dim) {\n        // note: what about shadow cubemaps?\n        // what happens when I need those?\n        this.ctx = ctx;\n        const gl = this.ctx.getGLContext();\n        this.cube = gl.createTexture();\n        ctx.getGLExtension(\"OES_texture_float\");\n        const linear = !!ctx.getGLExtension(\"OES_texture_float_linear\");\n        // firefox complains about this???\n        ctx.getGLExtension(\"WEBGL_color_buffer_float\");\n        if (ctx.webglVersion === 2) {\n            // 16f mipmap\n            ctx.getGLExtension(\"EXT_color_buffer_float\");\n        }\n        this.dims = dim;\n        const wrap = ctx.getGL();\n        const ind = wrap.bindTexture(this.cube, gl.TEXTURE_CUBE_MAP);\n        gl.activeTexture(ind);\n        // lule\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const ver = this.ctx.webglVersion;\n        for (let i = 0; i < 6; i++) {\n            // alloc our textures\n            if (ver === 2) {\n                const gl2 = gl;\n                gl2.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl2.RGBA16F, dim, dim, 0, gl.RGBA, gl.FLOAT, null);\n            }\n            else {\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, dim, dim, 0, gl.RGBA, gl.FLOAT, null);\n            }\n        }\n    }\n    generateMipmaps() {\n        // \"lazy texture initialization on level 0\"\n        // no idea what this means but i assume it has something to do with the crash before load\n        const gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(this.cube, gl.TEXTURE_CUBE_MAP));\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    }\n    attachToFramebuffer(face, framebuffer, mipLevel, target) {\n        let mip = mipLevel;\n        let targ = target;\n        const gl = this.ctx.getGLContext();\n        if (mip === undefined) {\n            mip = 0;\n        }\n        if (targ === undefined) {\n            targ = gl.COLOR_ATTACHMENT0;\n        }\n        const off = face - gl.TEXTURE_CUBE_MAP_POSITIVE_X;\n        if (off < 0 || off > 5) {\n            console.warn(\"Invalid face for bind call: \" + face);\n            return;\n        }\n        const wrap = this.ctx.getGL();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(wrap.bindTexture(this.cube, gl.TEXTURE_CUBE_MAP));\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, targ, face, this.cube, mip);\n    }\n    bindToUniform(location, index) {\n        const gl = this.ctx.getGLContext();\n        if (index > 31 || index < 0) {\n            const err = \"OOB index\";\n            console.error(err);\n            throw Error(err);\n        }\n        const wrap = this.ctx.getGL();\n        wrap.bindTexture(this.cube, gl.TEXTURE_CUBE_MAP, location);\n    }\n    bindCubemap(location, index) {\n        const gl = this.ctx.getGLContext();\n        let loc;\n        let slot;\n        if (location === undefined) {\n            loc = gl.TEXTURE_CUBE_MAP;\n        }\n        else {\n            loc = location;\n        }\n        if (index === undefined || (index < 0 || index >= 32)) {\n            slot = gl.TEXTURE0;\n        }\n        else {\n            slot = gl.TEXTURE0 + index;\n        }\n        gl.activeTexture(this.ctx.getGL().bindTexture(this.cube, loc));\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.RGBA;\n    }\n}\nexports.ColorCubemap = ColorCubemap;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/ColorCubemap.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/ShaderEnv.ts":
/*!********************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/ShaderEnv.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEnv = void 0;\n;\n/**\n *  Handles caching of shader context vars as well as converting them into GLSL preproc defines.\n */\nclass ShaderEnv {\n    constructor() {\n        this.shaderEnvMap = new Map();\n        this.shaderEnvDirty = false;\n        this.shaderEnvCache = \"\\n\";\n    }\n    /**\n     *  Sets a shader environment variable.\n     *  @param key - name of the var\n     *  @param val - typically a number -- assumed null otherwise\n     *  @param integer - optional param indicates if a number should be stored as an integer. default: false\n     */\n    setShaderVar(key, val, integer) {\n        // differentiating ints from floats?\n        let defVal = val;\n        // ensure bad types dont fuck shit up\n        if (typeof val !== \"number\") {\n            defVal = null;\n        }\n        const res = {\n            \"val\": defVal,\n            integer: (!!integer)\n        };\n        this.shaderEnvMap.set(key, res);\n        this.shaderEnvDirty = true;\n    }\n    getShaderEnv() {\n        if (this.shaderEnvDirty) {\n            let cache = \"\";\n            for (let entry of this.shaderEnvMap) {\n                const def = entry[1];\n                // if int: add floor\n                // if float: do a naive tostring and a toFixed(1) -- take the longer of the two\n                let line = `#define ${entry[0]}`;\n                if (def.val !== null) {\n                    if (entry[1].integer) {\n                        line = line.concat(` ${Math.floor(def.val).toString()}`);\n                    }\n                    else {\n                        // floating point\n                        const lineP = def.val.toFixed(1);\n                        const lineV = def.val.toString();\n                        line = line.concat(` ${(lineP.length > lineV.length ? lineP : lineV)}`);\n                    }\n                }\n                cache = cache.concat(`${line}\\n`);\n            }\n            this.shaderEnvCache = cache;\n            this.shaderEnvDirty = false;\n        }\n        return this.shaderEnvCache;\n    }\n}\nexports.ShaderEnv = ShaderEnv;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/ShaderEnv.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// build shaders from scratch\n// support include syntax path relative\n// i already wrote this in cpp :)\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderProgramBuilder = exports.shadersStillCompiling = exports.isShaderCompiling = void 0;\nconst Task_1 = __webpack_require__(/*! ../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst ShaderFileParser_1 = __webpack_require__(/*! ./internal/ShaderFileParser */ \"./hingler-party/client/ts/engine/gl/internal/ShaderFileParser.ts\");\n// TODO:\n// separate local imports and imports from our engine folder\n// first, check the engine folder\n// then, check local directory\nconst shaderCache = new Map();\nconst shadersCompiling = new Map();\n// load shader async compile\n// use a static func to check the shadercache at the end of each frame,\n// and resolve any lingering promises\nfunction isShaderCompiling() {\n    return (shadersCompiling.size === 0);\n}\nexports.isShaderCompiling = isShaderCompiling;\nfunction shadersStillCompiling() {\n    return (shadersCompiling.size);\n}\nexports.shadersStillCompiling = shadersStillCompiling;\n/**\n * Builds shaders from files.\n * Also supports non-standard include syntax for incorporating shader code from other files.\n */\nclass ShaderProgramBuilder {\n    constructor(ctx) {\n        this.vertPath = null;\n        this.fragPath = null;\n        this.ctx = ctx;\n        this.fileParser = new ShaderFileParser_1.ShaderFileParser(this.ctx);\n        this.flags = [];\n    }\n    /**\n     * Builder function which specifies a vertex shader.\n     * @param vertexPath - the path to the desired vertex shader.\n     * @returns the builder instance.\n     */\n    withVertexShader(vertexPath) {\n        // cue an async method which will build the shader\n        this.vertPath = vertexPath;\n        return this;\n    }\n    /**\n     * Builder which specifies a fragment shader.\n     * @param fragmentPath - the path to the desired fragment shader.\n     * @returns the builder instance.\n     */\n    withFragmentShader(fragmentPath) {\n        this.fragPath = fragmentPath;\n        return this;\n    }\n    withFlags(...flags) {\n        this.flags.push(...flags);\n        this.fileParser.setProgramFlags(this.flags);\n        return this;\n    }\n    getPathString() {\n        return `${this.vertPath}|${this.fragPath}:${this.flags.join(\",\")}`;\n    }\n    buildFuture() {\n        if (this.vertPath === null || this.fragPath === null) {\n            let err = `Missing ${this.vertPath === null ? \"vertex \" : \"\"}${this.vertPath === null && this.fragPath === null ? \"and \" : \"\"}${this.fragPath === null ? \"fragment \" : \"\"}shader!`;\n            console.error(err);\n            throw err;\n        }\n        let progTask = new Task_1.Task();\n        // errors from compilation will throw here\n        // `<vertpath>|<fragpath>:flagA,flagB,...,flagZ`\n        let pathString = this.getPathString();\n        if (shaderCache.has(pathString)) {\n            progTask.resolve(shaderCache.get(pathString));\n        }\n        else if (shadersCompiling.has(pathString)) {\n            shadersCompiling.get(pathString).then(() => {\n                if (shaderCache.has(pathString)) {\n                    progTask.resolve(shaderCache.get(pathString));\n                }\n            });\n        }\n        else {\n            this.build().then((prog) => {\n                progTask.resolve(prog);\n            });\n        }\n        return progTask.getFuture();\n    }\n    /**\n     * Builds the shader.\n     * @returns a promise which rejects if either shader is missing or invalid, or if a link error occurs, and resolves to the compiled program.\n     */\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // since our shaders are async: we ought to come up with a way to return this :(\n            // in usage: if the built shader is not ready yet, then perform a no-op when drawing.\n            if (this.vertPath === null || this.fragPath === null) {\n                let err = `Missing ${this.vertPath === null ? \"vertex \" : \"\"}${this.vertPath === null && this.fragPath === null ? \"and \" : \"\"}${this.fragPath === null ? \"fragment \" : \"\"}shader!`;\n                console.error(err);\n                throw err;\n            }\n            const gl = this.ctx.getGLContext();\n            // errors from compilation will throw here\n            let pathString = this.getPathString();\n            if (shadersCompiling.has(pathString)) {\n                yield shadersCompiling.get(pathString);\n                // shader is compiling -- wait for completion\n            }\n            if (shaderCache.has(pathString)) {\n                // since we've already waited for compilation: if this is false, the shader has not been compiled yet.\n                return shaderCache.get(pathString);\n            }\n            let res;\n            let rej;\n            let progress = new Promise((resolve, reject) => {\n                res = resolve;\n                rej = reject;\n            });\n            // use futures for this\n            // parallel: linkprogram will be an async call\n            // perframe:\n            //  - check linkstatus\n            //    - note: we'll have to put the program somewhere where we can see what its up to\n            //  - if failed, log link log, then shader logs, reject.\n            //  - if succeed, resolve.\n            shadersCompiling.set(pathString, progress);\n            let vertShader;\n            let fragShader;\n            this.fileParser.setProgramFlags(this.flags);\n            try {\n                vertShader = yield this.createShaderFromFile_(this.vertPath, gl.VERTEX_SHADER);\n                fragShader = yield this.createShaderFromFile_(this.fragPath, gl.FRAGMENT_SHADER);\n            }\n            catch (e) {\n                console.error(e);\n                rej(e);\n            }\n            let prog = gl.createProgram();\n            gl.attachShader(prog, vertShader[0]);\n            gl.attachShader(prog, fragShader[0]);\n            gl.linkProgram(prog);\n            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n                console.log(\"Encountered linking error: \" + gl.getProgramParameter(prog, gl.LINK_STATUS));\n                let info = gl.getProgramInfoLog(prog);\n                console.error(info);\n                // only check compilation status if link fails\n                for (let tuple of [vertShader, fragShader]) {\n                    const shader = tuple[0];\n                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                        let log = gl.getShaderInfoLog(shader);\n                        this.printParsedShaderWithLineNumbers(tuple[1], \"\");\n                        console.error(log);\n                        gl.deleteShader(shader);\n                        throw Error(log);\n                    }\n                }\n                rej();\n                throw Error(info);\n            }\n            // shader is not cached -- cache it!\n            shaderCache.set(pathString, prog);\n            shadersCompiling.delete(pathString);\n            res();\n            return prog;\n        });\n    }\n    createShaderFromFile_(shaderPath, shaderType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gl = this.ctx.getGLContext();\n            let shader = gl.createShader(shaderType);\n            let contents = yield this.fileParser.parseShaderFile(shaderPath, (shaderType === gl.VERTEX_SHADER));\n            gl.shaderSource(shader, contents);\n            gl.compileShader(shader);\n            return [shader, contents];\n        });\n    }\n    printParsedShaderWithLineNumbers(shader, path) {\n        let lines = shader.split(/\\r?\\n/);\n        let breaks = Math.ceil(Math.log10(lines.length + 1)) + 2;\n        for (let i = 0; i < lines.length; i++) {\n            let numstr = (i + 1).toString(10).padEnd(breaks, \" \");\n            lines[i] = numstr + lines[i];\n        }\n        console.warn(`Error in ${path}: \\n${lines.join(\"\\r\\n\")}`);\n    }\n}\nexports.ShaderProgramBuilder = ShaderProgramBuilder;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/Texture.ts":
/*!******************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/Texture.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Texture = exports.WrapMode = exports.SamplingMode = exports.TextureFormat = void 0;\nvar TextureFormat;\n(function (TextureFormat) {\n    TextureFormat[TextureFormat[\"RGBA\"] = 0] = \"RGBA\";\n    TextureFormat[TextureFormat[\"RGB\"] = 1] = \"RGB\";\n    TextureFormat[TextureFormat[\"DEPTH\"] = 2] = \"DEPTH\";\n})(TextureFormat = exports.TextureFormat || (exports.TextureFormat = {}));\n;\nvar SamplingMode;\n(function (SamplingMode) {\n    SamplingMode[SamplingMode[\"NEAREST\"] = 0] = \"NEAREST\";\n    SamplingMode[SamplingMode[\"LINEAR\"] = 1] = \"LINEAR\";\n    SamplingMode[SamplingMode[\"LINEAR_MIPMAP_LINEAR\"] = 2] = \"LINEAR_MIPMAP_LINEAR\";\n    SamplingMode[SamplingMode[\"LINEAR_MIPMAP_NEAREST\"] = 3] = \"LINEAR_MIPMAP_NEAREST\";\n})(SamplingMode = exports.SamplingMode || (exports.SamplingMode = {}));\n;\nvar WrapMode;\n(function (WrapMode) {\n    WrapMode[WrapMode[\"REPEAT\"] = 0] = \"REPEAT\";\n    WrapMode[WrapMode[\"CLAMP\"] = 1] = \"CLAMP\";\n    WrapMode[WrapMode[\"MIRRORED_REPEAT\"] = 2] = \"MIRRORED_REPEAT\";\n})(WrapMode = exports.WrapMode || (exports.WrapMode = {}));\n;\nclass Texture {\n    static pot(n) {\n        return !(n & (n - 1));\n    }\n    handleTextureSampling(tex, ctx, mode) {\n        const pot = Texture.pot(this.dims[0]) && Texture.pot(this.dims[1]);\n        const gl = ctx.getGLContext();\n        const wrap = ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(tex, gl.TEXTURE_2D));\n        switch (mode) {\n            case SamplingMode.LINEAR:\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                break;\n            case SamplingMode.NEAREST:\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                break;\n            case SamplingMode.LINEAR_MIPMAP_NEAREST:\n                if (!pot) {\n                    console.warn(\"Attempted to generate mipmaps for non-POT texture!\");\n                    return false;\n                }\n                // redundant mipmap gen? whatever its safe :)\n                gl.generateMipmap(gl.TEXTURE_2D);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                break;\n            case SamplingMode.LINEAR_MIPMAP_LINEAR:\n                if (!pot) {\n                    console.warn(\"Attempted to generate mipmaps for non-POT texture!\");\n                    return false;\n                }\n                gl.generateMipmap(gl.TEXTURE_2D);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                break;\n        }\n    }\n    handleWrapMode(tex, ctx, wrapS, wrapT) {\n        const gl = ctx.getGLContext();\n        const wrap = ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(tex, gl.TEXTURE_2D));\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapModeToNumber(gl, wrapS));\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapModeToNumber(gl, wrapT));\n    }\n    wrapModeToNumber(gl, mode) {\n        switch (mode) {\n            case WrapMode.CLAMP:\n                return gl.CLAMP_TO_EDGE;\n            case WrapMode.REPEAT:\n                return gl.REPEAT;\n            case WrapMode.MIRRORED_REPEAT:\n                return gl.MIRRORED_REPEAT;\n        }\n    }\n    static createTextureFromImage(ctx, img, sampler) {\n        if (!sampler) {\n            sampler = {};\n        }\n        const gl = ctx.getGLContext();\n        const wrap = ctx.getGL();\n        let dims = [img.width, img.height];\n        let tex = gl.createTexture();\n        gl.activeTexture(wrap.bindTexture(tex, gl.TEXTURE_2D));\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n        let mag = (sampler.magFilter ? sampler.magFilter : gl.LINEAR);\n        let min = (sampler.minFilter ? sampler.minFilter : gl.LINEAR);\n        let wrapS = (sampler.wrapS ? sampler.wrapS : gl.REPEAT);\n        let wrapT = (sampler.wrapT ? sampler.wrapT : gl.REPEAT);\n        // nonstandard: webgl1 doesn't like npot textures w repeat\n        // if either is set to repeat\n        // if pot: both will be 0, else non 0\n        let pot = !(dims[0] & (dims[0] - 1)) && !(dims[1] & (dims[1] - 1));\n        if (!pot) {\n            console.warn(\"Encountered non-POT texture!\");\n        }\n        // account for potential mipmap generation\n        if ([9984, 9985, 9986, 9987].indexOf(min) !== -1 && pot) {\n            // min filter uses mipmaps -- ensure they are generated\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n        if (!pot) {\n            wrapS = (wrapS === gl.REPEAT ? gl.CLAMP_TO_EDGE : wrapS);\n            wrapT = (wrapT === gl.REPEAT ? gl.CLAMP_TO_EDGE : wrapT);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mag);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, min);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n        return [dims, tex];\n    }\n}\nexports.Texture = Texture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/Texture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/TextureCompatibility.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/TextureCompatibility.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureCompatibility = void 0;\n;\nclass TextureCompatibility {\n    static supportFloatTexture(ctx) {\n        let res = {};\n        res.filterable = !!ctx.getGLExtension(\"OES_texture_float_linear\");\n        if (ctx.webglVersion === 2) {\n            res.renderable = !!ctx.getGLExtension(\"EXT_color_buffer_float\");\n            res.supported = true;\n        }\n        else {\n            res.renderable = !!ctx.getGLExtension(\"WEBGL_color_buffer_float\");\n            res.supported = !!ctx.getGLExtension(\"OES_texture_float\");\n        }\n        return res;\n    }\n    // todo: integrate into texture\n    // we need float (best) or half float (ok) to do deferred\n    static supportHalfFloatTexture(ctx) {\n        let res = {};\n        res.filterable = !!ctx.getGLExtension(\"OES_texture_half_float_linear\");\n        if (ctx.webglVersion === 2) {\n            res.supported = true;\n            res.renderable = true;\n        }\n        else {\n            res.supported = !!ctx.getGLExtension(\"OES_texture_half_float\");\n            res.renderable = !!ctx.getGLExtension(\"EXT_color_buffer_half_float\");\n        }\n        return res;\n    }\n}\nexports.TextureCompatibility = TextureCompatibility;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/TextureCompatibility.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ColorAttachFramebuffer.ts":
/*!******************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ColorAttachFramebuffer.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorAttachFramebuffer = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst DepthTexture_1 = __webpack_require__(/*! ./DepthTexture */ \"./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts\");\n/**\n * A framebuffer class which explicitly allows arbitrary textures\n * to attach themselves to a binding point.\n *\n * (rather than invalidate resources each time we redraw, we can return a unique texture)\n */\nclass ColorAttachFramebuffer {\n    constructor(ctx) {\n        this.colorTexture = null;\n        this.depthTexture = new DepthTexture_1.DepthTexture(ctx, [8, 8]);\n        this.ctx = ctx;\n        let gl = ctx.getGLContext();\n        this.fb = gl.createFramebuffer();\n        // whatever, we're not going to do anything anyway\n        this.dims = [8, 8];\n    }\n    getColorTexture() {\n        return this.colorTexture;\n    }\n    getDepthTexture() {\n        return this.depthTexture;\n    }\n    setFramebufferSize(dim_a, dim_b) {\n        if (this.colorTexture !== null) {\n            this.colorTexture.setDimensions(dim_a, dim_b);\n            this.colorTexture.attachToFramebuffer(this.fb);\n        }\n        this.depthTexture.setDimensions(dim_a, dim_b);\n        this.depthTexture.attachToFramebuffer(this.fb);\n        this.dims = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n    }\n    /**\n     * Attachesw a color texture to this framebuffer.\n     * @param tex - the color texture we wish to attach.\n     */\n    setColorTexture(tex) {\n        tex.attachToFramebuffer(this.fb);\n        this.colorTexture = tex;\n        if (!gl_matrix_1.vec2.equals(this.dims, tex.dims)) {\n            this.depthTexture.setDimensions(tex.dims);\n            gl_matrix_1.vec2.copy(this.dims, tex.dims);\n        }\n        this.depthTexture.attachToFramebuffer(this.fb);\n    }\n    /**\n     * Removes the currently associated color texture from this FB and returns it.\n     * @returns color texture\n     */\n    unsetColorTexture() {\n        const ret = this.colorTexture;\n        // const gl = this.ctx.getGLContext();\n        this.colorTexture = null;\n        return ret;\n    }\n    bindFramebuffer(target) {\n        const gl = this.ctx.getGLContext();\n        let targ = target;\n        if (!targ) {\n            targ = gl.FRAMEBUFFER;\n        }\n        if (!this.colorTexture) {\n            console.warn(\"Attempted to draw to ColorAttachFramebuffer without a color texture. Ignoring...\");\n        }\n        else {\n            gl.bindFramebuffer(targ, this.fb);\n        }\n    }\n}\nexports.ColorAttachFramebuffer = ColorAttachFramebuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ColorAttachFramebuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts":
/*!************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorFramebuffer = void 0;\nconst ColorTexture_1 = __webpack_require__(/*! ./ColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts\");\nconst DepthTexture_1 = __webpack_require__(/*! ./DepthTexture */ \"./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts\");\n// need something like a color framebuffer, where i can just attach things to it ad hoc\nclass ColorFramebuffer {\n    /**\n     * Creates a new ColorFramebuffer.\n     * @param ctx - game context\n     * @param dims - framebuffer dimensions\n     * @param floatAttach - float attachment\n     */\n    constructor(ctx, dims, floatAttach) {\n        const floatsupport = !!(ctx.getGLExtension(\"WEBGL_color_buffer_float\"));\n        if (floatsupport && floatAttach) {\n            this.colorTexture = new ColorTexture_1.ColorTexture(ctx, dims, 4, ColorTexture_1.BitDepth.FLOAT);\n        }\n        else {\n            this.colorTexture = new ColorTexture_1.ColorTexture(ctx, dims);\n        }\n        this.depthTexture = new DepthTexture_1.DepthTexture(ctx, dims);\n        this.gl = ctx.getGLContext();\n        let gl = this.gl;\n        this.fb = gl.createFramebuffer();\n        this.setFramebufferSize(dims);\n    }\n    getColorTexture() {\n        return this.colorTexture;\n    }\n    getDepthTexture() {\n        return this.depthTexture;\n    }\n    setFramebufferSize(dim_a, dim_b) {\n        this.colorTexture.setDimensions(dim_a, dim_b);\n        this.depthTexture.setDimensions(dim_a, dim_b);\n        this.colorTexture.attachToFramebuffer(this.fb);\n        this.depthTexture.attachToFramebuffer(this.fb);\n        this.dims = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n    }\n    bindFramebuffer(target) {\n        let targ = target;\n        if (!targ) {\n            targ = this.gl.FRAMEBUFFER;\n        }\n        this.gl.bindFramebuffer(targ, this.fb);\n    }\n}\nexports.ColorFramebuffer = ColorFramebuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorTexture = exports.BitDepth = void 0;\nconst Texture_1 = __webpack_require__(/*! ../Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\nvar BitDepth;\n(function (BitDepth) {\n    BitDepth[BitDepth[\"BYTE\"] = 1] = \"BYTE\";\n    BitDepth[BitDepth[\"HALF_FLOAT\"] = 2] = \"HALF_FLOAT\";\n    BitDepth[BitDepth[\"FLOAT\"] = 3] = \"FLOAT\";\n})(BitDepth = exports.BitDepth || (exports.BitDepth = {}));\nclass ColorTexture extends Texture_1.Texture {\n    constructor(ctx, dims, channelCount, bitDepth) {\n        super();\n        this.ctx = ctx;\n        this.gl = ctx.getGLContext();\n        this.tex = null;\n        // not necc\n        const floatTexSupport = this.ctx.getGLExtension(\"OES_texture_float_linear\");\n        this.floatlinearsupport = !!floatTexSupport;\n        const floatRenderSupport = this.ctx.getGLExtension(\"EXT_color_buffer_float\");\n        this.floatrendersupport = !!floatRenderSupport;\n        // always supported in gl2\n        this.floatsupport = true;\n        const gl2 = (this.ctx.webglVersion === 2);\n        let depthWrap = (bitDepth ? bitDepth : BitDepth.BYTE);\n        if (!gl2) {\n            this.floatsupport = !!this.ctx.getGLExtension(\"OES_texture_float\");\n            this.halffloatsupport = !!this.ctx.getGLExtension(\"OES_texture_half_float\");\n            this.halffloatsupport && (this.halffloatsupport = !!this.ctx.getGLExtension(\"OES_texture_half_float_linear\"));\n        }\n        else {\n            this.halffloatsupport = !!floatRenderSupport;\n        }\n        if (depthWrap === BitDepth.FLOAT) {\n            if (!floatTexSupport) {\n                console.warn(\"This platform does not support filtering floating point textures.\");\n            }\n            // should client be held responsible for enforcing these?\n            // how about we downgrade ad hoc? shouldn't make a difference since to get it working we'll have to do that anyway.\n            if (!floatRenderSupport) {\n                console.warn(\"This platform does not support rendering to floating point textures.\");\n            }\n            if (!this.floatsupport) {\n                depthWrap = BitDepth.HALF_FLOAT;\n            }\n        }\n        if (depthWrap === BitDepth.HALF_FLOAT) {\n            if (!this.halffloatsupport) {\n                // downgrade to unsigned byte\n                depthWrap = BitDepth.BYTE;\n            }\n            else {\n                depthWrap = BitDepth.HALF_FLOAT;\n            }\n        }\n        if (gl2) {\n            this.setFormatAndInternalFormat_WEBGL2(this.gl, channelCount, depthWrap);\n        }\n        else {\n            this.setFormatAndInternalFormat_WEBGL(this.gl, channelCount, depthWrap);\n        }\n        this.bitdepth = (depthWrap === BitDepth.BYTE ? this.gl.UNSIGNED_BYTE : this.gl.FLOAT);\n        if (!gl2 && depthWrap === BitDepth.HALF_FLOAT) {\n            this.bitdepth = (this.ctx.getGLExtension(\"OES_texture_half_float\").HALF_FLOAT_OES);\n        }\n        console.log(depthWrap);\n        console.log(this.bitdepth);\n        console.log(this.internalformat);\n        console.log(this.format);\n        this.setDimensions(dims);\n        this.depth = depthWrap;\n    }\n    setFormatAndInternalFormat_WEBGL2(gl, channelCount, depth) {\n        const f = (depth === BitDepth.FLOAT);\n        const hf = (depth === BitDepth.HALF_FLOAT);\n        const channels = (channelCount === undefined ? 4 : Math.round(Math.max(Math.min(channelCount, 4), 1)));\n        switch (channels) {\n            case 1:\n                this.internalformat = (f ? gl.R32F : (hf ? gl.R16F : gl.R8));\n                this.format = gl.RED;\n                break;\n            case 2:\n                this.internalformat = (f ? gl.RG32F : (hf ? gl.RG16F : gl.RG8));\n                this.format = gl.RG;\n                break;\n            case 3:\n                this.internalformat = (f ? gl.RGB32F : (hf ? gl.RGB16F : gl.RGB8));\n                this.format = gl.RGB;\n                break;\n            case 4:\n                this.internalformat = (f ? gl.RGBA32F : (hf ? gl.RGBA16F : gl.RGBA8));\n                this.format = gl.RGBA;\n                break;\n        }\n    }\n    setFormatAndInternalFormat_WEBGL(gl, channelCount, depth) {\n        const channels = (channelCount === undefined ? 4 : Math.round(Math.max(Math.min(channelCount, 4), 1)));\n        switch (channels) {\n            case 1:\n                this.internalformat = gl.LUMINANCE;\n                break;\n            case 2:\n                this.internalformat = gl.LUMINANCE_ALPHA;\n                break;\n            case 3:\n                this.internalformat = gl.RGB;\n                break;\n            case 4:\n                this.internalformat = gl.RGBA;\n                break;\n        }\n        this.format = this.internalformat;\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.RGBA;\n    }\n    getBitDepth() {\n        return this.depth;\n    }\n    setSamplingMode(mode) {\n        return this.handleTextureSampling(this.tex, this.ctx, mode);\n    }\n    setWrapMode(modeS, modeT) {\n        const wrapS = modeS;\n        const wrapT = (modeT === undefined ? modeS : modeT);\n        this.handleWrapMode(this.tex, this.ctx, wrapS, wrapT);\n    }\n    bindToUniform(location, index) {\n        let gl = this.gl;\n        if (index > 31) {\n            console.error(\"OOB index\");\n            throw Error(\"OOB index\");\n        }\n        // ignore index completely >:)\n        this.ctx.getGL().bindTexture(this.tex, gl.TEXTURE_2D, location);\n    }\n    setDimensions(dim_a, dim_b) {\n        let dims = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n        this.createColorTextureWithDims(dims[0], dims[1]);\n        this.dims = dims;\n    }\n    attachToFramebuffer(framebuffer, target) {\n        let targ = target;\n        let gl = this.gl;\n        if (target === undefined) {\n            targ = gl.COLOR_ATTACHMENT0;\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        const wrap = this.ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(this.tex, gl.TEXTURE_2D));\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex, 0);\n    }\n    createColorTextureWithDims(x, y) {\n        let gl = this.gl;\n        if (this.tex === null) {\n            this.tex = gl.createTexture();\n        }\n        const wrap = this.ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(this.tex, gl.TEXTURE_2D));\n        gl.texImage2D(gl.TEXTURE_2D, 0, this.internalformat, x, y, 0, this.format, this.bitdepth, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        // gl_repeat incompatible with npot textures :(\n        // have to solve it in shader if necessary :)\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n}\nexports.ColorTexture = ColorTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/DepthStencilRenderbuffer.ts":
/*!********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/DepthStencilRenderbuffer.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DepthStencilRenderbuffer = void 0;\nclass DepthStencilRenderbuffer {\n    constructor(ctx, dims) {\n        this.gl = ctx.getGLContext();\n        this.rb = null;\n        this.setDimensions(dims);\n    }\n    setDimensions(dim_a, dim_b) {\n        let d = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n        this.createRenderBufferWithDims(d);\n        this._dims = d;\n    }\n    createRenderBufferWithDims(dims) {\n        let gl = this.gl;\n        if (this.rb === null) {\n            this.rb = gl.createRenderbuffer();\n        }\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this.rb);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, dims[0], dims[1]);\n    }\n    attachToFramebuffer(fb) {\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.rb);\n        this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.rb);\n    }\n    get dims() {\n        return this._dims;\n    }\n}\nexports.DepthStencilRenderbuffer = DepthStencilRenderbuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/DepthStencilRenderbuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DepthTexture = void 0;\nconst Texture_1 = __webpack_require__(/*! ../Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\nlet depthtex = undefined;\n// TODO: come up with a debug view that lets you view shadows :)\n// probably engine side\n// grab framebuffers after every render pass, just return the moment the desired fb is complete\nclass DepthTexture extends Texture_1.Texture {\n    constructor(ctx, dims) {\n        super();\n        this.ctx = ctx;\n        this.gl = ctx.getGLContext();\n        this.tex = null;\n        if (depthtex === undefined) {\n            depthtex = ctx.getGLExtension(\"WEBGL_depth_texture\");\n            if (depthtex !== null) {\n                console.log(\"ok :)\");\n            }\n        }\n        if (depthtex === null) {\n            let err = \"Depth texture not supported on this device.\";\n            console.error(err);\n            throw Error(err);\n        }\n        this.setDimensions(dims);\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.DEPTH;\n    }\n    setSamplingMode(mode) {\n        return this.handleTextureSampling(this.tex, this.ctx, mode);\n    }\n    bindToUniform(location, index) {\n        let gl = this.gl;\n        if (index > 31 || index < 0) {\n            console.error(\"OOB index\");\n            throw Error(\"OOB index\");\n        }\n        const wrap = this.ctx.getGL();\n        wrap.bindTexture(this.tex, gl.TEXTURE_2D, location);\n    }\n    setDimensions(dim_a, dim_b) {\n        // conform to power of two\n        let dims = this.validateTextureSize(dim_a, dim_b);\n        this.createDepthTextureWithDims(dims[0], dims[1]);\n        this.dims = dims;\n    }\n    /**\n     * Attaches this texture to the depth component of the provided framebuffer,\n     * or the provided target.\n     * @param target - the desired target. Defaults to gl.DEPTH_COMPONENT.\n     */\n    attachToFramebuffer(framebuffer, target) {\n        let targ = target;\n        let gl = this.gl;\n        if (!target) {\n            targ = gl.DEPTH_ATTACHMENT;\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, targ, gl.TEXTURE_2D, this.tex, 0);\n    }\n    validateTextureSize(dim_a, dim_b) {\n        let dims = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n        return dims;\n    }\n    createDepthTextureWithDims(x, y) {\n        const ver = this.ctx.webglVersion;\n        const gl = this.gl;\n        if (this.tex === null) {\n            this.tex = gl.createTexture();\n            console.log(\"texture created :)\");\n        }\n        let internalFormat, type;\n        if (ver === 2) {\n            const gl = this.ctx.getGLContext();\n            internalFormat = gl.DEPTH_COMPONENT32F;\n            type = gl.FLOAT;\n        }\n        else {\n            internalFormat = gl.DEPTH_COMPONENT;\n            type = gl.UNSIGNED_INT;\n        }\n        const wrap = this.ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(this.tex, gl.TEXTURE_2D));\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, x, y, 0, gl.DEPTH_COMPONENT, type, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n}\nexports.DepthTexture = DepthTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/FloatColorTexture.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/FloatColorTexture.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FloatColorTexture = void 0;\nconst ColorTexture_1 = __webpack_require__(/*! ./ColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts\");\nclass FloatColorTexture extends ColorTexture_1.ColorTexture {\n    constructor(ctx, dims) {\n        super(ctx, dims, 4, ColorTexture_1.BitDepth.FLOAT);\n    }\n}\nexports.FloatColorTexture = FloatColorTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/FloatColorTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts":
/*!***********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLAttributeImpl = void 0;\nconst gltfTypes_1 = __webpack_require__(/*! ../../loaders/internal/gltfTypes */ \"./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts\");\nconst DataType_1 = __webpack_require__(/*! nekogirl-valhalla/model/DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\n// TODO:\n// return float32arrays from everything\n// attributes are context dependent, but we can return them\n// we can already bind everything, but getting the component count wrong by chance will suck\n// so let's let the implementor figure it out :3\n// internal implementation of glattribute.\n// engine specifies fields before casting to proper attr format and returning\nclass GLAttributeImpl {\n    constructor(buffer, view, accessor) {\n        this.buffer = buffer;\n        switch (accessor.type) {\n            case gltfTypes_1.GLTFAccessorType.SCALAR:\n                this.comps = 1;\n                break;\n            case gltfTypes_1.GLTFAccessorType.VEC2:\n            case gltfTypes_1.GLTFAccessorType.VEC3:\n            case gltfTypes_1.GLTFAccessorType.VEC4:\n                this.comps = Number.parseInt(accessor.type.charAt(3), 10);\n                break;\n            default:\n                let err = `Unknown accessor type: ${accessor.type}`;\n                console.warn(err);\n                throw Error(err);\n        }\n        this.type = accessor.componentType;\n        this.offset = view.byteOffset + (accessor.byteOffset !== undefined ? accessor.byteOffset : 0);\n        this.stride = (view.byteStride !== undefined ? view.byteStride : 0);\n        switch (this.type) {\n            case DataType_1.DataType.BYTE:\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                this.componentByteSize = 1;\n                break;\n            case DataType_1.DataType.SHORT:\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                this.componentByteSize = 2;\n                break;\n            case DataType_1.DataType.FLOAT:\n                this.componentByteSize = 4;\n                break;\n            default:\n                let err = `Unknown component type: ${this.type}`;\n                console.warn(err);\n                throw Error(err);\n        }\n        switch (this.type) {\n            case DataType_1.DataType.BYTE:\n                this.accessFunc = this.buffer.getInt8.bind(buffer);\n                break;\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                this.accessFunc = this.buffer.getUint8.bind(buffer);\n                break;\n            case DataType_1.DataType.SHORT:\n                this.accessFunc = this.buffer.getInt16.bind(buffer);\n                break;\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                this.accessFunc = this.buffer.getUint16.bind(buffer);\n                break;\n            case DataType_1.DataType.FLOAT:\n                this.accessFunc = this.buffer.getFloat32.bind(buffer);\n                break;\n        }\n        this.count = accessor.count;\n        this.location = -1;\n    }\n    /**\n     * Returns a new GLAttributeImpl from attributes, rather than a BufferView and Accessor.\n     * @param buffer - the buffer in question\n     * @param components - number of components per element\n     * @param type - the type of data stored in each component\n     * @param offset - offset between components and start of buffer\n     * @param stride - stride between individual components.\n     */\n    static createFromValues(buffer, components, type, num, offset, stride) {\n        let typeString;\n        switch (components) {\n            case 1:\n                typeString = gltfTypes_1.GLTFAccessorType.SCALAR;\n                break;\n            case 2:\n                typeString = gltfTypes_1.GLTFAccessorType.VEC2;\n                break;\n            case 3:\n                typeString = gltfTypes_1.GLTFAccessorType.VEC3;\n                break;\n            case 4:\n                typeString = gltfTypes_1.GLTFAccessorType.VEC4;\n                break;\n        }\n        ;\n        let a = {\n            bufferView: -1,\n            componentType: type,\n            count: num,\n            min: [-1, -1, -1],\n            max: [1, 1, 1],\n            type: typeString\n        };\n        let b = {\n            buffer: -1,\n            byteLength: -1,\n            byteStride: stride,\n            byteOffset: offset\n        };\n        return new GLAttributeImpl(buffer, b, a);\n    }\n    pointToAttribute(location) {\n        this.location = location;\n        this.buffer.bindToVertexAttribute(location, this.comps, this.type, false, this.stride, this.offset);\n    }\n    setDefaultAttribute(location, ...data) {\n        if (data.length >= this.comps) {\n            this.buffer.setDefaultAttributeValue(location, this.comps, ...data);\n        }\n    }\n    setDefaultAttributeComps(location, comps, ...data) {\n        if (data.length >= comps) {\n            this.buffer.setDefaultAttributeValue(location, comps, ...data);\n        }\n    }\n    disableAttribute() {\n        if (this.location >= 0) {\n            this.buffer.disableVertexAttribute(this.location);\n            this.location = -1;\n        }\n    }\n    // probably just return number instead of float32array?\n    // mantissa is 23bit so we won't lose any info this way\n    // ... i probably wont use int attribs because they don't interp and i dont need them >:)\n    [Symbol.iterator]() {\n        let accessFunc = this.accessFunc;\n        const iterator = {\n            buffer: this.buffer,\n            readFunc: accessFunc,\n            offset: this.offset,\n            stride: this.stride,\n            elem: 0,\n            comps: this.comps,\n            componentSize: this.componentByteSize,\n            count: this.count,\n            next: function () {\n                if (this.elem >= this.count) {\n                    return { done: true, value: null };\n                }\n                let pos = (this.elem * (this.stride !== 0 ? this.stride : this.componentSize * this.comps)) + this.offset;\n                let res;\n                res = new Float32Array(this.comps);\n                for (let i = 0; i < this.comps; i++) {\n                    // read from wrapper function\n                    res[i] = this.readFunc(pos + i * this.componentSize, true);\n                }\n                this.elem++;\n                return { done: (this.elem >= this.count), value: res };\n            }\n        };\n        return iterator;\n    }\n    get(index) {\n        let pos = index * (this.stride !== 0 ? this.stride : this.componentByteSize * this.comps) + this.offset;\n        let res = new Float32Array(this.comps);\n        for (let i = 0; i < this.comps; i++) {\n            res[i] = this.accessFunc(pos, true);\n            pos += this.componentByteSize;\n        }\n        return res;\n    }\n}\nexports.GLAttributeImpl = GLAttributeImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLBuffer.ts":
/*!****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLBuffer.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DrawMode = exports.BufferTarget = void 0;\nvar BufferTarget;\n(function (BufferTarget) {\n    BufferTarget[BufferTarget[\"ARRAY_BUFFER\"] = 0] = \"ARRAY_BUFFER\";\n    BufferTarget[BufferTarget[\"ELEMENT_ARRAY_BUFFER\"] = 1] = \"ELEMENT_ARRAY_BUFFER\";\n    BufferTarget[BufferTarget[\"UNBOUND\"] = 2] = \"UNBOUND\";\n})(BufferTarget = exports.BufferTarget || (exports.BufferTarget = {}));\n;\nvar DrawMode;\n(function (DrawMode) {\n    DrawMode[DrawMode[\"TRIANGLES\"] = 0] = \"TRIANGLES\";\n    DrawMode[DrawMode[\"LINES\"] = 1] = \"LINES\";\n    DrawMode[DrawMode[\"POINTS\"] = 2] = \"POINTS\";\n})(DrawMode = exports.DrawMode || (exports.DrawMode = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLBuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLBufferImpl = void 0;\nconst ReadWriteBuffer_1 = __webpack_require__(/*! nekogirl-valhalla/buffer/ReadWriteBuffer */ \"./node_modules/nekogirl-valhalla/buffer/ReadWriteBuffer.js\");\nconst DataType_1 = __webpack_require__(/*! nekogirl-valhalla/model/DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\nconst GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ \"./hingler-party/client/ts/engine/gl/internal/GLBuffer.ts\");\nlet ext = undefined;\n/**\n * Represents a GL ArrayBuffer.\n * TODO: this is implementing two things in one place.\n *       create a different implementation specifically for element arrays?\n *\n *       I won't worry about it for now because this class is internal only\n */\nclass GLBufferImpl {\n    // TODO: assign a target on ctor? (array / element array / etc?)\n    // we'd have a confusing dependency :( but even then it like won't matter\n    // it's just a safeguard for me, so that we have a bit more info instead of just crashing out\n    constructor(ctx, buffer, dataMode) {\n        if (buffer instanceof ReadWriteBuffer_1.ReadWriteBuffer) {\n            this.buf = buffer;\n        }\n        else {\n            this.buf = new ReadWriteBuffer_1.ReadWriteBuffer(buffer);\n        }\n        this.ctx = ctx;\n        this.gl = ctx.getGLContext();\n        const gl = this.gl;\n        this.glBuf = gl.createBuffer();\n        this.target = GLBuffer_1.BufferTarget.UNBOUND;\n        this.version = this.buf.versionnum - 1;\n        this.glBufferSize = -1;\n        if (dataMode === undefined) {\n            this.dataMode = gl.STATIC_DRAW;\n        }\n        else {\n            this.dataMode = dataMode;\n        }\n        if (!ext && ctx.webglVersion < 2) {\n            ext = ctx.getGLExtension(\"ANGLE_instanced_arrays\");\n        }\n    }\n    bindAndPopulate(target) {\n        let gl = this.gl;\n        let targ;\n        switch (target) {\n            case GLBuffer_1.BufferTarget.ARRAY_BUFFER:\n                targ = gl.ARRAY_BUFFER;\n                break;\n            case GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER:\n                targ = gl.ELEMENT_ARRAY_BUFFER;\n                break;\n        }\n        const wrap = this.ctx.getGL();\n        wrap.bindBuffer(targ, this.glBuf);\n        const buf = this.buf.arrayBuffer();\n        if (this.version !== this.buf.versionnum && this.glBufferSize < buf.byteLength) {\n            gl.bufferData(targ, buf, this.dataMode);\n            this.glBufferSize = buf.byteLength;\n        }\n        else if (this.version !== this.buf.versionnum) {\n            gl.bufferSubData(targ, 0, buf);\n        }\n        this.version = this.buf.versionnum;\n    }\n    bindToVertexAttribute(location, components, type, normalize, stride, offset) {\n        if (this.target === GLBuffer_1.BufferTarget.UNBOUND) {\n            this.target = GLBuffer_1.BufferTarget.ARRAY_BUFFER;\n        }\n        else if (this.target !== GLBuffer_1.BufferTarget.ARRAY_BUFFER) {\n            let err = `WebGL buffers cannot be multi-purpose!`;\n            console.warn(err);\n            throw Error(err);\n        }\n        this.bindAndPopulate(GLBuffer_1.BufferTarget.ARRAY_BUFFER);\n        this.gl.vertexAttribPointer(location, components, type, normalize, stride, offset);\n        this.gl.enableVertexAttribArray(location);\n    }\n    // bind attribute instanced\n    // same thing as bindattribute but we want to add an additional step\n    // where we specify the divisor in ext\n    bindToInstancedVertexAttribute(location, components, type, normalize, stride, offset, divisor) {\n        if (location < 0) {\n            // print stack trace to identify erroneous func call in firefox\n            console.error(\"LOCATION < 0\");\n        }\n        if (divisor === undefined) {\n            divisor = 1;\n        }\n        if (this.target === GLBuffer_1.BufferTarget.UNBOUND) {\n            this.target = GLBuffer_1.BufferTarget.ARRAY_BUFFER;\n        }\n        else if (this.target !== GLBuffer_1.BufferTarget.ARRAY_BUFFER) {\n            let err = `WebGL buffers cannot be multi-purpose!`;\n            console.warn(err);\n            throw Error(err);\n        }\n        this.bindAndPopulate(GLBuffer_1.BufferTarget.ARRAY_BUFFER);\n        this.gl.enableVertexAttribArray(location);\n        this.gl.vertexAttribPointer(location, components, type, normalize, stride, offset);\n        this.glVertexAttribDivisor(location, divisor);\n    }\n    setDefaultAttributeValue(location, components, ...data) {\n        switch (components) {\n            case 1:\n                this.gl.vertexAttrib1fv(location, data);\n                break;\n            case 2:\n                this.gl.vertexAttrib2fv(location, data);\n                break;\n            case 3:\n                this.gl.vertexAttrib3fv(location, data);\n                break;\n            case 4:\n                this.gl.vertexAttrib4fv(location, data);\n                break;\n        }\n    }\n    glVertexAttribDivisor(loc, div) {\n        if (this.ctx.webglVersion === 2) {\n            const gl = this.ctx.getGLContext();\n            gl.vertexAttribDivisor(loc, div);\n        }\n        else {\n            ext.vertexAttribDivisorANGLE(loc, div);\n        }\n    }\n    glDrawElementsInstanced(mode, count, dataType, offset, primCount) {\n        if (this.ctx.webglVersion === 2) {\n            const gl = this.ctx.getGLContext();\n            gl.drawElementsInstanced(mode, count, dataType, offset, primCount);\n        }\n        else {\n            ext.drawElementsInstancedANGLE(mode, count, dataType, offset, primCount);\n        }\n    }\n    disableInstancedVertexAttribute(location) {\n        this.gl.disableVertexAttribArray(location);\n        this.glVertexAttribDivisor(location, 0);\n    }\n    disableVertexAttribute(location) {\n        this.gl.disableVertexAttribArray(location);\n    }\n    handleBindingPoints(mode, dataType) {\n        let gl = this.gl;\n        let glMode;\n        if (mode === undefined) {\n            glMode = gl.TRIANGLES;\n        }\n        else {\n            switch (mode) {\n                case GLBuffer_1.DrawMode.TRIANGLES:\n                    glMode = gl.TRIANGLES;\n                    break;\n                case GLBuffer_1.DrawMode.LINES:\n                    glMode = gl.LINES;\n                    break;\n                case GLBuffer_1.DrawMode.POINTS:\n                    glMode = gl.POINTS;\n                    break;\n            }\n        }\n        let type;\n        switch (dataType) {\n            case DataType_1.DataType.BYTE:\n                type = gl.BYTE;\n                break;\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                type = gl.UNSIGNED_BYTE;\n                break;\n            case DataType_1.DataType.SHORT:\n                type = gl.SHORT;\n                break;\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                type = gl.UNSIGNED_SHORT;\n                break;\n            case DataType_1.DataType.INT:\n                type = gl.INT;\n                break;\n            case DataType_1.DataType.UNSIGNED_INT:\n                type = gl.UNSIGNED_INT;\n                break;\n            default:\n                let err = `Unhandled data type: ${dataType}`;\n                console.error(err);\n                throw Error(err);\n        }\n        return [glMode, type];\n    }\n    drawElements(offset, count, dataType, mode) {\n        if (this.target === GLBuffer_1.BufferTarget.UNBOUND) {\n            this.target = GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER;\n        }\n        else if (this.target !== GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER) {\n            let err = `WebGL buffers cannot be multi-purpose!`;\n            console.warn(err);\n            throw Error(err);\n        }\n        this.bindAndPopulate(GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER);\n        let gl = this.gl;\n        let [glMode, type] = this.handleBindingPoints(mode, dataType);\n        gl.drawElements(glMode, count, type, offset);\n    }\n    drawElementsInstanced(mode, count, type, offset, primCount) {\n        if (this.target === GLBuffer_1.BufferTarget.UNBOUND) {\n            this.target = GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER;\n        }\n        else if (this.target !== GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER) {\n            let err = `WebGL buffers cannot be multi-purpose!`;\n            console.warn(err);\n            throw Error(err);\n        }\n        this.bindAndPopulate(GLBuffer_1.BufferTarget.ELEMENT_ARRAY_BUFFER);\n        let [glMode, dataType] = this.handleBindingPoints(mode, type);\n        this.glDrawElementsInstanced(glMode, count, dataType, offset, primCount);\n    }\n    getInt8(offset) {\n        return this.buf.getInt8(offset);\n    }\n    getUint8(offset) {\n        return this.buf.getUint8(offset);\n    }\n    getInt16(offset, littleEndian) {\n        return this.buf.getInt16(offset, littleEndian);\n    }\n    getUint16(offset, littleEndian) {\n        return this.buf.getUint16(offset, littleEndian);\n    }\n    getInt32(offset, littleEndian) {\n        return this.buf.getInt32(offset, littleEndian);\n    }\n    getUint32(offset, littleEndian) {\n        return this.buf.getUint32(offset, littleEndian);\n    }\n    getFloat32(offset, littleEndian) {\n        return this.buf.getFloat32(offset, littleEndian);\n    }\n    getFloat32Array(offset, num) {\n        return this.buf.getFloat32Array(offset, num);\n    }\n    setInt8(offset, value) {\n        this.buf.setInt8(offset, value);\n    }\n    setUint8(offset, value) {\n        this.buf.setUint8(offset, value);\n    }\n    setInt16(offset, value, littleEndian) {\n        this.buf.setInt16(offset, value, littleEndian);\n    }\n    setUint16(offset, value, littleEndian) {\n        this.buf.setUint16(offset, value, littleEndian);\n    }\n    setInt32(offset, value, littleEndian) {\n        this.buf.setInt32(offset, value, littleEndian);\n    }\n    setUint32(offset, value, littleEndian) {\n        this.buf.setUint32(offset, value, littleEndian);\n    }\n    setFloat32(offset, value, littleEndian) {\n        this.buf.setFloat32(offset, value, littleEndian);\n    }\n    setFloatArray(offset, arr, littleEndian) {\n        this.buf.setFloatArray(offset, arr, littleEndian);\n    }\n    getRegionAsUint16Array(offset, length) {\n        return this.buf.getRegionAsUint16Array(offset, length);\n    }\n    getRegionAsFloat32Array(offset, length) {\n        return this.buf.getRegionAsFloat32Array(offset, length);\n    }\n    size() {\n        return this.buf.size();\n    }\n    arrayBuffer() {\n        return this.buf.arrayBuffer();\n    }\n    copy() {\n        return new GLBufferImpl(this.ctx, this.buf.arrayBuffer(), this.dataMode);\n    }\n}\nexports.GLBufferImpl = GLBufferImpl;\n// NOTE: Our GLBuffer should handle all commands pertaining to GL state. No other model-related\n// class should have any idea that the GL state machine exists, and should work through this buffer exclusively!\n// TODO: Work on making that consistent. Eliminate dependencies.\n// Then write a stub which we can use elsewhere (factor out into interface and impl)\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLIndexImpl.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLIndexImpl.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLIndexImpl = void 0;\nconst DataType_1 = __webpack_require__(/*! nekogirl-valhalla/model/DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\nconst gltfTypes_1 = __webpack_require__(/*! ../../loaders/internal/gltfTypes */ \"./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts\");\nconst GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ \"./hingler-party/client/ts/engine/gl/internal/GLBuffer.ts\");\nclass IndexIterator {\n    constructor(accessFunc, indexWidth, count, offset) {\n        this.accessFunc = accessFunc;\n        this.indexWidth = indexWidth;\n        this.offset = offset;\n        this.count = count;\n        this.index = 0;\n    }\n    next() {\n        if (this.index >= this.count) {\n            return { done: true, value: null };\n        }\n        let ind = this.accessFunc(this.offset, true);\n        this.offset += this.indexWidth;\n        this.index++;\n        return {\n            done: (this.count === this.index),\n            value: ind\n        };\n    }\n}\nclass GLIndexImpl {\n    constructor(buffer, accessor, view) {\n        this.buffer = buffer;\n        this.type = accessor.componentType;\n        if (accessor.type !== \"SCALAR\") {\n            console.warn(\"access type mismatch. ignoring :)\");\n        }\n        this.offset = (accessor.byteOffset !== undefined ? accessor.byteOffset : 0) + (view.byteOffset !== undefined ? view.byteOffset : 0);\n        this.count = accessor.count;\n        // TODO: these are reused, come up with a way to abstract them a bit better\n        this.byteSize = GLIndexImpl.getByteSizeFromDataType(this.type);\n        switch (this.type) {\n            case DataType_1.DataType.BYTE:\n                this.accessFunc = this.buffer.getInt8.bind(buffer);\n                break;\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                this.accessFunc = this.buffer.getUint8.bind(buffer);\n                break;\n            case DataType_1.DataType.SHORT:\n                this.accessFunc = this.buffer.getInt16.bind(buffer);\n                break;\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                this.accessFunc = this.buffer.getUint16.bind(buffer);\n                break;\n            case DataType_1.DataType.UNSIGNED_INT:\n                this.accessFunc = this.buffer.getInt32.bind(buffer);\n                break;\n            case DataType_1.DataType.FLOAT:\n                this.accessFunc = this.buffer.getFloat32.bind(buffer);\n                break;\n        }\n    }\n    static createFromValues(buffer, type, count, offset) {\n        const acc = {\n            bufferView: -1,\n            componentType: type,\n            count: count,\n            type: gltfTypes_1.GLTFAccessorType.SCALAR\n        };\n        const view = {\n            buffer: -1,\n            byteLength: this.getByteSizeFromDataType(type) * count,\n            byteOffset: offset\n        };\n        return new GLIndexImpl(buffer, acc, view);\n    }\n    static getByteSizeFromDataType(type) {\n        switch (type) {\n            case DataType_1.DataType.BYTE:\n            case DataType_1.DataType.UNSIGNED_BYTE:\n                return 1;\n            case DataType_1.DataType.SHORT:\n            case DataType_1.DataType.UNSIGNED_SHORT:\n                return 2;\n            case DataType_1.DataType.FLOAT:\n            case DataType_1.DataType.UNSIGNED_INT:\n                return 4;\n            default:\n                let err = `Unknown component type: ${type}`;\n                console.warn(err);\n                throw Error(err);\n        }\n    }\n    getIndex(offset) {\n        let byteOffset = this.offset + (this.byteSize * offset);\n        return this.accessFunc(byteOffset, true);\n    }\n    [Symbol.iterator]() {\n        return new IndexIterator(this.accessFunc, this.byteSize, this.count, this.offset);\n    }\n    draw() {\n        this.buffer.drawElements(this.offset, this.count, this.type, GLBuffer_1.DrawMode.TRIANGLES);\n    }\n    drawInstanced(count) {\n        this.buffer.drawElementsInstanced(GLBuffer_1.DrawMode.TRIANGLES, this.count, this.type, this.offset, count);\n    }\n}\nexports.GLIndexImpl = GLIndexImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLIndexImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts":
/*!*********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLProgramWrap = void 0;\n/**\n * Wrapper for WebGL Programs which attempts to expedite costly procedures\n */\nclass GLProgramWrap {\n    constructor(gl, prog) {\n        this.gl = gl;\n        this.prog = prog;\n        this.uniformCache = new Map();\n    }\n    getUniformLocation(name) {\n        if (this.uniformCache.has(name)) {\n            return this.uniformCache.get(name);\n        }\n        else {\n            let loc = this.gl.getUniformLocation(this.prog, name);\n            if (loc !== null) {\n                this.uniformCache.set(name, loc);\n            }\n            return loc;\n        }\n    }\n}\nexports.GLProgramWrap = GLProgramWrap;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/GLTFTexture.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/GLTFTexture.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFTexture = void 0;\nconst Texture_1 = __webpack_require__(/*! ../Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\nclass GLTFTexture extends Texture_1.Texture {\n    constructor(ctx, buf, sampler, mime) {\n        super();\n        this.gl = ctx.getGLContext();\n        this.ctx = ctx;\n        // https://gist.github.com/candycode/f18ae1767b2b0aba568e\n        let urlCreator = window.URL || window.webkitURL;\n        let url = urlCreator.createObjectURL(new Blob([buf], { type: mime }));\n        this.img = new Image();\n        this.img.src = url;\n        this.sampler = sampler;\n        this.tex = null;\n        this.img.addEventListener(\"load\", this.loadTexture.bind(this));\n    }\n    get dims() {\n        return this.dims_;\n    }\n    setSamplingMode(mode) {\n        return this.handleTextureSampling(this.tex, this.ctx, mode);\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.RGBA;\n    }\n    bindToUniform(location, index) {\n        let gl = this.gl;\n        if (index > 31 || index < 0) {\n            let err = \"Index OOB on GLTF Texture!\";\n            console.error(err);\n        }\n        if (this.tex !== null) {\n            const wrap = this.ctx.getGL();\n            wrap.bindTexture(this.tex, gl.TEXTURE_2D, location);\n        }\n    }\n    loadTexture() {\n        [this.dims_, this.tex] = Texture_1.Texture.createTextureFromImage(this.ctx, this.img, this.sampler);\n    }\n}\nexports.GLTFTexture = GLTFTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/GLTFTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/HDRTexture.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/HDRTexture.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HDRTexture = void 0;\nconst Task_1 = __webpack_require__(/*! ../../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst Texture_1 = __webpack_require__(/*! ../Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\n// todo: come up with a better system for managing gl extensions\n// might be a global that our engine pulls\n// then we can look them up on the fly instead of storing them all over the place ;(\nclass HDRTexture extends Texture_1.Texture {\n    constructor(ctx, path) {\n        super();\n        this.tex = null;\n        this.ctx = ctx;\n        const gl = this.ctx.getGLContext();\n        if (this.ctx.webglVersion === 2) {\n            this.internalFormat = gl.RGB16F;\n        }\n        else {\n            this.internalFormat = gl.RGB;\n        }\n        this.uintTexture = !(ctx.getGLExtension(\"OES_texture_float\") !== null && ctx.getGLExtension(\"OES_texture_float_linear\") !== null);\n        this.loadTask = new Task_1.Task();\n        this.ctx.getFileLoader().open(path)\n            .then(HDRTexture.loadHDRImageFromFile)\n            .then(this.finalizeImageTexture.bind(this))\n            .then(() => this.loadTask.resolve());\n        // load file from file loader\n        // write a method to parse its contents\n    }\n    get dims() {\n        return [this.dims_[0], this.dims_[1]];\n    }\n    waitUntilUploaded() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadTask.getFuture().wait();\n        });\n    }\n    setSamplingMode(mode) {\n        return this.handleTextureSampling(this.tex, this.ctx, mode);\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.RGB;\n    }\n    bindToUniform(location, index) {\n        const gl = this.ctx.getGLContext();\n        if (index > 31 || index < 0) {\n            console.error(\"OOB index\");\n            throw Error(\"OOB index\");\n        }\n        // todo: calling shader draw before texture is loaded!?\n        if (this.tex !== null) {\n            const wrap = this.ctx.getGL();\n            wrap.bindTexture(this.tex, gl.TEXTURE_2D, location);\n        }\n        else {\n            console.log(\"oops\");\n        }\n    }\n    finalizeImageTexture(res) {\n        // if float textures arent supported, we need to convert res back to a float\n        if (this.uintTexture) {\n            console.warn(\"Platform does not support floating point textures. Converting to uint...\");\n            // this does nothing right now im just going to ignore it while i try to get this working\n        }\n        let data = res[0];\n        let dims = res[1];\n        const gl = this.ctx.getGLContext();\n        this.dims_ = dims;\n        this.tex = gl.createTexture();\n        const wrap = this.ctx.getGL();\n        gl.activeTexture(wrap.bindTexture(this.tex, gl.TEXTURE_2D));\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, dims[1], dims[0], 0, gl.RGB, gl.FLOAT, data);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    static loadHDRImageFromFile(img) {\n        const buf = new Uint8Array(img.asArrayBuffer());\n        // lol\n        const magic = String.fromCharCode(...buf.slice(0, 11));\n        if (magic !== \"#?RADIANCE\\n\") {\n            // bad magic\n            console.error(\"Magic number inside file not consistent with HDR\");\n            return null;\n        }\n        // index of the first char in our header\n        let lineStart = 11;\n        let cur = lineStart;\n        let char;\n        let format = null;\n        while (true) {\n            char = buf[cur];\n            cur++;\n            if (char === 0x0A) { // hex \\n\n                const line = String.fromCharCode(...buf.slice(lineStart, cur - 1));\n                console.log(line);\n                if (line.indexOf(\"FORMAT=\") !== -1) {\n                    format = line.substring(7);\n                    if (format !== \"32-bit_rle_rgbe\") {\n                        // cant handle this encoding type yet\n                        console.error(\"Unable to handle format \" + format);\n                        return null;\n                    }\n                }\n                // cur advanced past first newline -- on first char of next line\n                lineStart = cur;\n                if (buf[cur] === 0x0A) {\n                    break;\n                }\n            }\n        }\n        // cur is at the second newline after header -- advance to get to res\n        lineStart = ++cur;\n        if (format === null) {\n            // format was never defined\n            console.error(\"Internal file format unknown!\");\n            return null;\n        }\n        // read up to the next newline to consume resolution info\n        while (true) {\n            char = buf[cur];\n            cur++;\n            if (char === 0x0A) {\n                break;\n            }\n        }\n        // cur is now past the newline, on our data\n        const resRegex = /([\\+\\-][XY] [0-9]+) ([\\+\\-][XY] [0-9]+)/;\n        const resString = String.fromCharCode(...buf.slice(lineStart, cur - 1));\n        const m = resString.match(resRegex);\n        console.log(m);\n        if (m === null) {\n            console.error(\"Could not interpret resolution string: \" + resString);\n            return null;\n        }\n        console.log(m);\n        const highDim = Number.parseInt(m[1].split(\" \")[1], 10);\n        const lowDim = Number.parseInt(m[2].split(\" \")[1], 10);\n        console.log(highDim);\n        console.log(lowDim);\n        // allocate * 4 and then return a slice?\n        // doing the function call so many times is costly, this avoids code reuse in exchange for a larger mem footprint\n        // we only do this a couple times and then dealloc the result once its on the gpu so its fine\n        const int = new Uint8Array(highDim * lowDim * 4);\n        const res = new Float32Array(highDim * lowDim * 3);\n        // read (highdim) lines of length (lowdim)\n        for (let i = 0; i < highDim; i++) {\n            cur = HDRTexture.readLine(buf, cur, int, (i * lowDim * 4), lowDim);\n        }\n        // int contains pixel data\n        let inputOffset = 0;\n        let outputOffset = 0;\n        let r, g, b, e;\n        for (let i = 0; i < highDim; i++) {\n            for (let j = 0; j < lowDim; j++) {\n                r = int[inputOffset++];\n                g = int[inputOffset++];\n                b = int[inputOffset++];\n                e = int[inputOffset++];\n                const pow = Math.pow(2, (e - 128));\n                res[outputOffset++] = ((r + 0.5) / 256) * pow;\n                res[outputOffset++] = ((g + 0.5) / 256) * pow;\n                res[outputOffset++] = ((b + 0.5) / 256) * pow;\n            }\n        }\n        return [res, [highDim, lowDim]];\n    }\n    /**\n     * Reads a single scanline of our file.\n     * @param file - Uint8Array containing our file.\n     * @param offset - file offset which we will start reading at.\n     * @param out - float32array we will output the result to.\n     * @param outOffset - location where we should start writing to `out`.\n     * @param len - length of the scanline remaining to read\n     */\n    static readLine(file, offset, out, outOffset, len) {\n        // new lines: (2, 2, [16 bit lowdim]), code byte, then pixel data for (codebyte & 127) bytes -- colors are separated, and each is ARLE encoded on its own\n        // old lines: 1,1,1,(repeat) - duplicate last pixel\n        // raw: neither\n        let r, g, b, e;\n        let fileOffset = offset;\n        let arrayOffset = outOffset;\n        r = file[fileOffset++];\n        g = file[fileOffset++];\n        b = file[fileOffset++];\n        e = file[fileOffset++];\n        // r = 2 and g = 2 is new format, scan len is capped at 128 so check the blue channel as well\n        if (r !== 2 || g !== 2 || (b & 128)) {\n            fileOffset -= 4;\n            // could be repeat char i didnt check lol\n            return HDRTexture.readLineOldRLE(file, fileOffset, out, arrayOffset, len);\n        }\n        const lenCheck = (b << 8 | e);\n        if (lenCheck !== len) {\n            const err = \"Invalid scanline length on HDR file!\";\n            console.error(err);\n            throw Error(err);\n        }\n        return HDRTexture.readLineARLE(file, fileOffset, out, arrayOffset, len);\n    }\n    /**\n     * Reads a line with adaptive RLE encoding.\n     * @param file - Uint8Array containing our file.\n     * @param offset - file offset which we will start reading at.\n     * @param out - float32array we will output the result to.\n     * @param outOffset - location where we should start writing to `out`.\n     * @param len - length of the scanline remaining to read\n     *\n     * @returns the file offset after performing operations.\n     */\n    static readLineARLE(file, offset, out, outOffset, len) {\n        let code;\n        let fileOffset = offset;\n        let arrayOffset = outOffset;\n        let repeatCount;\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < len;) {\n                // read code byte\n                code = file[fileOffset++];\n                // if > 128, repeat the next value over the col channel\n                if (code > 128) {\n                    repeatCount = code & 127;\n                    while (repeatCount--) {\n                        out[arrayOffset + (4 * j++) + i] = file[fileOffset];\n                    }\n                    fileOffset++;\n                }\n                else {\n                    while (code--) {\n                        out[arrayOffset + (4 * j++) + i] = file[fileOffset++];\n                    }\n                }\n            }\n        }\n        return fileOffset;\n    }\n    /**\n     * Reads a line with old RLE encoding.\n     * @param file - Uint8Array containing our file.\n     * @param offset - file offset which we will start reading at.\n     * @param out - float32array we will output the result to.\n     * @param outOffset - location where we should start writing to `out`.\n     * @param len - length of the scanline remaining to read\n     *\n     * @returns the file offset after performing operations\n     */\n    static readLineOldRLE(file, offset, out, outOffset, len) {\n        let r, g, b, e;\n        let fileOffset = offset;\n        let arrayOffset = outOffset;\n        let repeatOffset = 0;\n        for (let i = 0; i < len; i++) {\n            r = file[fileOffset++];\n            g = file[fileOffset++];\n            b = file[fileOffset++];\n            e = file[fileOffset++];\n            if (r === 1 && g === 1 && b === 1) {\n                const arrayAnchor = arrayOffset - 4;\n                e <<= repeatOffset;\n                while (e--) {\n                    for (let j = 0; j < 4; j++) {\n                        out[arrayOffset++] = out[arrayAnchor + j];\n                    }\n                }\n                // if consecutive repeat pixels, higher order bits (duplicating prev still works :3)\n                repeatOffset += 8;\n            }\n            else {\n                out[arrayOffset++] = r;\n                out[arrayOffset++] = g;\n                out[arrayOffset++] = b;\n                out[arrayOffset++] = e;\n                repeatOffset = 0;\n            }\n        }\n        return fileOffset;\n    }\n}\nexports.HDRTexture = HDRTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/HDRTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ImageTexture.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ImageTexture.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageTexture = void 0;\nconst Task_1 = __webpack_require__(/*! ../../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst Texture_1 = __webpack_require__(/*! ../Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\nclass ImageTexture extends Texture_1.Texture {\n    // todo: create an interface for readonly textures\n    // share w other components where necessaryt :D\n    constructor(ctx, href) {\n        super();\n        this.gl = ctx.getGLContext();\n        this.ctx = ctx;\n        this.img = new Image();\n        this.img.src = href;\n        this.tex = null;\n        this.loadTask = new Task_1.Task();\n        this.img.addEventListener(\"load\", this.loadTexture.bind(this));\n    }\n    get dims() {\n        return this.dims_;\n    }\n    // TODO: redundant code\n    bindToUniform(location, index) {\n        let gl = this.gl;\n        if (index > 31 || index < 0) {\n            let err = \"Index OOB on GLTF Texture!\";\n            console.error(err);\n        }\n        if (this.tex !== null) {\n            const wrap = this.ctx.getGL();\n            wrap.bindTexture(this.tex, gl.TEXTURE_2D, location);\n        }\n    }\n    setSamplingMode(mode) {\n        return this.handleTextureSampling(this.tex, this.ctx, mode);\n    }\n    getTextureFormat() {\n        return Texture_1.TextureFormat.RGBA;\n    }\n    waitUntilLoaded() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadTask.getFuture().wait();\n        });\n    }\n    loadTexture() {\n        [this.dims_, this.tex] = Texture_1.Texture.createTextureFromImage(this.ctx, this.img);\n        this.loadTask.resolve();\n    }\n}\nexports.ImageTexture = ImageTexture;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ImageTexture.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ShaderFileParser.ts":
/*!************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ShaderFileParser.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderFileParser = void 0;\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst eol = /\\r?\\n/;\nlet ver = undefined;\nconst DEFAULT_INCLUDES = [\n    \"env\",\n    \"attenuation\",\n    \"compatibility\",\n    \"spotlight\",\n    \"procedural\",\n    \"parallax\",\n    \"ambient\",\n    \"constants\",\n    \"gradient\",\n    \"opensimplex\",\n    \"perlin\",\n    \"pbr\",\n    \"radialblur\",\n    \"random\",\n    \"version\"\n];\nconst SPOTLIGHT_INCLUDES = [\n    \"object\",\n    \"light\",\n    \"pbr\"\n];\nconst PROCEDURAL_INCLUDES = [\n    \"brick\",\n    \"bump\",\n    \"noise\",\n    \"voronoi\"\n];\n// fix dupe includes on env :(\nclass ShaderFileParser {\n    constructor(ctx) {\n        this.loader = ctx.getFileLoader();\n        this.ctx = ctx;\n        if (ver === undefined) {\n            ver = (this.ctx.webglVersion === 2 ? \"#version 300 es\" : \"#version 100\");\n        }\n    }\n    setProgramFlags(flags) {\n        this.programFlags = Array.from(flags);\n    }\n    parseShaderFile(path, isVertexShader) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.pathRecord = new Set();\n            return yield this.parseShaderFile_(path, !!isVertexShader);\n        });\n    }\n    parseShaderFile_(path, isVertexShader) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.pathRecord.has(path)) {\n                console.debug(path + \" already included in program. Ignoring import...\");\n                return \"\";\n            }\n            this.pathRecord.add(path);\n            const includeHeader = \"#include \";\n            const includeExtract = /\\s*#include\\s+<(([^\\/]+)(\\/(.*))?)>.*/;\n            let contents = yield this.loader.open(path);\n            let folder = path.substring(0, Math.max(path.lastIndexOf(\"/\"), path.lastIndexOf(\"\\\\\")) + 1);\n            let lines = contents.asString().split(eol);\n            let output = [];\n            for (let line of lines) {\n                if (line.indexOf(includeHeader) !== -1) {\n                    console.debug(\"Encountered new include: \" + line);\n                    let match = includeExtract.exec(line);\n                    if (match !== null) {\n                        const name = match[2];\n                        // note: look for trailing slashes\n                        if (DEFAULT_INCLUDES.includes(name)) {\n                            switch (name) {\n                                case \"env\":\n                                    output.push(this.ctx.getShaderEnv());\n                                    output.push(`#define VERT ${isVertexShader ? 1 : 0}`);\n                                    output.push(...(this.programFlags.map(val => `#define ${val}\\n`)));\n                                    break;\n                                case \"attenuation\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/spotlight/attenuation.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"compatibility\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/compatibility.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"spotlight\":\n                                    console.log(match);\n                                    if (match[4] !== undefined) {\n                                        if (SPOTLIGHT_INCLUDES.indexOf(match[4]) !== -1) {\n                                            output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(`engine/glsl/includes/spotlight/spotlight_libs/spotlight_${match[4]}.inc.glsl`), isVertexShader));\n                                        }\n                                        else {\n                                            // if not a valid include, treat it as a normal path\n                                            const relativePath = folder + match[1];\n                                            output.push(yield this.parseShaderFile_(relativePath, isVertexShader));\n                                        }\n                                    }\n                                    else {\n                                        output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/spotlight/spotlight.inc.glsl\"), isVertexShader));\n                                    }\n                                    break;\n                                case \"procedural\":\n                                    if (match[4] !== undefined) {\n                                        if (PROCEDURAL_INCLUDES.indexOf(match[4]) !== -1) {\n                                            output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(`engine/glsl/includes/procedural/${match[4]}.inc.glsl`), isVertexShader));\n                                        }\n                                        else {\n                                            // if not a valid include, treat it as a normal path\n                                            const relativePath = folder + match[1];\n                                            output.push(yield this.parseShaderFile_(relativePath, isVertexShader));\n                                        }\n                                    }\n                                    else {\n                                        console.warn(\"cannot interpret plain procedural import -- ignoring...\");\n                                    }\n                                    break;\n                                case \"ambient\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/ambient.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"constants\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/constants.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"gradient\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/gradient.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"opensimplex\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/opensimplex.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"parallax\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/parallax.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"perlin\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/perlin.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"pbr\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/pbr.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"radialblur\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/radialblur.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"random\":\n                                    output.push(yield this.parseShaderFile_((0, getEnginePath_1.getEnginePath)(\"engine/glsl/includes/random.inc.glsl\"), isVertexShader));\n                                    break;\n                                case \"version\":\n                                    output.push(ver + \"\\n\");\n                                    break;\n                            }\n                            continue;\n                        }\n                        else {\n                            let relativePath = folder + match[1];\n                            output.push(yield this.parseShaderFile_(relativePath, isVertexShader));\n                        }\n                        continue;\n                    }\n                }\n                output.push(line);\n            }\n            return output.join(\"\\n\");\n        });\n    }\n}\nexports.ShaderFileParser = ShaderFileParser;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ShaderFileParser.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/ShadowFramebuffer.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/ShadowFramebuffer.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShadowFramebuffer = void 0;\nconst ColorTexture_1 = __webpack_require__(/*! ./ColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts\");\nconst DepthTexture_1 = __webpack_require__(/*! ./DepthTexture */ \"./hingler-party/client/ts/engine/gl/internal/DepthTexture.ts\");\nclass ShadowFramebuffer {\n    constructor(ctx, dims) {\n        this.colorTexture = new ColorTexture_1.ColorTexture(ctx, dims);\n        this.shadowTexture = new DepthTexture_1.DepthTexture(ctx, dims);\n        this.gl = ctx.getGLContext();\n        let gl = this.gl;\n        this.framebuffer = gl.createFramebuffer();\n        this.setFramebufferSize(dims);\n        this.colorTexture.attachToFramebuffer(this.framebuffer);\n        this.shadowTexture.attachToFramebuffer(this.framebuffer);\n    }\n    get dims() {\n        return this.colorTexture.dims;\n    }\n    getColorTexture() {\n        return this.colorTexture;\n    }\n    getDepthTexture() {\n        return this.shadowTexture;\n    }\n    setFramebufferSize(dim_a, dim_b) {\n        this.colorTexture.setDimensions(dim_a, dim_b);\n        this.shadowTexture.setDimensions(dim_a, dim_b);\n        this.colorTexture.attachToFramebuffer(this.framebuffer);\n        this.shadowTexture.attachToFramebuffer(this.framebuffer);\n    }\n    bindFramebuffer(target) {\n        let targ = target;\n        if (!targ) {\n            targ = this.gl.FRAMEBUFFER;\n        }\n        this.gl.bindFramebuffer(targ, this.framebuffer);\n    }\n}\nexports.ShadowFramebuffer = ShadowFramebuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/ShadowFramebuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/SharedGPUTimer.ts":
/*!**********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/SharedGPUTimer.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// a shared timer implementation for gpu queries\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SharedGPUTimer = exports.DummyGPUTimer = exports.QueryManagerWebGL2 = exports.IntervalBlock = exports.EndBlock = exports.StartBlock = exports.BlockType = void 0;\n// ignore this for a bit -- i'll have to drop by again and fix it\nconst IDGenerator_1 = __webpack_require__(/*! nekogirl-valhalla/object/IDGenerator */ \"./node_modules/nekogirl-valhalla/object/IDGenerator.js\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../../internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst RingArray_1 = __webpack_require__(/*! nekogirl-valhalla/array/RingArray */ \"./node_modules/nekogirl-valhalla/array/RingArray.js\");\nlet objCount = 0;\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"INTERVAL\"] = 0] = \"INTERVAL\";\n    BlockType[BlockType[\"START\"] = 1] = \"START\";\n    BlockType[BlockType[\"END\"] = 2] = \"END\";\n})(BlockType = exports.BlockType || (exports.BlockType = {}));\n;\n;\nclass StartBlock {\n    constructor() {\n        // unique identifier for a given query\n        this.type = BlockType.START;\n    }\n}\nexports.StartBlock = StartBlock;\n;\nclass EndBlock {\n    constructor() {\n        // unique identifier for this query, shared with startblock\n        this.type = BlockType.END;\n    }\n}\nexports.EndBlock = EndBlock;\n;\nclass IntervalBlock {\n    constructor() {\n        // time units passed during this interval block\n        this.type = BlockType.INTERVAL;\n    }\n}\nexports.IntervalBlock = IntervalBlock;\n;\nclass QueryRecord {\n}\nclass QueryManagerWebGL2 {\n    // alternative: use a pool of timers!!!\n    constructor(gl, ext) {\n        this.gl = gl;\n        this.ext = ext;\n        this.query = null;\n        this.queryList = new Set();\n    }\n    flushQueries() {\n        const gl = this.gl;\n        const ext = this.ext;\n        const disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);\n        for (let query of this.queryList) {\n            const q = query.query;\n            if (disjoint) {\n                query.reject(\"Timer query was disjoint :(\");\n            }\n            const avail = gl.getQueryParameter(q, gl.QUERY_RESULT_AVAILABLE);\n            if (avail && !disjoint) {\n                const result = gl.getQueryParameter(q, gl.QUERY_RESULT);\n                query.resolve(result);\n            }\n            if (avail || disjoint) {\n                gl.deleteQuery(q);\n                this.queryList.delete(query);\n            }\n        }\n    }\n    startQuery() {\n        this.query = this.gl.createQuery();\n        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.query);\n    }\n    stopQuery() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n            const q = this.query;\n            this.query = null;\n            return new Promise((res, rej) => {\n                this.queryList.add({\n                    query: q,\n                    logDest: null,\n                    resolve: res,\n                    reject: rej\n                });\n            });\n        });\n    }\n}\nexports.QueryManagerWebGL2 = QueryManagerWebGL2;\n// placeholder if extension is not avail\nclass DummyGPUTimer {\n    startQuery() { return -1; }\n    stopQuery(_) { return Promise.resolve(0); }\n    stopQueryAndLog(_, __, ___) { }\n    invalidateAll() { }\n}\nexports.DummyGPUTimer = DummyGPUTimer;\n// webgl2 gpu timer\nclass SharedGPUTimer {\n    constructor(mgr) {\n        this.blockList = new RingArray_1.RingArray(4096);\n        this.gen = new IDGenerator_1.IDGenerator();\n        this.word = mgr;\n        this.test = false;\n    }\n    getLastBlockAsIntervalBlock() {\n        const res = this.blockList.get(this.blockList.length - 1);\n        if (res.type !== BlockType.INTERVAL) {\n            throw Error(\"END OF LIST IS NOT INTERVAL\");\n        }\n        return res;\n    }\n    // stops the last query, and places its eventual result in the last interval block\n    // starts a new GPU query.\n    // returns an identifier which can be used to stop the query later.\n    startQuery() {\n        if (this.test === true) {\n            const prom = this.word.stopQuery();\n            this.getLastBlockAsIntervalBlock().time = prom;\n        }\n        this.word.startQuery();\n        this.test = true;\n        const id = this.gen.getNewID();\n        const start = new StartBlock();\n        start.id = this.gen.getNewID();\n        start.queryId = id;\n        start.resolved = false;\n        this.blockList.push(start);\n        const interval = new IntervalBlock();\n        interval.time = null;\n        this.blockList.push(interval);\n        return id;\n    }\n    stopQuery(queryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.test === false) {\n                return Promise.reject(\"No query was available\");\n            }\n            let marker = -1;\n            for (let i = 0; i < this.blockList.length; i++) {\n                const block = this.blockList.get(i);\n                if (block.type === BlockType.START) {\n                    const start = block;\n                    if (start.queryId === queryId) {\n                        marker = i;\n                    }\n                }\n            }\n            if (marker === -1) {\n                // end query flag does not exist\n                return Promise.reject(\"Uh oh!!! Your ID is bad >:)\");\n            }\n            const prom = this.word.stopQuery();\n            this.getLastBlockAsIntervalBlock().time = prom;\n            this.word.startQuery();\n            const endBlock = new EndBlock();\n            endBlock.queryId = queryId;\n            endBlock.resolved = false;\n            this.blockList.push(endBlock);\n            const intervals = [];\n            for (let i = marker; i < this.blockList.length; i++) {\n                const block = this.blockList.get(i);\n                if (block.type === BlockType.INTERVAL) {\n                    intervals.push(block.time);\n                }\n            }\n            const sumPromise = Promise.all(intervals).then((times) => {\n                let res = 0;\n                for (const time of times) {\n                    res += time;\n                }\n                return res;\n            }).then(sum => {\n                endBlock.resolved = true;\n                return sum;\n            });\n            // push the interval to the end of the blocklist\n            this.blockList.push(endBlock);\n            const interval = new IntervalBlock();\n            interval.time = null;\n            this.blockList.push(interval);\n            return sumPromise;\n        });\n    }\n    stopQueryAndLog(id, name, category) {\n        this.stopQuery(id)\n            .then(res => (0, performanceanalytics_1.logRender)(name, res / 1e6, category));\n    }\n    invalidateAll() {\n        // reset state -- called at the end of a frame\n        if (this.test === true) {\n            const _ = this.word.stopQuery();\n        }\n        this.test = false;\n        this.blockList.clear();\n        // flush out our queue\n        this.word.flushQueries();\n    }\n}\nexports.SharedGPUTimer = SharedGPUTimer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/SharedGPUTimer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/SkyboxFramebuffer.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/SkyboxFramebuffer.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SkyboxFramebuffer = void 0;\nconst ColorCubemap_1 = __webpack_require__(/*! ../ColorCubemap */ \"./hingler-party/client/ts/engine/gl/ColorCubemap.ts\");\nconst DepthStencilRenderbuffer_1 = __webpack_require__(/*! ./DepthStencilRenderbuffer */ \"./hingler-party/client/ts/engine/gl/internal/DepthStencilRenderbuffer.ts\");\n// special framebuffer which is intended for rendering skyboxes\n// supports reattaching different color buffers\n// can't use default framebuffer because we don't meet the spec\n// this one is new!\nclass SkyboxFramebuffer {\n    constructor(ctx, dim) {\n        this.mipLevel = -1;\n        this.dim_ = dim;\n        this.cubemap = new ColorCubemap_1.ColorCubemap(ctx, dim);\n        this.cubemap.generateMipmaps();\n        const gl = ctx.getGLContext();\n        this.fb = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);\n        this.rb = new DepthStencilRenderbuffer_1.DepthStencilRenderbuffer(ctx, [dim, dim]);\n        this.rb.attachToFramebuffer(this.fb);\n        this.ctx = ctx;\n        this.setMipLevel(0);\n        this.fboMipmap = !!(this.ctx.getGLExtension(\"OES_fbo_render_mipmap\"));\n    }\n    get dim() {\n        return Math.round(Math.pow(0.5, this.mipLevel) * this.dim_);\n    }\n    /**\n     * Sets the mip level of this framebuffer\n     * @param mip - the desired mip level\n     * @returns true if the fb mipmap level could be set -- false otherwise.\n     */\n    setMipLevel(mip) {\n        const newMip = Math.round(mip);\n        if (!this.fboMipmap && newMip !== 0) {\n            // ensure we can load our mip0\n            return false;\n        }\n        if (newMip !== this.mipLevel) {\n            this.mipLevel = newMip;\n            const mipRes = Math.round(this.dim);\n            this.rb.setDimensions(mipRes, mipRes);\n            this.rb.attachToFramebuffer(this.fb);\n        }\n        return true;\n    }\n    // bind framebuffer: specify face\n    bindFramebuffer(face, target) {\n        const gl = this.ctx.getGLContext();\n        let targ = target;\n        if (!targ) {\n            targ = gl.FRAMEBUFFER;\n        }\n        const d = face - gl.TEXTURE_CUBE_MAP_POSITIVE_X;\n        if (d > 5 || d < 0) {\n            console.warn(\"Invalid cube face specified to SkyboxFramebuffer: \" + face.toString(16));\n            return;\n        }\n        gl.bindFramebuffer(targ, this.fb);\n        this.cubemap.attachToFramebuffer(face, this.fb, this.mipLevel, gl.COLOR_ATTACHMENT0);\n    }\n    // get cubemap: return cubemap obj\n    getCubemap() {\n        return this.cubemap;\n    }\n}\nexports.SkyboxFramebuffer = SkyboxFramebuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/SkyboxFramebuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/glcontext/GLContext.ts":
/*!***************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/glcontext/GLContext.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLContext = void 0;\nconst LRUMap_1 = __webpack_require__(/*! nekogirl-valhalla/map/LRUMap */ \"./node_modules/nekogirl-valhalla/map/LRUMap.js\");\nconst UniformMap_1 = __webpack_require__(/*! ./UniformMap */ \"./hingler-party/client/ts/engine/gl/internal/glcontext/UniformMap.ts\");\nclass GLContext {\n    constructor(gl) {\n        this.gl = gl;\n        this.activeUniformList = null;\n        this.programMap = new Map();\n        this.bufferMap = new Map();\n        const texmax = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        this.textureMap = new LRUMap_1.LRUMap(texmax);\n        this.texCapacity = texmax;\n    }\n    useProgram(prog) {\n        if (prog !== this.boundProgram) {\n            if (!this.programMap.has(prog)) {\n                this.programMap.set(prog, new UniformMap_1.UniformMap(this.gl));\n            }\n            this.activeUniformList = this.programMap.get(prog);\n            this.gl.useProgram(prog);\n            this.boundProgram = prog;\n        }\n    }\n    uniform1i(loc, val) {\n        if (this.activeUniformList === null) {\n            throw Error(\"No program currently bound!\");\n        }\n        this.activeUniformList.uniform1i(loc, val);\n    }\n    uniform1f(loc, val) {\n        if (this.activeUniformList === null) {\n            throw Error(\"No program currently bound!\");\n        }\n        this.activeUniformList.uniform1f(loc, val);\n    }\n    bindTexture(tex, target, loc) {\n        let res = -1;\n        if (this.textureMap.has(tex)) {\n            res = this.textureMap.get(tex);\n            this.textureMap.insert(tex, res);\n        }\n        else {\n            if (this.textureMap.size < this.texCapacity) {\n                const index = this.textureMap.size;\n                this.textureMap.insert(tex, index);\n                res = index;\n            }\n            else {\n                const swap = this.textureMap.evict();\n                this.textureMap.insert(tex, swap);\n                res = swap;\n            }\n            // should we always activate this texture?\n            this.gl.activeTexture(this.gl.TEXTURE0 + res);\n            this.gl.bindTexture(target, tex);\n        }\n        if (loc !== undefined) {\n            this.activeUniformList.uniform1i(loc, res);\n        }\n        return this.gl.TEXTURE0 + res;\n    }\n    bindBuffer(targ, buf) {\n        if (this.bufferMap.has(targ)) {\n            if (this.bufferMap.get(targ) === buf) {\n                return;\n            }\n        }\n        const gl = this.gl;\n        gl.bindBuffer(targ, buf);\n        this.bufferMap.set(targ, buf);\n    }\n    clearTexBinds() {\n        // lazy soln\n        this.textureMap = new LRUMap_1.LRUMap(this.texCapacity);\n    }\n}\nexports.GLContext = GLContext;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/glcontext/GLContext.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/internal/glcontext/UniformMap.ts":
/*!****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/internal/glcontext/UniformMap.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UniformMap = void 0;\nclass UniformMap {\n    constructor(gl) {\n        this.gl = gl;\n        this.bindings1D = new Map();\n    }\n    uniform1f(location, val) {\n        if (this.bindings1D.get(location) !== val) {\n            this.bindings1D.set(location, val);\n            this.gl.uniform1f(location, val);\n        }\n    }\n    uniform1i(location, val) {\n        if (this.bindings1D.get(location) !== val) {\n            this.bindings1D.set(location, val);\n            this.gl.uniform1i(location, val);\n        }\n    }\n}\nexports.UniformMap = UniformMap;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/internal/glcontext/UniformMap.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/struct/AmbientLightStruct.ts":
/*!************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/struct/AmbientLightStruct.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmbientLightStruct = void 0;\nclass AmbientLightStruct {\n    constructor(ctx, light) {\n        this.color = light.color;\n        this.intensity = light.intensity;\n        this.ctx = ctx;\n    }\n    bindToUniformByName(prog, name) {\n        const colLoc = prog.getUniformLocation(name + \".color\");\n        const intLoc = prog.getUniformLocation(name + \".intensity\");\n        let gl = this.ctx.getGLContext();\n        gl.uniform4fv(colLoc, this.color);\n        gl.uniform1f(intLoc, this.intensity);\n    }\n}\nexports.AmbientLightStruct = AmbientLightStruct;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/struct/AmbientLightStruct.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/struct/AttenuationStruct.ts":
/*!***********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/struct/AttenuationStruct.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttenuationStruct = void 0;\nclass AttenuationStruct {\n    constructor(ctx, light) {\n        this.atten_const = light.atten_const;\n        this.atten_linear = light.atten_linear;\n        this.atten_quad = light.atten_quad;\n        this.gl = ctx.getGLContext();\n    }\n    bindToUniformByName(prog, name) {\n        let gl = this.gl;\n        const constLoc = prog.getUniformLocation(name + \".atten_const\");\n        const linearLoc = prog.getUniformLocation(name + \".atten_linear\");\n        const quadLoc = prog.getUniformLocation(name + \".atten_quad\");\n        gl.uniform1f(constLoc, this.atten_const);\n        gl.uniform1f(linearLoc, this.atten_linear);\n        gl.uniform1f(quadLoc, this.atten_quad);\n    }\n}\nexports.AttenuationStruct = AttenuationStruct;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/struct/AttenuationStruct.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/gl/struct/SpotLightStruct.ts":
/*!*********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/gl/struct/SpotLightStruct.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpotLightStruct = void 0;\nconst AttenuationStruct_1 = __webpack_require__(/*! ./AttenuationStruct */ \"./hingler-party/client/ts/engine/gl/struct/AttenuationStruct.ts\");\nclass SpotLightStruct {\n    constructor(ctx, light) {\n        this.position = light.getGlobalPosition();\n        this.dir = light.getDirectionVector();\n        // convert back to rads for shader :)\n        this.fov = light.fov * (Math.PI / 180);\n        this.falloffRadius = light.falloffRadius;\n        this.intensity = light.intensity;\n        // TODO: no idea why this happens :(\n        this.color = new Float32Array(light.color);\n        if (light.getShadowState()) {\n            this.shadowTex = light.getShadowTexture();\n        }\n        else {\n            this.shadowTex = null;\n        }\n        this.lightTransform = light.getLightMatrix();\n        this.attenuation = new AttenuationStruct_1.AttenuationStruct(ctx, light);\n        this.shadowSize = light.getShadowDims();\n        this.index = 0;\n        this.gl = ctx.getGLContext();\n    }\n    hasShadow() {\n        return (this.shadowTex !== null);\n    }\n    // this is fine :)\n    // users will set it from render ctx\n    // i think thats fine though\n    setShadowTextureIndex(index) {\n        if (index < 0 || index > 31) {\n            const err = \"Texture index out of bounds!\";\n            console.error(err);\n            throw Error(err);\n        }\n        this.index = index;\n    }\n    getShadowTextureIndex() {\n        return this.index;\n    }\n    bindToUniformByName(prog, name, enableShadow) {\n        let gl = this.gl;\n        // resolves if undefined\n        let useShadow = (!!enableShadow) && (this.shadowTex !== null);\n        const posLoc = prog.getUniformLocation(name + \".position\");\n        const dirLoc = prog.getUniformLocation(name + \".dir\");\n        const fovLoc = prog.getUniformLocation(name + \".fov\");\n        const falloffLoc = prog.getUniformLocation(name + \".falloffRadius\");\n        const intensityLoc = prog.getUniformLocation(name + \".intensity\");\n        const colorLoc = prog.getUniformLocation(name + \".color\");\n        const transformLoc = prog.getUniformLocation(name + \".lightTransform\");\n        const shadowDimLoc = prog.getUniformLocation(name + \".shadowSize\");\n        let texLoc;\n        if (useShadow) {\n            texLoc = prog.getUniformLocation(\"texture_\" + name);\n        }\n        this.attenuation.bindToUniformByName(prog, name + \".a\");\n        gl.uniform3fv(posLoc, this.position);\n        gl.uniform3fv(dirLoc, this.dir);\n        gl.uniform1f(fovLoc, this.fov);\n        gl.uniform1f(falloffLoc, this.falloffRadius);\n        gl.uniform1f(intensityLoc, this.intensity);\n        gl.uniform4fv(colorLoc, this.color);\n        if (useShadow) {\n            this.shadowTex.bindToUniform(texLoc, this.index);\n        }\n        gl.uniformMatrix4fv(transformLoc, false, this.lightTransform);\n        gl.uniform2fv(shadowDimLoc, this.shadowSize);\n    }\n}\nexports.SpotLightStruct = SpotLightStruct;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/gl/struct/SpotLightStruct.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/internal/DebugDisplay.ts":
/*!*****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/internal/DebugDisplay.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DebugDisplay = void 0;\nconst PingQueue_1 = __webpack_require__(/*! ../../../../ts/util/PingQueue */ \"./hingler-party/ts/util/PingQueue.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ./getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ./performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nfunction text(s) {\n    return document.createTextNode(s);\n}\nfunction span() {\n    return document.createElement(\"span\");\n}\nfunction br() {\n    return document.createElement(\"br\");\n}\nconst MAX_NUMBER_BARS = 24;\nconst DEBUG_QUEUE_SIZE = 128;\n/**\n * Little class for displaying debug information on the screen :D\n */\nclass DebugDisplay {\n    constructor(ctx) {\n        this.ctx = ctx;\n        ctx.getFileLoader().open((0, getEnginePath_1.getEnginePath)(\"engine/css/debug.css\"))\n            .then(res => {\n            const style = document.createElement(\"style\");\n            style.textContent = res.asString();\n            document.head.appendChild(style);\n        });\n        this.frame = document.createElement(\"div\");\n        this.frame.classList.add(\"debug-frame\");\n        this.updateTimeSpan = span();\n        this.shadowTimeSpan = span();\n        this.finalTimeSpan = span();\n        this.postTimeSpan = span();\n        this.totalTimeSpan = span();\n        this.updateQueue = new PingQueue_1.PingQueue(DEBUG_QUEUE_SIZE);\n        this.shadowQueue = new PingQueue_1.PingQueue(DEBUG_QUEUE_SIZE);\n        this.finalQueue = new PingQueue_1.PingQueue(DEBUG_QUEUE_SIZE);\n        this.postQueue = new PingQueue_1.PingQueue(DEBUG_QUEUE_SIZE);\n        this.totalQueue = new PingQueue_1.PingQueue(DEBUG_QUEUE_SIZE);\n        const general = document.createElement(\"p\");\n        general.appendChild(text(\"UPDATE: \"));\n        general.appendChild(this.updateTimeSpan);\n        general.appendChild(br());\n        general.appendChild(text(\"RENDER: \"));\n        general.appendChild(this.totalTimeSpan);\n        const renderdata = document.createElement(\"p\");\n        renderdata.appendChild(text(\"RENDER INFO: \"));\n        renderdata.appendChild(br());\n        renderdata.appendChild(text(\"SHADOW: \"));\n        renderdata.appendChild(this.shadowTimeSpan);\n        renderdata.appendChild(br());\n        renderdata.appendChild(text(\"FINAL: \"));\n        renderdata.appendChild(this.finalTimeSpan);\n        renderdata.appendChild(br());\n        renderdata.appendChild(text(\"POST: \"));\n        renderdata.appendChild(this.postTimeSpan);\n        this.frame.appendChild(general);\n        this.frame.appendChild(renderdata);\n        const renderBars = document.createElement(\"div\");\n        renderBars.classList.add(\"renderbars\");\n        this.frame.appendChild(renderBars);\n        document.body.appendChild(this.frame);\n        this.renderbarsContainer = renderBars;\n        this.renderBars = [];\n        this.updateTime = 0;\n        this.shadowTime = 0;\n        this.finalTime = 0;\n        this.postTime = 0;\n        this.totalTime = 0;\n    }\n    generateRenderBar() {\n        const bar = document.createElement(\"div\");\n        bar.classList.add(\"bar\");\n        return bar;\n    }\n    update() {\n        if (!this.ctx.debugger) {\n            if (!this.frame.classList.contains(\"hidden\")) {\n                this.frame.classList.add(\"hidden\");\n            }\n            return;\n        }\n        else if (this.frame.classList.contains(\"hidden\")) {\n            this.frame.classList.remove(\"hidden\");\n        }\n        const perf = (0, performanceanalytics_1.getRenderPerf)();\n        const len = Math.min(perf.length, MAX_NUMBER_BARS);\n        while (this.renderBars.length < len) {\n            const bar = this.generateRenderBar();\n            this.renderbarsContainer.appendChild(bar);\n            this.renderBars.push(bar);\n        }\n        let max = 0;\n        for (let val of perf) {\n            max = Math.max(val[1], max);\n        }\n        for (let i = 0; i < len; i++) {\n            const res = perf.get(i);\n            this.renderBars[i].style.width = (res[1] / max) * 100 + \"%\";\n            const name = res[0];\n            const ind = name.indexOf(\":\");\n            const type = name.substring(0, ind);\n            this.renderBars[i].classList.remove(performanceanalytics_1.RenderType.FINAL, performanceanalytics_1.RenderType.POST, performanceanalytics_1.RenderType.SHADOW, performanceanalytics_1.RenderType.UNCATEGORIZED);\n            this.renderBars[i].classList.add(type);\n            this.renderBars[i].textContent = `${res[0]} - ${res[1].toFixed(3)}MS`;\n            this.renderBars[i].classList.remove(\"hidden\");\n        }\n        for (let i = len; i < this.renderBars.length; i++) {\n            this.renderBars[i].classList.add(\"hidden\");\n        }\n        this.updateQueue.enqueue(this.updateTime);\n        this.shadowQueue.enqueue(this.shadowTime);\n        this.finalQueue.enqueue(this.finalTime);\n        this.postQueue.enqueue(this.postTime);\n        this.totalQueue.enqueue(this.totalTime);\n        this.updateTimeSpan.textContent = (`${this.updateQueue.getAverage().toFixed(3)}MS`);\n        this.shadowTimeSpan.textContent = (`${this.shadowQueue.getAverage().toFixed(3)}MS`);\n        this.finalTimeSpan.textContent = (`${this.finalQueue.getAverage().toFixed(3)}MS`);\n        this.postTimeSpan.textContent = (`${this.postQueue.getAverage().toFixed(3)}MS`);\n        this.totalTimeSpan.textContent = (`${this.totalQueue.getAverage().toFixed(3)}MS`);\n    }\n}\nexports.DebugDisplay = DebugDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/internal/DebugDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/internal/EngineContext.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/internal/EngineContext.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EngineContext = void 0;\nconst performance_1 = __webpack_require__(/*! ../../../../ts/performance */ \"./hingler-party/ts/performance.ts\");\nconst GameCamera_1 = __webpack_require__(/*! ../object/game/GameCamera */ \"./hingler-party/client/ts/engine/object/game/GameCamera.ts\");\nconst FileLoader_1 = __webpack_require__(/*! ../loaders/FileLoader */ \"./hingler-party/client/ts/engine/loaders/FileLoader.ts\");\nconst GLTFLoaderImpl_1 = __webpack_require__(/*! ../loaders/internal/GLTFLoaderImpl */ \"./hingler-party/client/ts/engine/loaders/internal/GLTFLoaderImpl.ts\");\nconst Renderer_1 = __webpack_require__(/*! ./Renderer */ \"./hingler-party/client/ts/engine/internal/Renderer.ts\");\nconst MobileCheck_1 = __webpack_require__(/*! ../../../../ts/util/MobileCheck */ \"./hingler-party/ts/util/MobileCheck.ts\");\nconst SceneSwapImpl_1 = __webpack_require__(/*! ../object/scene/internal/SceneSwapImpl */ \"./hingler-party/client/ts/engine/object/scene/internal/SceneSwapImpl.ts\");\nconst ShaderEnv_1 = __webpack_require__(/*! ../gl/ShaderEnv */ \"./hingler-party/client/ts/engine/gl/ShaderEnv.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ./performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst DebugDisplay_1 = __webpack_require__(/*! ./DebugDisplay */ \"./hingler-party/client/ts/engine/internal/DebugDisplay.ts\");\nconst SharedGPUTimer_1 = __webpack_require__(/*! ../gl/internal/SharedGPUTimer */ \"./hingler-party/client/ts/engine/gl/internal/SharedGPUTimer.ts\");\nconst GLContext_1 = __webpack_require__(/*! ../gl/internal/glcontext/GLContext */ \"./hingler-party/client/ts/engine/gl/internal/glcontext/GLContext.ts\");\n// short list from https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html\nconst WEBGL2_NATIVE_EXTENSIONS = [\n    \"WEBGL_depth_texture\",\n    \"OES_texture_float\",\n    \"OES_texture_half_float\",\n    \"OES_texture_half_float_linear\",\n    \"OES_vertex_array_object\",\n    \"OES_standard_derivatives\",\n    \"ANGLE_instanced_arrays\",\n    \"OES_element_index_uint\",\n    \"EXT_frag_depth\",\n    \"EXT_blend_minmax\",\n    \"EXT_shader_texture_lod\",\n    \"WEBGL_draw_buffers\",\n    \"OES_fbo_render_mipmap\"\n];\n/**\n * INTERNAL ONLY.\n */\nclass EngineContext {\n    // create a new constructor which allows this scene to borrow assets from\n    // the last ctx\n    constructor(init, scene, opts) {\n        this.lastDelta = 0;\n        this.lastTimePoint = performance_1.perf.now();\n        this.varMap = new Map();\n        this.debugger = false;\n        // copy over env???\n        // nah we'll standardize its initialization\n        this.swapContext = null;\n        this.swapObject = null;\n        this.passOffset = 0;\n        this.shaderCache = new ShaderEnv_1.ShaderEnv();\n        if (init instanceof EngineContext) {\n            this.glContext = init.glContext;\n            this.glWrap = init.glWrap;\n            this.canvas = init.canvas;\n            this.webglVersion = init.webglVersion;\n            this.extensionList = init.extensionList;\n            this.gpuTimer = init.gpuTimer;\n            this.loader = new FileLoader_1.FileLoader(this, opts ? opts.useServiceWorker : true);\n            this.debug = init.debug;\n        }\n        else {\n            this.canvas = init;\n            this.extensionList = new Map();\n            if (opts && opts.forceWebGL1) {\n                this.setupWebGL1(init);\n            }\n            else {\n                const gl2 = init.getContext(\"webgl2\");\n                if (gl2 && gl2 instanceof WebGL2RenderingContext) {\n                    this.glContext = gl2;\n                    this.webglVersion = 2;\n                    const timing = this.getGLExtension(\"EXT_disjoint_timer_query_webgl2\");\n                    if (timing !== null) {\n                        const mgr = new SharedGPUTimer_1.QueryManagerWebGL2(gl2, timing);\n                        this.gpuTimer = new SharedGPUTimer_1.SharedGPUTimer(mgr);\n                    }\n                    else {\n                        // necessary plugins are missing - use this instead\n                        this.gpuTimer = new SharedGPUTimer_1.DummyGPUTimer();\n                    }\n                }\n                else {\n                    this.setupWebGL1(init);\n                }\n                this.glWrap = new GLContext_1.GLContext(this.glContext);\n            }\n            console.log(`Using WebGL Version ${this.webglVersion}`);\n            this.loader = new FileLoader_1.FileLoader(this, opts ? opts.useServiceWorker : true);\n            this.debug = new DebugDisplay_1.DebugDisplay(this);\n        }\n        this.crappoTimer = new SharedGPUTimer_1.DummyGPUTimer();\n        this.gltfLoader = new GLTFLoaderImpl_1.GLTFLoaderImpl(this.loader, this);\n        this.updateScreenDims();\n        this.windowListener = this.updateScreenDims.bind(this);\n        // will this event listener stick around forever?\n        window.addEventListener(\"resize\", this.windowListener);\n        this.mobile = (0, MobileCheck_1.mobileCheck)();\n        // DEBUG LINE!!!\n        // this.glContext = this.getGLProxy(this.glContext);\n        let gl = this.glContext;\n        gl.clearColor(0, 0, 0, 1);\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n        gl.clearDepth(1.0);\n        this.scene = scene;\n        this.renderer = new Renderer_1.Renderer(this, this.scene);\n        if (!this.scene.isInitialized()) {\n            this.scene.begininit(this);\n        }\n        addEventListener(\"keydown\", (e) => {\n            if (e.code === \"PageUp\") {\n                this.passOffset--;\n            }\n            else if (e.code === \"PageDown\") {\n                this.passOffset++;\n            }\n            else if (e.code === \"Backquote\") {\n                this.debugger = !this.debugger;\n            }\n        });\n        this.setContextVar(\"SHADER_WEBGL_VERSION\", this.webglVersion, { shaderInteger: true });\n    }\n    getGLProxy(gl) {\n        gl = new Proxy(gl, {\n            get: function (target, prop, _) {\n                let res = target[prop];\n                if (typeof res === \"function\") {\n                    let func = res;\n                    return (...args) => {\n                        let res = func.apply(target, args);\n                        let err = target.getError();\n                        if (err !== target.NO_ERROR) {\n                            console.error(\"Err generated by last gl call to \" + prop.toString() + \": \" + err);\n                        }\n                        return res;\n                    };\n                }\n                else {\n                    return res;\n                }\n            }\n        });\n        return gl;\n    }\n    setupWebGL1(init) {\n        this.glContext = init.getContext(\"webgl\");\n        this.webglVersion = 1;\n    }\n    updateScreenDims() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        this.dims = [this.canvas.clientWidth, this.canvas.clientHeight];\n    }\n    getGPUTimer() {\n        if (this.debugger) {\n            return this.gpuTimer;\n        }\n        else {\n            return this.crappoTimer;\n        }\n    }\n    // TODO: add method to switch scenes.\n    /**\n     * @returns the current active scene.\n     */\n    getScene() {\n        return this.scene;\n    }\n    getDelta() {\n        return this.lastDelta;\n    }\n    updateDelta() {\n        let timept = performance_1.perf.now();\n        this.lastDelta = (timept - this.lastTimePoint) / 1000;\n        this.lastTimePoint = timept;\n    }\n    getFileLoader() {\n        return this.loader;\n    }\n    getGLTFLoader() {\n        return this.gltfLoader;\n    }\n    getGLExtension(name) {\n        if (this.extensionList.has(name)) {\n            const res = this.extensionList.get(name);\n            return res;\n        }\n        if (this.webglVersion === 2 && WEBGL2_NATIVE_EXTENSIONS.indexOf(name) !== -1) {\n            // native support -- return a placeholder\n            // TODO: bundle in something to indicate that the extension is native\n            return {};\n        }\n        const ext = this.glContext.getExtension(name);\n        if (ext !== null) {\n            this.extensionList.set(name, ext);\n            console.log(\"loaded extension \" + name);\n            console.log(ext);\n            return ext;\n        }\n        return null;\n    }\n    getGLContext() {\n        return this.glContext;\n    }\n    getGL() {\n        return this.glWrap;\n    }\n    getScreenDims() {\n        // testing: https://docs.cypress.io/api/commands/viewport#Syntax\n        // note: this is slow, cache once a frame instead\n        return this.dims;\n    }\n    loadNewScene(scene) {\n        // create a new context with this ctx and our passed scene as its initial arg\n        let newContext = new EngineContext(this, scene);\n        let swap = new SceneSwapImpl_1.SceneSwapImpl(newContext, scene);\n        this.swapContext = newContext;\n        this.swapObject = swap;\n        // note: we might want to borrow shit from another scene ig\n        return swap;\n    }\n    setContextVar(key, value, opts) {\n        const SHADER_VAR_PREFIX = \"SHADER_\";\n        const ind = key.indexOf(SHADER_VAR_PREFIX);\n        if (ind !== -1) {\n            this.shaderCache.setShaderVar(key.substring(ind + SHADER_VAR_PREFIX.length), value, (opts ? !!opts.shaderInteger : false));\n        }\n        this.varMap.set(key, value);\n    }\n    getContextVar(key) {\n        return this.varMap.get(key);\n    }\n    getShaderEnv() {\n        return this.shaderCache.getShaderEnv();\n    }\n    glSetup() {\n        let gl = this.glContext;\n        gl.clearColor(0, 0, 0, 1);\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n    }\n    // we should kickstart the engine, and then forget this object\n    deployContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // perform our gl setup here\n            this.glSetup();\n            yield this.step();\n            requestAnimationFrame(this.computeFrame.bind(this));\n        });\n    }\n    computeFrame() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.drawFrame();\n            // put swap code here\n            if (this.swapObject !== null && this.swapObject.canSwap()) {\n                // update delta before deploying, so we don't get a long frame time since init\n                this.swapContext.updateDelta();\n                requestAnimationFrame(this.swapContext.deployContext.bind(this.swapContext));\n            }\n            else {\n                yield this.step();\n                requestAnimationFrame(this.computeFrame.bind(this));\n            }\n        });\n    }\n    step() {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, performanceanalytics_1.clearPerf)();\n            this.updateDelta();\n            if (this.scene && this.scene.isInitialized()) {\n                const updateStart = performance_1.perf.now();\n                this.scene.getGameObjectRoot().updateChildren();\n                const updateEnd = performance_1.perf.now();\n                this.updateTime = updateEnd - updateStart;\n                yield this.renderer.renderScene();\n                this.debug.updateTime = this.updateTime;\n            }\n            this.gpuTimer.invalidateAll();\n            const renderTiming = this.renderer.getDebugTiming();\n            this.debug.shadowTime = renderTiming.shadowTime;\n            this.debug.finalTime = renderTiming.finalTime;\n            this.debug.postTime = renderTiming.postTime;\n            this.debug.totalTime = renderTiming.totalTime;\n            this.debug.update();\n        });\n    }\n    drawFrame() {\n        if (this.scene && this.scene.isInitialized()) {\n            let passCount = this.renderer.getPassCount();\n            if (passCount > 0) {\n                let disp = this.renderer.getPass(Math.abs(this.renderer.getPassCount() - 1));\n                this.glContext.bindFramebuffer(this.glContext.FRAMEBUFFER, null);\n                this.glContext.clear(this.glContext.COLOR_BUFFER_BIT | this.glContext.DEPTH_BUFFER_BIT);\n                disp.drawTexture();\n            }\n        }\n    }\n    findActiveCamera(root) {\n        for (let child of root.getChildren()) {\n            if (child instanceof GameCamera_1.GameCamera) {\n                if (child.isActive()) {\n                    return child;\n                }\n                else {\n                    this.findActiveCamera(child);\n                }\n            }\n        }\n    }\n}\nexports.EngineContext = EngineContext;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/internal/EngineContext.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/internal/Renderer.ts":
/*!*************************************************************!*\
  !*** ./hingler-party/client/ts/engine/internal/Renderer.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Renderer = exports.RenderPerformanceInfo = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst PingQueue_1 = __webpack_require__(/*! ../../../../ts/util/PingQueue */ \"./hingler-party/ts/util/PingQueue.ts\");\nconst ComponentType_1 = __webpack_require__(/*! ../component/ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nconst ColorAttachFramebuffer_1 = __webpack_require__(/*! ../gl/internal/ColorAttachFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/ColorAttachFramebuffer.ts\");\nconst ColorFramebuffer_1 = __webpack_require__(/*! ../gl/internal/ColorFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/ColorFramebuffer.ts\");\nconst ColorTexture_1 = __webpack_require__(/*! ../gl/internal/ColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts\");\nconst AmbientLightStruct_1 = __webpack_require__(/*! ../gl/struct/AmbientLightStruct */ \"./hingler-party/client/ts/engine/gl/struct/AmbientLightStruct.ts\");\nconst SpotLightStruct_1 = __webpack_require__(/*! ../gl/struct/SpotLightStruct */ \"./hingler-party/client/ts/engine/gl/struct/SpotLightStruct.ts\");\nconst TextureCompatibility_1 = __webpack_require__(/*! ../gl/TextureCompatibility */ \"./hingler-party/client/ts/engine/gl/TextureCompatibility.ts\");\nconst ColorDisplay_1 = __webpack_require__(/*! ../material/ColorDisplay */ \"./hingler-party/client/ts/engine/material/ColorDisplay.ts\");\nconst PositionMaterial_1 = __webpack_require__(/*! ../material/deferred/PositionMaterial */ \"./hingler-party/client/ts/engine/material/deferred/PositionMaterial.ts\");\nconst ShadowDisplay_1 = __webpack_require__(/*! ../material/ShadowDisplay */ \"./hingler-party/client/ts/engine/material/ShadowDisplay.ts\");\nconst SkyboxMaterial_1 = __webpack_require__(/*! ../material/SkyboxMaterial */ \"./hingler-party/client/ts/engine/material/SkyboxMaterial.ts\");\nconst GameCamera_1 = __webpack_require__(/*! ../object/game/GameCamera */ \"./hingler-party/client/ts/engine/object/game/GameCamera.ts\");\nconst AmbientLightObject_1 = __webpack_require__(/*! ../object/game/light/AmbientLightObject */ \"./hingler-party/client/ts/engine/object/game/light/AmbientLightObject.ts\");\nconst SpotLightObject_1 = __webpack_require__(/*! ../object/game/light/SpotLightObject */ \"./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts\");\nconst SkyboxObject_1 = __webpack_require__(/*! ../object/game/SkyboxObject */ \"./hingler-party/client/ts/engine/object/game/SkyboxObject.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ./performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nclass RenderPerformanceInfo {\n}\nexports.RenderPerformanceInfo = RenderPerformanceInfo;\nclass SpotLightRenderContext {\n    constructor(light) {\n        this.info = light.getLightMatrixAsCameraInfo();\n        this.fb = light._getShadowFramebuffer();\n    }\n    getRenderPass() {\n        return RenderContext_1.RenderPass.SHADOW;\n    }\n    getActiveCameraInfo() {\n        return this.info;\n    }\n    // something else?\n    getSpotLightInfo() {\n        return [];\n    }\n    getAmbientLightInfo() {\n        return [];\n    }\n    getSkybox() {\n        return [];\n    }\n    getFramebuffer() {\n        return this.fb;\n    }\n    getPositionData() {\n        return null;\n    }\n}\n/**\n * Handles rendering of our component hierarchy.\n */\nclass Renderer {\n    constructor(ctx, scene) {\n        this.ctx = ctx;\n        this.gl = ctx.getGLContext();\n        this.scene = scene;\n        this.primaryFB = new ColorFramebuffer_1.ColorFramebuffer(ctx, ctx.getScreenDims());\n        this.swapFB = new ColorFramebuffer_1.ColorFramebuffer(ctx, ctx.getScreenDims());\n        this.skyboxMat = new SkyboxMaterial_1.SkyboxMaterial(ctx);\n        this.cube = SkyboxObject_1.SkyboxObject.createSkyboxCube(this.ctx);\n        this.shadowRenderTime = 0;\n        this.finalRenderTime = 0;\n        this.postRenderTime = 0;\n        this.totalRenderTime = 0;\n        this.shadowQueue = new PingQueue_1.PingQueue(64);\n        this.finalQueue = new PingQueue_1.PingQueue(64);\n        this.postQueue = new PingQueue_1.PingQueue(64);\n        this.totalQueue = new PingQueue_1.PingQueue(64);\n        this.positionFB = new ColorAttachFramebuffer_1.ColorAttachFramebuffer(ctx);\n        this.positionTex = this.getPositionTex();\n        this.positionFB.setColorTexture(this.positionTex);\n        this.positionMaterial = new PositionMaterial_1.PositionMaterial(ctx);\n        this.queryExt = null;\n        if (ctx.webglVersion === 2) {\n            this.queryExt = ctx.getGLExtension(\"EXT_disjoint_timer_query_webgl2\");\n            console.log(this.queryExt);\n        }\n    }\n    getPositionTex() {\n        const floatSupport = TextureCompatibility_1.TextureCompatibility.supportFloatTexture(this.ctx);\n        if (floatSupport.supported && floatSupport.filterable && floatSupport.renderable) {\n            return new ColorTexture_1.ColorTexture(this.ctx, this.ctx.getScreenDims(), 4, ColorTexture_1.BitDepth.FLOAT);\n        }\n        const halfFloatSupport = TextureCompatibility_1.TextureCompatibility.supportHalfFloatTexture(this.ctx);\n        if (halfFloatSupport.supported && halfFloatSupport.filterable && halfFloatSupport.renderable) {\n            return new ColorTexture_1.ColorTexture(this.ctx, this.ctx.getScreenDims(), 4, ColorTexture_1.BitDepth.HALF_FLOAT);\n        }\n        // todo: dump effects which require support for higher bit depth\n        throw Error(\"This machine does not support textures necessary to perform deferred rendering!\");\n    }\n    renderScene() {\n        const timer = this.ctx.getGPUTimer();\n        if (!this.scene.isInitialized()) {\n            console.info(\"Render skipped due to uninitialized scene...\");\n            return;\n        }\n        const totalStart = timer.startQuery();\n        let dims = this.ctx.getScreenDims();\n        let old_dims = this.primaryFB.dims;\n        if (dims[0] !== old_dims[0] || dims[1] !== old_dims[1]) {\n            this.primaryFB.setFramebufferSize(dims);\n            this.swapFB.setFramebufferSize(dims);\n            this.positionFB.setFramebufferSize(dims);\n        }\n        this.renderPasses = [];\n        let gl = this.gl;\n        // find lights\n        let lights = this.findSpotLights(this.scene.getGameObjectRoot());\n        let ambLights = this.findAmbientLights(this.scene.getGameObjectRoot());\n        let spotLightInfo = [];\n        let ambLightInfo = [];\n        gl.enable(gl.CULL_FACE);\n        gl.cullFace(gl.FRONT);\n        const shadowStart = timer.startQuery();\n        // shit.cleanBlockList();\n        for (let light of lights) {\n            if (light.intensity < 0.0001) {\n                continue;\n            }\n            // spotlights void skyboxes for some reason\n            if (this.ctx.mobile) {\n                light.setShadows(false);\n            }\n            else if (light.getShadowState()) {\n                this.renderFromSpotLight(light);\n            }\n            spotLightInfo.push(new SpotLightStruct_1.SpotLightStruct(this.ctx, light));\n        }\n        const shadowProm = timer.stopQuery(shadowStart);\n        for (let light of ambLights) {\n            ambLightInfo.push(new AmbientLightStruct_1.AmbientLightStruct(this.ctx, light));\n        }\n        gl.cullFace(gl.BACK);\n        let cam = this.findActiveCamera(this.scene.getGameObjectRoot());\n        let info;\n        if (cam) {\n            info = cam.getCameraInfo();\n        }\n        else {\n            let view = gl_matrix_1.mat4.create();\n            let persp = gl_matrix_1.mat4.create();\n            let vp = gl_matrix_1.mat4.create();\n            let pos = gl_matrix_1.vec3.create();\n            console.info(\"no active cam found\");\n            gl_matrix_1.mat4.identity(view);\n            let rat = this.ctx.getScreenDims();\n            gl_matrix_1.mat4.perspective(persp, 1.0826, (rat[0] / rat[1]), 0.01, 100);\n            gl_matrix_1.mat4.mul(vp, view, persp);\n            gl_matrix_1.vec3.zero(pos);\n            info = {\n                viewMatrix: view,\n                perspectiveMatrix: persp,\n                vpMatrix: vp,\n                cameraPosition: pos\n            };\n        }\n        const skyboxes = this.findSkybox(this.scene.getGameObjectRoot());\n        const skyboxList = [];\n        // do not include until completely convolved\n        for (let skybox of skyboxes) {\n            if (skybox !== null && skybox.getCubemapDiffuse() !== null && skybox.getCubemapSpecular() !== null && skybox.getBRDF() !== null) {\n                skyboxList.push({\n                    irridance: skybox.getCubemapDiffuse(),\n                    specular: skybox.getCubemapSpecular(),\n                    brdf: skybox.getBRDF(),\n                    intensity: skybox.intensity,\n                    color: skybox.getCubemap()\n                });\n            }\n        }\n        // desc wrt intensity\n        skyboxList.sort((a, b) => (b.intensity - a.intensity));\n        const fb = this.primaryFB;\n        const pos = this.positionTex;\n        let rc = {\n            getRenderPass() {\n                return RenderContext_1.RenderPass.FINAL;\n            },\n            getActiveCameraInfo() {\n                return info;\n            },\n            getSpotLightInfo() {\n                return spotLightInfo;\n            },\n            getAmbientLightInfo() {\n                return ambLightInfo;\n            },\n            getSkybox() {\n                return skyboxList;\n            },\n            getFramebuffer() {\n                return fb;\n            },\n            getPositionData() {\n                return pos;\n            }\n        };\n        const finalStart = timer.startQuery();\n        let dim = this.ctx.getScreenDims();\n        this.gl.viewport(0, 0, dim[0], dim[1]);\n        // renderer should get a tree of components instead of trusting this guy\n        this.positionFB.bindFramebuffer(gl.FRAMEBUFFER);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n        this.scene.getGameObjectRoot().callbackChildren((this.drawPosition.bind(this, info.vpMatrix)));\n        this.gl.viewport(0, 0, dim[0], dim[1]);\n        this.primaryFB.bindFramebuffer(gl.FRAMEBUFFER);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n        this.scene.getGameObjectRoot().renderChildren(rc);\n        for (let model of this.ctx.getGLTFLoader().getInstancedModels()) {\n            model.flush(rc);\n        }\n        // problem: how do we deferred draw flushed models?\n        // - use an InstancedModel component.\n        // - grab it, draw its contents (instancedmodel + instancedposmat)\n        // note that we lose drawing order if we do this. that's probably for the best?\n        // draw skybox\n        const skyboxid = timer.startQuery();\n        this.gl.disable(gl.CULL_FACE);\n        this.skyboxMat.skyboxes = skyboxList;\n        this.skyboxMat.persp = info.perspectiveMatrix;\n        this.skyboxMat.view = info.viewMatrix;\n        this.skyboxMat.drawMaterial(this.cube);\n        timer.stopQueryAndLog(skyboxid, \"SkyboxMaterial\", performanceanalytics_1.RenderType.FINAL);\n        const finalProm = timer.stopQuery(finalStart);\n        const postStart = timer.startQuery();\n        // run our post processing passes\n        let filters = [];\n        if (cam) {\n            filters = cam.getFilters();\n        }\n        let usePrimaryAsSource = true;\n        let src = this.swapFB;\n        let dst = this.primaryFB;\n        for (let filter of filters) {\n            src = (usePrimaryAsSource ? this.primaryFB : this.swapFB);\n            dst = (usePrimaryAsSource ? this.swapFB : this.primaryFB);\n            dst.bindFramebuffer(this.gl.FRAMEBUFFER);\n            filter.filterfunc(src, dst, rc);\n            usePrimaryAsSource = !usePrimaryAsSource;\n        }\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this.renderPasses.push(new ColorDisplay_1.ColorDisplay(this.ctx, dst.getColorTexture()));\n        const postProm = timer.stopQuery(postStart);\n        const totalProm = timer.stopQuery(totalStart);\n        shadowProm.then((res) => this.shadowQueue.enqueue(res));\n        finalProm.then((res) => this.finalQueue.enqueue(res));\n        postProm.then((res) => this.postQueue.enqueue(res));\n        totalProm.then((res) => this.totalQueue.enqueue(res));\n    }\n    drawPosition(mat, obj) {\n        const model = obj.getComponent(ComponentType_1.ComponentType.MODEL);\n        if (model) {\n            this.positionMaterial.modelMat = obj.getTransformationMatrix();\n            this.positionMaterial.vpMat = mat;\n            this.positionMaterial.drawMaterial(model.model);\n        }\n    }\n    getDebugTiming() {\n        const shadowTime = this.shadowQueue.getAverage() / 1e6;\n        const finalTime = this.finalQueue.getAverage() / 1e6;\n        const postTime = this.postQueue.getAverage() / 1e6;\n        return {\n            shadowTime: shadowTime,\n            finalTime: finalTime,\n            postTime: postTime,\n            totalTime: shadowTime + finalTime + postTime\n        };\n    }\n    /**\n     * Once render is complete, returns the number of passes taken.\n     */\n    getPassCount() {\n        return (this.renderPasses ? this.renderPasses.length : 0);\n    }\n    /**\n     * Returns the texture associated with a given pass.\n     * Starts from zero and progresses in order drawn.\n     * @param index - index fetched.\n     * @returns Texture, or null if the index was invalid.\n     */\n    getPass(index) {\n        return this.renderPasses[Math.min(Math.max(Math.floor(index), 0), this.getPassCount() - 1)];\n    }\n    findSpotLights(root) {\n        let lights = [];\n        if (root instanceof SpotLightObject_1.SpotLightObject) {\n            lights.push(root);\n        }\n        for (let child of root.getChildren()) {\n            let childLights = this.findSpotLights(child);\n            lights.push.apply(lights, childLights);\n        }\n        return lights;\n    }\n    findAmbientLights(root) {\n        let lights = [];\n        if (root instanceof AmbientLightObject_1.AmbientLightObject) {\n            lights.push(root);\n        }\n        for (let child of root.getChildren()) {\n            let childLights = this.findAmbientLights(child);\n            lights.push.apply(lights, childLights);\n        }\n        return lights;\n    }\n    renderFromSpotLight(light) {\n        let rc = new SpotLightRenderContext(light);\n        // provide the fb in context? or rebind it on each pass\n        let fb = light._getShadowFramebuffer();\n        fb.bindFramebuffer(this.gl.FRAMEBUFFER);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);\n        let dim = fb.dims;\n        this.gl.viewport(0, 0, dim[0], dim[1]);\n        this.scene.getGameObjectRoot().renderChildren(rc);\n        // flush instanced models\n        for (let model of this.ctx.getGLTFLoader().getInstancedModels()) {\n            model.flush(rc);\n        }\n        // shadow texture will contain result\n        this.renderPasses.push(new ShadowDisplay_1.ShadowDisplay(this.ctx, light));\n    }\n    findActiveCamera(root) {\n        for (let child of root.getChildren()) {\n            if (child instanceof GameCamera_1.GameCamera && child.isActive()) {\n                return child;\n            }\n            else {\n                let activeCamera = this.findActiveCamera(child);\n                if (activeCamera !== null) {\n                    return activeCamera;\n                }\n            }\n        }\n        return null;\n    }\n    findSkybox(root) {\n        let res = [];\n        for (let child of root.getChildren()) {\n            if (child instanceof SkyboxObject_1.SkyboxObject) {\n                res.push(child);\n            }\n            else {\n                const skybox = this.findSkybox(child);\n                if (skybox.length !== 0) {\n                    res = res.concat(skybox);\n                }\n            }\n        }\n        return res;\n    }\n}\nexports.Renderer = Renderer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/internal/Renderer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/internal/getEnginePath.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/internal/getEnginePath.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnginePath = void 0;\nfunction getEnginePath(relPath) {\n    // accepts paths specified from root dir\n    // puts together a path which starts from window\n    let prefix = window.location.href;\n    // trailing slash is sometimes missing\n    if (prefix.charAt(prefix.length - 1) !== '/') {\n        prefix = prefix + '/';\n    }\n    return `${prefix}../`;\n}\nexports.getEnginePath = getEnginePath;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/internal/getEnginePath.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/internal/performanceanalytics.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/internal/performanceanalytics.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRenderPerf = exports.getUpdatePerf = exports.logRender = exports.logUpdate = exports.clearPerf = exports.RenderType = exports.Category = void 0;\nconst PingQueue_1 = __webpack_require__(/*! ../../../../ts/util/PingQueue */ \"./hingler-party/ts/util/PingQueue.ts\");\nconst updatePerf = new Map();\nconst renderPerf = new Map();\nconst renderQueue = new Map();\nconst updateQueue = new Map();\nconst SAMPLES_PER_QUEUE = 128;\nclass PerfData {\n    constructor(data) {\n        this.sortedData = [];\n        for (let elem of data) {\n            this.sortedData.push([elem[0], elem[1].getAverage()]);\n        }\n        this.sortedData.sort((a, b) => b[1] - a[1]);\n        this.sortedData = this.sortedData.filter((val) => val[1] > 0);\n    }\n    get length() {\n        return this.sortedData.length;\n    }\n    get(ind) {\n        return this.sortedData[ind];\n    }\n    [Symbol.iterator]() {\n        return new PerfDataIterator(this.sortedData);\n    }\n}\nclass PerfDataIterator {\n    constructor(sortedData) {\n        this.sortedData = sortedData;\n        this.index = 0;\n    }\n    next() {\n        if (this.index >= this.sortedData.length) {\n            return { done: true, value: null };\n        }\n        return {\n            value: [this.sortedData[this.index][0], this.sortedData[this.index][1]],\n            done: (++this.index >= this.sortedData.length)\n        };\n    }\n}\nvar Category;\n(function (Category) {\n    Category[Category[\"UPDATE\"] = 0] = \"UPDATE\";\n    Category[Category[\"RENDER\"] = 1] = \"RENDER\";\n})(Category = exports.Category || (exports.Category = {}));\n;\nvar RenderType;\n(function (RenderType) {\n    RenderType[\"SHADOW\"] = \"shadow\";\n    RenderType[\"FINAL\"] = \"final\";\n    RenderType[\"POST\"] = \"post\";\n    RenderType[\"UNCATEGORIZED\"] = \"uncategorized\";\n})(RenderType = exports.RenderType || (exports.RenderType = {}));\n;\nfunction clearPerf() {\n    const perfs = [\n        [updatePerf, updateQueue],\n        [renderPerf, renderQueue]\n    ];\n    for (let [perf, queueMap] of perfs) {\n        for (let [name, delta] of perf) {\n            let queue;\n            if (!queueMap.has(name)) {\n                queue = new PingQueue_1.PingQueue(SAMPLES_PER_QUEUE);\n                queueMap.set(name, queue);\n            }\n            else {\n                queue = queueMap.get(name);\n            }\n            queue.enqueue(delta);\n            // if we haven't queued up a value for something which definitely has a pingqueue, then wipe it\n        }\n        for (let name of queueMap.keys()) {\n            if (!perf.has(name)) {\n                // wasn't updated -- no render, so push a 0\n                queueMap.get(name).enqueue(0);\n            }\n        }\n    }\n    updatePerf.clear();\n    renderPerf.clear();\n}\nexports.clearPerf = clearPerf;\nfunction logPerf(name, delta, category) {\n    const targ = (category === Category.UPDATE ? updatePerf : renderPerf);\n    let time = 0;\n    if (targ.has(name)) {\n        time = targ.get(name);\n    }\n    targ.set(name, time + delta);\n}\n// todo: add some color tagging\n// quickly differentiate shadows from draws from postrenders\nfunction logUpdate(name, delta) {\n    logPerf(name, delta, Category.UPDATE);\n}\nexports.logUpdate = logUpdate;\nfunction logRender(name, delta, type) {\n    const rendertype = (type !== undefined ? type : RenderType.UNCATEGORIZED);\n    logPerf(`${rendertype}::${name}`, delta, Category.RENDER);\n}\nexports.logRender = logRender;\nfunction getData(category) {\n    const targ = (category === Category.UPDATE ? updateQueue : renderQueue);\n    return new PerfData(targ);\n}\nfunction getUpdatePerf() {\n    return getData(Category.UPDATE);\n}\nexports.getUpdatePerf = getUpdatePerf;\nfunction getRenderPerf() {\n    return getData(Category.RENDER);\n}\nexports.getRenderPerf = getRenderPerf;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/internal/performanceanalytics.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/FileLoader.ts":
/*!**************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/FileLoader.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileLoader = void 0;\nconst Task_1 = __webpack_require__(/*! ../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst ImageTexture_1 = __webpack_require__(/*! ../gl/internal/ImageTexture */ \"./hingler-party/client/ts/engine/gl/internal/ImageTexture.ts\");\nconst FileLikeWeb_1 = __webpack_require__(/*! ./internal/FileLikeWeb */ \"./hingler-party/client/ts/engine/loaders/internal/FileLikeWeb.ts\");\n/**\n * Provides a convenient wrapper for loading files.\n * Tracks loading progress of a particular file.\n * Move loading here, instead of GLTFLoader lmao\n */\nclass FileLoader {\n    constructor(ctx, loadServiceWorker) {\n        this.loadedFiles = new Map();\n        this.imageTextures = new Map();\n        this.gl = ctx.getGLContext();\n        this.ctx = ctx;\n        FileLoader.workerLoaded = null;\n        if (loadServiceWorker === undefined || loadServiceWorker) {\n            this.workerPath = new Promise((re, rj) => { this.res = re; this.rej = rj; });\n            ;\n            // serviceworker needs to be a singleton!!!\n            if (\"serviceWorker\" in navigator && FileLoader.workerLoaded === null) {\n                FileLoader.workerLoaded = new Task_1.Task();\n                this.cb();\n            }\n            else {\n                // fetch calls won't go to cache, but it's OK\n                this.res();\n            }\n        }\n        else {\n            console.debug(\"ServiceWorker did not load on this run :)\");\n        }\n    }\n    cb() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"test\");\n            // raise a boolean flag if the serviceworker is registered\n            window.navigator.serviceWorker.register(\"../sw.js\", {}).then((_) => {\n                console.log(\"serviceworker registered~~~\");\n                this.res();\n                FileLoader.workerLoaded.resolve();\n            }, (err) => {\n                console.error(\"could not register serviceworker :(\");\n                // for some reason this occurs on the pentium silver\n                // not sure what the underlying cause is, i'll look into it\n                // either way, make sure this doesn't throw forever\n                // supported but crashes\n                console.error(err);\n                this.res();\n            });\n        });\n    }\n    open(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.workerPath;\n            if (FileLoader.workerLoaded !== null) {\n                // this should always be false -- wait for the resolution of the workerloaded singleton\n                yield FileLoader.workerLoaded.getFuture().wait();\n            }\n            let res;\n            if (this.loadedFiles.has(path)) {\n                res = this.loadedFiles.get(path);\n            }\n            else {\n                let resp = fetch(path);\n                res = new FileLikeWeb_1.FileLikeWeb(resp);\n                this.loadedFiles.set(path, res);\n            }\n            yield res.waitUntilReady();\n            return res;\n        });\n    }\n    openTexture(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let tex;\n            if (this.imageTextures.has(path)) {\n                tex = this.imageTextures.get(path);\n            }\n            else {\n                tex = new ImageTexture_1.ImageTexture(this.ctx, path);\n                this.imageTextures.set(path, tex);\n            }\n            yield tex.waitUntilLoaded();\n            return tex;\n        });\n    }\n    getFractionLoaded() {\n        let files = 0;\n        let filesLoaded = 0;\n        if (this.loadedFiles.size === 0) {\n            return 1;\n        }\n        for (let file of this.loadedFiles) {\n            files++;\n            if (file[1].ready()) {\n                filesLoaded++;\n            }\n        }\n        return (filesLoaded / files);\n    }\n}\nexports.FileLoader = FileLoader;\nFileLoader.workerLoaded = null;\n// focus on single scene right now -- i'm pretty sure that should be fine.\n// rather than transitioning between scenes, we'll use webpages to implement that.\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/FileLoader.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/ArmatureBuilder.ts":
/*!****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/ArmatureBuilder.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArmatureBuilder = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ArmatureNode_1 = __webpack_require__(/*! ../../object/armature/ArmatureNode */ \"./hingler-party/client/ts/engine/object/armature/ArmatureNode.ts\");\nconst ArmatureManager_1 = __webpack_require__(/*! ../../object/armature/ArmatureManager */ \"./hingler-party/client/ts/engine/object/armature/ArmatureManager.ts\");\nclass ArmatureBuilder {\n    // gltf data, skin index -> armaturenode\n    // gltf data, skin index -> (unknown armature wrapper)\n    static skinToArmature(data, skinIndex, buffers, ctx) {\n        if (!data.skins) {\n            // no skins to fetch\n            console.warn(`No skins present in this GLTF file.`);\n            return null;\n        }\n        if (!data.skins[skinIndex]) {\n            console.warn(`Skin index ${skinIndex} not present in GLTF file.`);\n            return null;\n        }\n        // for each joint:\n        // - get the node\n        // - put it in an array\n        const skin = data.skins[skinIndex];\n        const nodeArray = this.getNodeArray(data, skin);\n        if (!nodeArray) {\n            // some important component was missing\n            return null;\n        }\n        // then, inversebind\n        // - get the buffer which contains our inversebind data\n        // - we intend to use it as a mat4, so just read it from the GLBuffer.\n        const inverseMatrices = this.getInverseBindMatrices(data, skin, buffers);\n        // lastly, hierarchy\n        // - go through our node list, creating ArmatureNodes when relevant.\n        // - use a hash set to associate node numbers with armature nodes.\n        // - if a child has not been created, go create it and add it to the hash set\n        // set our node transforms to the values specified in the GLTF file\n        // once all our nodes have been attached, go up the hierarchy to the root node\n        // that's the one we want to return!!!\n        const rootArmature = this.nodesToArmatureHierarchy(data, nodeArray, inverseMatrices);\n        // DEBUG: so we can peek at it temporarily\n        rootArmature.getJointMatrix();\n        console.log(rootArmature);\n        return new ArmatureManager_1.ArmatureManager(rootArmature, ctx);\n        // animation manager\n        // - just put the armature into the manager\n        // (skipped for now)\n    }\n    static getNodeArray(data, skin) {\n        if (!data.nodes) {\n            // no nodes but armature data?\n            return null;\n        }\n        const nodeArray = [];\n        for (let jointIndex of skin.joints) {\n            if (!data.nodes[jointIndex]) {\n                // node index is invalid :(\n                return null;\n            }\n            nodeArray.push(jointIndex);\n        }\n        return nodeArray;\n    }\n    static getInverseBindMatrices(data, skin, buffers) {\n        // should probably throw instead of returning null\n        if (!data.buffers || !data.bufferViews || !data.accessors) {\n            // mystery mode\n            return null;\n        }\n        const res = [];\n        if (!skin.inverseBindMatrices) {\n            // assume identity for all\n            for (let i = 0; i < skin.joints.length; i++) {\n                res.push(gl_matrix_1.mat4.identity([]));\n            }\n        }\n        else {\n            const inverseMatAccessor = data.accessors[skin.inverseBindMatrices];\n            if (!inverseMatAccessor) {\n                return null;\n            }\n            const inverseMatBufferView = data.bufferViews[inverseMatAccessor.bufferView];\n            if (!inverseMatBufferView) {\n                return null;\n            }\n            const inverseMatBuffer = buffers[inverseMatBufferView.buffer];\n            if (!inverseMatBuffer) {\n                return null;\n            }\n            const bufferOffset = (inverseMatBufferView.byteOffset || 0) + (inverseMatAccessor.byteOffset || 0);\n            // this might be bad\n            const bufferStride = (inverseMatBufferView.byteStride || 64);\n            if (inverseMatAccessor.count < skin.joints.length) {\n                // bad joints length\n                return null;\n            }\n            console.log(\"here?\");\n            if (inverseMatBuffer.size() < (bufferStride * (inverseMatAccessor.count - 1) + 64 + bufferOffset)) {\n                console.log(inverseMatBuffer.size());\n                // not enough buffer space\n                return null;\n            }\n            for (let i = 0; i < skin.joints.length; i++) {\n                const mat = inverseMatBuffer.getFloat32Array(bufferOffset + bufferStride * i, 16);\n                res.push(mat);\n            }\n        }\n        return res;\n    }\n    static nodesToArmatureHierarchy(data, nodeList, inverseBindMatrices) {\n        const nodeMap = new Map();\n        // map from node indices to \n        for (let i = 0; i < nodeList.length; i++) {\n            const node = data.nodes[nodeList[i]];\n            // we should have caught this already but just in case\n            if (!node) {\n                return null;\n            }\n            let armature;\n            armature = this.createArmatureNodeFromGLTFNode(node, i, inverseBindMatrices[i], nodeList[i]);\n            nodeMap.set(nodeList[i], armature);\n        }\n        for (let i = 0; i < nodeList.length; i++) {\n            const armature = nodeMap.get(nodeList[i]);\n            if (!armature) {\n                console.warn(\"Armature not found in nodemap!\");\n                return null;\n            }\n            const node = data.nodes[nodeList[i]];\n            if (node.children) {\n                for (let child of node.children) {\n                    if (!nodeMap.has(child)) {\n                        // a child node was not found in the armature map.\n                        // it could be a non-armature, or a bug -- skip it for now\n                        console.warn(\"Child \" + child + \" not found in nodemap -- skipping...\");\n                    }\n                    // add the specified child armature as a child!\n                    const childArmature = nodeMap.get(child);\n                    armature.addChild(childArmature);\n                }\n            }\n        }\n        // at this point, we should have an unambiguous parent node which is the root of our tree\n        let parentNode = nodeMap.get(nodeList[0]);\n        while (parentNode.getParent() !== null) {\n            parentNode = parentNode.getParent();\n        }\n        return parentNode;\n    }\n    static createArmatureNodeFromGLTFNode(node, id, invMat, nodeID) {\n        const res = new ArmatureNode_1.ArmatureNode(id, invMat);\n        if (node.translation) {\n            res.setPosition(node.translation);\n        }\n        if (node.rotation) {\n            res.setRotationQuat(node.rotation);\n        }\n        if (node.scale) {\n            res.setScale(node.scale);\n        }\n        res.setNodeID(nodeID);\n        return res;\n    }\n}\nexports.ArmatureBuilder = ArmatureBuilder;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/ArmatureBuilder.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/FileLikeWeb.ts":
/*!************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/FileLikeWeb.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileLikeWeb = void 0;\nconst StringToArrayBuffer_1 = __webpack_require__(/*! ../../../../../ts/util/StringToArrayBuffer */ \"./hingler-party/ts/util/StringToArrayBuffer.ts\");\nclass FileLikeWeb {\n    constructor(resp) {\n        this.buffer = null;\n        this.fail_ = false;\n        if (resp instanceof Response) {\n            if (!resp.ok) {\n                this.fail_ = true;\n            }\n            this.bufferPromise = resp.arrayBuffer().then((r) => {\n                this.buffer = r;\n            });\n        }\n        else {\n            this.bufferPromise = resp.then((r) => r.arrayBuffer()).then((r) => {\n                this.buffer = r;\n            });\n        }\n        // assume utf8 for now :(\n        this.bufferPromise.catch(r => {\n            this.fail_ = true;\n        });\n    }\n    get fail() {\n        return this.fail_;\n    }\n    asString() {\n        if (this.buffer === null) {\n            return null;\n        }\n        return (0, StringToArrayBuffer_1.ArrayBufferToString)(this.buffer);\n    }\n    asArrayBuffer() {\n        // this does not work :/\n        // ideally: we would return it as a read only\n        return this.buffer;\n    }\n    waitUntilReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.bufferPromise;\n            return this;\n        });\n    }\n    ready() {\n        return (this.buffer !== null);\n    }\n}\nexports.FileLikeWeb = FileLikeWeb;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/FileLikeWeb.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/GLTFLoaderImpl.ts":
/*!***************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/GLTFLoaderImpl.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFLoaderImpl = void 0;\nconst StringToArrayBuffer_1 = __webpack_require__(/*! ../../../../../ts/util/StringToArrayBuffer */ \"./hingler-party/ts/util/StringToArrayBuffer.ts\");\nconst GLAttributeImpl_1 = __webpack_require__(/*! ../../gl/internal/GLAttributeImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts\");\nconst GLBufferImpl_1 = __webpack_require__(/*! ../../gl/internal/GLBufferImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts\");\nconst ImageTexture_1 = __webpack_require__(/*! ../../gl/internal/ImageTexture */ \"./hingler-party/client/ts/engine/gl/internal/ImageTexture.ts\");\nconst GLTFSceneImpl_1 = __webpack_require__(/*! ./GLTFSceneImpl */ \"./hingler-party/client/ts/engine/loaders/internal/GLTFSceneImpl.ts\");\nconst GLTF_MAGIC = 0x46546C67;\nconst CHUNK_TYPE_JSON = 0x4E4F534A;\nconst CHUNK_TYPE_BIN = 0x004E4942;\nvar FileType;\n(function (FileType) {\n    FileType[FileType[\"BINARY\"] = 0] = \"BINARY\";\n    FileType[FileType[\"UNKNOWN\"] = 1] = \"UNKNOWN\";\n})(FileType || (FileType = {}));\n;\nclass GLTFLoaderImpl {\n    constructor(loader, ctx) {\n        this.loader = loader;\n        this.gl = ctx.getGLContext();\n        this.ctx = ctx;\n        this.sceneCache = new Map();\n        this.scenesLoading = new Map();\n        this.instancedModels = new Set();\n    }\n    getInstancedModels() {\n        return this.instancedModels;\n    }\n    /**\n     * Internally stores the passed model, so that the renderer can draw it.\n     * @param model - The model being registered.\n     *\n     * todo: handling duplicates from multiple scenes? it shouldnt be a problem\n     * if we implement scene switching we'll dump loader contents and spin up a new context\n     */\n    registerInstancedModel(model) {\n        this.instancedModels.add(model);\n    }\n    resolvePath(path) {\n        let suffix = path.substring(path.lastIndexOf('.') + 1).toLowerCase();\n        switch (suffix) {\n            case \"glb\":\n                return FileType.BINARY;\n            default:\n                console.error(\"Cannot currently handle file \" + path);\n                return FileType.UNKNOWN;\n        }\n    }\n    loadAsGLTFScene(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let type = this.resolvePath(path);\n            let res;\n            switch (type) {\n                case FileType.BINARY:\n                    res = yield this.glbBinaryToScene(path);\n                    break;\n                case FileType.UNKNOWN:\n                    return null;\n                default:\n                    console.error(\"Something went wrong :(\");\n                    throw Error(\"what\");\n            }\n            return res;\n        });\n    }\n    /**\n     * deprecated\n     * @param path - path to image\n     * @returns imagetexture object\n     */\n    loadTexture(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let tex = new ImageTexture_1.ImageTexture(this.ctx, path);\n            yield tex.waitUntilLoaded();\n            return tex;\n        });\n    }\n    loadGLTFModel(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // start out by just printing the stuff in the json field\n            // as well as interpreting the binary data\n            // convert to a resolvepath func\n            let suffix = path.substring(path.lastIndexOf('.') + 1).toLowerCase();\n            switch (suffix) {\n                case \"glb\":\n                    return this.loadGLB(path);\n                default:\n                    console.error(\"Cannot currently handle file \" + path);\n                    return null;\n            }\n        });\n    }\n    glbBinaryToScene(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.scenesLoading.has(path)) {\n                return yield this.scenesLoading.get(path);\n            }\n            if (this.sceneCache.has(path)) {\n                console.log(\"scene cache hit!\");\n                return this.sceneCache.get(path);\n            }\n            let resolve;\n            let reject;\n            let progress = new Promise((re, rj) => {\n                resolve = re;\n                reject = rj;\n            });\n            this.scenesLoading.set(path, progress);\n            let file = yield this.loader.open(path);\n            let buf = file.asArrayBuffer();\n            let view = new DataView(buf);\n            // do everything up to reading the buffers, then return those\n            // let the loading function handle parsing\n            // read magic\n            const magic = view.getUint32(0, true);\n            if (magic !== GLTF_MAGIC) {\n                let err = `Magic number in file does not match desired!`;\n                console.warn(err);\n                reject(err);\n                this.scenesLoading.delete(path);\n                throw Error(err);\n            }\n            const ver = view.getUint32(4, true);\n            if (ver !== 2) {\n                let err = `Version number in file is not 2!`;\n                console.warn(err);\n                reject(err);\n                this.scenesLoading.delete(path);\n                throw Error(err);\n            }\n            const len = view.getUint32(8, true);\n            // first chunk is always json data, remaining are binary\n            const jsonChunkLen = view.getUint32(12, true);\n            const jsonChunkType = view.getUint32(16, true);\n            if (jsonChunkType !== CHUNK_TYPE_JSON) {\n                let err = `First chunk is not JSON!`;\n                console.warn(err);\n                reject(err);\n                this.scenesLoading.delete(path);\n                throw Error(err);\n            }\n            let jsonData = buf.slice(20, 20 + jsonChunkLen);\n            let jsonRaw = (0, StringToArrayBuffer_1.ArrayBufferToString)(jsonData);\n            console.debug(jsonRaw);\n            let jsonParsed = JSON.parse(jsonRaw);\n            console.info(jsonParsed);\n            let buffers = this.readBinaryDataToBuffers(view, buf, 20 + jsonChunkLen, len);\n            let res = new GLTFSceneImpl_1.GLTFSceneImpl(this.ctx, jsonParsed, buffers);\n            this.sceneCache.set(path, res);\n            this.scenesLoading.delete(path);\n            resolve(res);\n            return res;\n        });\n    }\n    loadGLB(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let scene = yield this.glbBinaryToScene(path);\n            let models = [];\n            for (let i = 0; i < scene.getModelCount(); i++) {\n                models.push(scene.getModel(i));\n            }\n            return models;\n        });\n    }\n    // returns null if the accessor is falsy (undefined, null, etc)\n    createAttributeFromJSON(data, buffers, accessor) {\n        if (accessor === undefined) {\n            return null;\n        }\n        let ac = data.accessors[accessor];\n        let view = data.bufferViews[ac.bufferView];\n        let buffer = buffers[view.buffer];\n        // convert this over to something which is just raw memory\n        // TODO: this whole bunch needs a reorganization\n        // the loader should turn files into arrbuffers\n        // the scene should bunch arrbuffers into models\n        // and a third component should turn those models into GL data\n        // for now i'll just test it in browser \n        return new GLAttributeImpl_1.GLAttributeImpl(buffer, view, ac);\n    }\n    // convert this over to array buffers\n    readBinaryDataToBuffers(view, buffer, initOffset, len) {\n        let buffers = [];\n        let chunkCount = 1;\n        let offset = initOffset;\n        while (offset < len) {\n            let chunkLen = view.getUint32(offset, true);\n            offset += 4;\n            let chunkType = view.getUint32(offset, true);\n            offset += 4;\n            if (chunkType !== CHUNK_TYPE_BIN) {\n                let err = `Chunk ${chunkCount} did not contain binary data!`;\n                console.warn(err);\n                throw Error(err);\n            }\n            buffers.push(new GLBufferImpl_1.GLBufferImpl(this.ctx, buffer.slice(offset, chunkLen + offset)));\n            offset += chunkLen;\n        }\n        return buffers;\n    }\n}\nexports.GLTFLoaderImpl = GLTFLoaderImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/GLTFLoaderImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/GLTFSceneImpl.ts":
/*!**************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/GLTFSceneImpl.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFSceneImpl = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst GLAttributeImpl_1 = __webpack_require__(/*! ../../gl/internal/GLAttributeImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts\");\nconst GLIndexImpl_1 = __webpack_require__(/*! ../../gl/internal/GLIndexImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLIndexImpl.ts\");\nconst GLTFTexture_1 = __webpack_require__(/*! ../../gl/internal/GLTFTexture */ \"./hingler-party/client/ts/engine/gl/internal/GLTFTexture.ts\");\nconst PBRMaterialImpl_1 = __webpack_require__(/*! ../../material/PBRMaterialImpl */ \"./hingler-party/client/ts/engine/material/PBRMaterialImpl.ts\");\nconst PBRInstanceFactory_1 = __webpack_require__(/*! ../../model/PBRInstanceFactory */ \"./hingler-party/client/ts/engine/model/PBRInstanceFactory.ts\");\nconst GamePBRModel_1 = __webpack_require__(/*! ../../object/game/GamePBRModel */ \"./hingler-party/client/ts/engine/object/game/GamePBRModel.ts\");\nconst ArmatureBuilder_1 = __webpack_require__(/*! ./ArmatureBuilder */ \"./hingler-party/client/ts/engine/loaders/internal/ArmatureBuilder.ts\");\nconst InstancedModelImpl_1 = __webpack_require__(/*! ./InstancedModelImpl */ \"./hingler-party/client/ts/engine/loaders/internal/InstancedModelImpl.ts\");\nconst ModelImpl_1 = __webpack_require__(/*! ./ModelImpl */ \"./hingler-party/client/ts/engine/loaders/internal/ModelImpl.ts\");\nconst PBRModelImpl_1 = __webpack_require__(/*! ./PBRModelImpl */ \"./hingler-party/client/ts/engine/loaders/internal/PBRModelImpl.ts\");\nconst GLTFAnimationBuilder_1 = __webpack_require__(/*! ../../animation/GLTFAnimationBuilder */ \"./hingler-party/client/ts/engine/animation/GLTFAnimationBuilder.ts\");\n// todo: holy shit this needs cleanup\nclass GLTFSceneImpl {\n    constructor(ctx, data, buffers) {\n        this.ctx = ctx;\n        this.gl = ctx.getGLContext();\n        this.data = data;\n        this.buffers = buffers;\n        this.modelCache = new Map();\n        this.modelCachePBR = new Map();\n        this.matCache = new Map();\n        this.animationData = new Map();\n    }\n    // check nodes first\n    getArmature(name) {\n        // number is a meshid\n        // string is a node name or mesh name\n        // check nodes for a skin id\n        if (typeof name === \"string\") {\n            if (this.data.nodes) {\n                for (let node of this.data.nodes) {\n                    if (node.name === name && node.skin !== undefined) {\n                        return this.getArmatureFromSkinID(node.skin);\n                    }\n                }\n            }\n            // then check meshes for matching string\n            if (this.data.meshes) {\n                for (let i = 0; i < this.data.meshes.length; i++) {\n                    if (this.data.meshes[i].name === name) {\n                        return this.getArmatureFromMeshID(i);\n                    }\n                }\n            }\n        }\n        else {\n            if (this.data.meshes && name < this.data.meshes.length) {\n                return this.getArmatureFromMeshID(name);\n            }\n        }\n        // then check meshes for a matching number\n        return null;\n    }\n    // work off a string, or a number\n    getArmatureFromMeshID(meshID) {\n        if (this.data.nodes) {\n            for (let node of this.data.nodes) {\n                if (node.mesh && node.mesh === meshID && node.skin !== undefined) {\n                    return this.getArmatureFromSkinID(node.skin);\n                }\n            }\n        }\n        return undefined;\n    }\n    // load an armature as a manager\n    getArmatureFromSkinID(skinID) {\n        return ArmatureBuilder_1.ArmatureBuilder.skinToArmature(this.data, skinID, this.buffers, this.ctx);\n    }\n    getAnimationData(animationName) {\n        if (this.animationData.has(animationName)) {\n            return this.animationData.get(animationName);\n        }\n        else {\n            // need to build it!\n            if (!this.data.animations) {\n                return null;\n            }\n            for (let animation of this.data.animations) {\n                if (animation.name && animation.name === animationName) {\n                    const anim = GLTFAnimationBuilder_1.GLTFAnimationBuilder.buildAnimationManager(this.data, animation, this.buffers);\n                    this.animationData.set(animationName, anim);\n                    return anim;\n                }\n            }\n            return null;\n        }\n    }\n    getModel(name) {\n        // nodes have skins\n        let meshID = this.lookupMeshID(name);\n        let mesh = this.data.meshes[meshID];\n        let models = [];\n        for (let prim of mesh.primitives) {\n            let inst = this.getInstance(prim);\n            models.push(inst);\n        }\n        let armature = this.getArmature(name);\n        let res = new ModelImpl_1.ModelImpl(models);\n        if (typeof name === \"string\") {\n            // probably the node name\n            res.name = name;\n        }\n        else {\n            res.name = this.getMeshName(meshID);\n        }\n        // figure out the skin, and nodeID, if relevant.\n        return res;\n    }\n    getNodeAsGameObject(name) {\n        let targNode;\n        if (!this.data.nodes) {\n            return null;\n        }\n        if (typeof name === \"string\") {\n            for (let node of this.data.nodes) {\n                if (node.name === name) {\n                    targNode = node;\n                    break;\n                }\n            }\n        }\n        else {\n            if (name < 0 || name >= this.data.nodes.length) {\n                return null;\n            }\n            targNode = this.data.nodes[name];\n        }\n        if (!targNode.mesh) {\n            console.warn(\"Attempted to load node which is not a model - i dont want to deal with it right now sorry\");\n        }\n        let model = this.getPBRModel(targNode.mesh);\n        let res = new GamePBRModel_1.GamePBRModel(this.ctx, model);\n        if (targNode.rotation) {\n            res.setRotationQuat(targNode.rotation);\n        }\n        if (targNode.translation) {\n            res.setPosition(targNode.translation);\n        }\n        if (targNode.scale) {\n            res.setScale(targNode.scale);\n        }\n        return res;\n    }\n    getInstancedModel(name) {\n        // create the instanced model\n        let model = this.getModel(name);\n        let instModel = new InstancedModelImpl_1.InstancedModelImpl(this.ctx, model);\n        this.ctx.getGLTFLoader().registerInstancedModel(instModel);\n        return instModel;\n        // put it somewhere in the engine\n        // the renderer will pick it up and flush it\n    }\n    getTexture(name) {\n        if (typeof name === \"string\") {\n            return this.getTextureFromName(name);\n        }\n        else {\n            return this.getTextureFromNumber(name);\n        }\n    }\n    getTextureFromName(name) {\n        if (this.data.textures) {\n            for (let tex of this.data.textures) {\n                let img = this.data.images[tex.source];\n                if (img.name === name) {\n                    // TODO: alternative methods of fetching textures (name not always present)\n                    return this.texSchemaToTexture(tex, img);\n                }\n            }\n        }\n    }\n    getTextureFromNumber(ind) {\n        if (this.data.textures && ind < this.data.textures.length) {\n            let tex = this.data.textures[ind];\n            return this.texSchemaToTexture(tex, this.data.images[tex.source]);\n        }\n    }\n    getModelCount() {\n        return this.data.meshes.length;\n    }\n    getInstancesAsModels(meshID) {\n        if (this.modelCachePBR.has(meshID)) {\n            return this.modelCachePBR.get(meshID);\n        }\n        let mesh = this.data.meshes[meshID];\n        let models = [];\n        for (let prim of mesh.primitives) {\n            let inst = this.getInstance(prim);\n            // caching is a mess\n            // PBRArray should return models (from instances)\n            // and materials\n            let model = new ModelImpl_1.ModelImpl([inst]);\n            models.push(model);\n        }\n        this.modelCachePBR.set(meshID, models);\n        return models;\n    }\n    // consumes a PBRInterface and a material and configures all fixed values in the PBRInterface.\n    configurePBR(pbrMat, mat) {\n        if (mat.normalTexture && !this.ctx.mobile) {\n            let normtex = this.getTextureFromNumber(mat.normalTexture.index);\n            pbrMat.normal = normtex;\n        }\n        let pbrSchema = mat.pbrMetallicRoughness;\n        if (pbrSchema.baseColorFactor) {\n            pbrMat.colorFactor = pbrSchema.baseColorFactor;\n        }\n        else {\n            pbrMat.colorFactor = [1, 1, 1, 1];\n        }\n        if (pbrSchema.baseColorTexture) {\n            pbrMat.color = this.getTextureFromNumber(pbrSchema.baseColorTexture.index);\n        }\n        pbrMat.roughFactor = (pbrSchema.roughnessFactor !== undefined ? pbrSchema.roughnessFactor : 1.0);\n        pbrMat.metalFactor = (pbrSchema.metallicFactor !== undefined ? pbrSchema.metallicFactor : 1.0);\n        if (pbrSchema.metallicRoughnessTexture) {\n            pbrMat.metalRough = this.getTextureFromNumber(pbrSchema.metallicRoughnessTexture.index);\n        }\n        if (mat.emissiveFactor) {\n            const fac = gl_matrix_1.vec4.create();\n            fac[0] = mat.emissiveFactor[0];\n            fac[1] = mat.emissiveFactor[1];\n            fac[2] = mat.emissiveFactor[2];\n            fac[3] = 1.0;\n            pbrMat.emissionFactor = fac;\n        }\n        else {\n            pbrMat.emissionFactor = gl_matrix_1.vec4.zero(gl_matrix_1.vec4.create());\n        }\n        return pbrMat;\n    }\n    getPBRMaterials(meshID) {\n        let mesh = this.data.meshes[meshID];\n        let materials = [];\n        for (let prim of mesh.primitives) {\n            if (this.matCache.has(prim.material)) {\n                materials.push(this.matCache.get(prim.material));\n                continue;\n            }\n            let mat = this.data.materials[prim.material];\n            if (!mat) {\n                const err = \"Could not find relevant material\";\n                console.error(err);\n                throw Error(err);\n            }\n            // create a PBRMaterial which mirrors that material\n            // append it to an array\n            let pbrMat = new PBRMaterialImpl_1.PBRMaterialImpl(this.ctx);\n            pbrMat = this.configurePBR(pbrMat, mat);\n            materials.push(pbrMat);\n        }\n        return materials;\n    }\n    lookupMeshID(model) {\n        let meshID = -1;\n        if (typeof model === \"number\") {\n            meshID = model;\n        }\n        else {\n            for (let i = 0; i < this.data.meshes.length; i++) {\n                if (this.data.meshes[i].name === model) {\n                    meshID = i;\n                    break;\n                }\n            }\n            // check node names -- sometimes they get mixed up\n            if (meshID === -1 && this.data.nodes) {\n                for (let i = 0; i < this.data.nodes.length; i++) {\n                    if (this.data.nodes[i].name === model && this.data.nodes[i].mesh !== undefined) {\n                        meshID = this.data.nodes[i].mesh;\n                        break;\n                    }\n                }\n            }\n        }\n        if (meshID < 0 || meshID >= this.data.meshes.length) {\n            let err = \"Invalid mesh identifier provided: \" + model;\n            console.error(err);\n            throw err;\n        }\n        return meshID;\n    }\n    getMeshName(meshID) {\n        return this.data.meshes[meshID].name;\n    }\n    getPBRModel(model) {\n        let meshID = this.lookupMeshID(model);\n        let [models, materials] = [this.getInstancesAsModels(meshID), this.getPBRMaterials(meshID)];\n        let armature = this.getArmature(model);\n        let res = new PBRModelImpl_1.PBRModelImpl(this.ctx, models, materials, armature);\n        if (typeof model === \"string\") {\n            // probably the node name\n            res.setName(model);\n        }\n        else {\n            res.setName(this.getMeshName(meshID));\n        }\n        return res;\n    }\n    getPBRInstanceFactory(init) {\n        // need multiple instances and materials\n        let meshID = this.lookupMeshID(init);\n        let [models, materials] = [this.getInstancesAsModels(meshID), this.getPBRMaterials(meshID)];\n        const armature = this.getArmature(init);\n        // queue these up under the meshID\n        let modelsInstanced = models.map((model) => {\n            let inst = new InstancedModelImpl_1.InstancedModelImpl(this.ctx, model);\n            if (typeof init === \"string\") {\n                // probably the node name\n                model.name = init;\n            }\n            else {\n                model.name = (this.getMeshName(meshID));\n            }\n            this.ctx.getGLTFLoader().registerInstancedModel(inst);\n            return inst;\n        });\n        return new PBRInstanceFactory_1.PBRInstanceFactory(this.ctx, modelsInstanced, materials);\n    }\n    texSchemaToTexture(texture, img) {\n        if (!img.bufferView) {\n            let err = \"Loader does not currently handle image URIs.\";\n            console.error(err);\n            throw Error(err);\n        }\n        let view = this.data.bufferViews[img.bufferView];\n        if (!view) {\n            let err = \"Invalid GLTF file: view specified by image schema does not exist\";\n            console.error(err);\n            throw Error(err);\n        }\n        let buffer = this.buffers[view.buffer];\n        if (!buffer) {\n            let err = \"Buffer returned undefined while attempting to create a texture from it\";\n            console.error(err);\n            throw Error(err);\n        }\n        let sampler = this.data.samplers[texture.sampler];\n        if (!sampler) {\n            let err = \"Invalid GLTF file: sampler specified by texture schema does not exist\";\n            console.error(err);\n            throw Error(err);\n        }\n        // we ultimately need the arraybuffer to gen an image\n        // delegating that responsibility to the glbuffer is not to our benefit\n        // the glbuffer replaces our \"GL BUFFERS\" (yeah everything is but whatever)\n        let arrbuf = buffer.arrayBuffer();\n        let off = view.byteOffset ? view.byteOffset : 0;\n        let imgbuf = arrbuf.slice(off, view.byteLength + off);\n        return new GLTFTexture_1.GLTFTexture(this.ctx, imgbuf, sampler, img.mimeType);\n    }\n    getInstance(prim) {\n        const inst = {};\n        inst.positions = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.POSITION);\n        inst.normals = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.NORMAL);\n        inst.texcoords = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.TEXCOORD_0);\n        inst.tangents = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.TANGENT);\n        let joint = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.JOINTS_0);\n        if (joint) {\n            inst.joints = [joint];\n        }\n        let weight = this.createAttributeFromJSON(this.data, this.buffers, prim.attributes.WEIGHTS_0);\n        if (weight) {\n            inst.weights = [weight];\n        }\n        {\n            // indices\n            let indexAccessor = this.data.accessors[prim.indices];\n            let indexView = this.data.bufferViews[indexAccessor.bufferView];\n            let buffer = this.buffers[indexView.buffer];\n            // copy buffer to indexBuffer\n            // we reuse the arrbuf object, so there's no needless duplication of data\n            // we just give it a fresh start as an element array\n            let indexBuffer = buffer.copy();\n            inst.indices = new GLIndexImpl_1.GLIndexImpl(indexBuffer, indexAccessor, indexView);\n        }\n        return inst;\n    }\n    createAttributeFromJSON(data, buffers, accessor) {\n        if (accessor === undefined) {\n            return null;\n        }\n        let ac = data.accessors[accessor];\n        let view = data.bufferViews[ac.bufferView];\n        let buffer = buffers[view.buffer];\n        return new GLAttributeImpl_1.GLAttributeImpl(buffer, view, ac);\n    }\n}\nexports.GLTFSceneImpl = GLTFSceneImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/GLTFSceneImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/InstancedModelImpl.ts":
/*!*******************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/InstancedModelImpl.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstancedModelImpl = void 0;\nconst GLBufferImpl_1 = __webpack_require__(/*! ../../gl/internal/GLBufferImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../../internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\n;\nclass InstancedModelImpl {\n    constructor(ctx, model) {\n        this.model = model;\n        this.ctx = ctx;\n        this.instances = new Map();\n        this.enabledAttributes = new Set();\n        this.attributeToBuffer = new Map();\n        this.materials = new Map();\n        this.boundMaterial = null;\n    }\n    getArmature() {\n        return this.model.getArmature();\n    }\n    setInstancedMaterial(material) {\n        this.boundMaterial = material;\n    }\n    getReadOnlyBuffer(index) {\n        let res = this.instances.get(index);\n        if (res !== null) {\n            return res.buf;\n        }\n        return null;\n    }\n    clearInstances() {\n        this.materials.clear();\n        for (let record of this.instances.values()) {\n            record.offset = 0;\n        }\n        this.enabledAttributes = new Set();\n        this.attributeToBuffer = new Map();\n    }\n    drawMat(rc, mat, instanceCount) {\n        this.logname = `${this.name}.${mat.constructor.name}`;\n        const timer = this.ctx.getGPUTimer();\n        const id = timer.startQuery();\n        try {\n            mat.prepareAttributes(this, instanceCount, rc);\n            this.model.drawInstanced(instanceCount);\n            mat.cleanUpAttributes();\n        }\n        catch (e) {\n            console.debug(\"Skipped draw due to caught error: \" + e);\n            console.debug(e);\n        }\n        finally {\n            let gl = this.ctx.getGLContext();\n            const disabledAttribs = [];\n            if (this.instances.size > 0) {\n                for (let attrib of this.enabledAttributes) {\n                    let bufIndex = this.attributeToBuffer.get(attrib);\n                    let buf = this.instances.get(bufIndex);\n                    buf.buf.disableInstancedVertexAttribute(attrib);\n                    // reset used buffers\n                    buf.offset = 0;\n                    disabledAttribs.push(attrib);\n                }\n                // disable any attribs which were used\n                for (let attrib of disabledAttribs) {\n                    this.enabledAttributes.delete(attrib);\n                    gl.disableVertexAttribArray(attrib);\n                }\n            }\n        }\n        timer.stopQueryAndLog(id, this.logname, rc.getRenderPass() === RenderContext_1.RenderPass.SHADOW ? performanceanalytics_1.RenderType.SHADOW : performanceanalytics_1.RenderType.FINAL);\n    }\n    flush(rc) {\n        if (this.materials.size > 0) {\n            for (let mat of this.materials) {\n                this.drawMat(rc, mat[0], mat[1]);\n            }\n            this.materials.clear();\n            this.materials.set(this.boundMaterial, 0);\n        }\n    }\n    bindAttribute(at, location) {\n        this.model.bindAttribute(at, location);\n    }\n    draw() {\n        this.model.draw();\n    }\n    drawInstanced() {\n        let cur = this.materials.get(this.boundMaterial);\n        if (cur === undefined) {\n            cur = 0;\n        }\n        this.materials.set(this.boundMaterial, ++cur);\n    }\n    drawManyInstanced(count) {\n        let cur = this.materials.get(this.boundMaterial);\n        if (cur === undefined) {\n            cur = 0;\n        }\n        this.materials.set(this.boundMaterial, cur + count);\n    }\n    appendInstanceData(index, data, ...args) {\n        let buf = this.instances.get(index);\n        if (!buf) {\n            buf = {\n                buf: new GLBufferImpl_1.GLBufferImpl(this.ctx, 32768),\n                offset: 0\n            };\n            this.instances.set(index, buf);\n        }\n        if (typeof data === \"number\") {\n            buf.buf.setFloat32(buf.offset, data, true);\n            buf.offset += 4;\n        }\n        else {\n            buf.buf.setFloatArray(buf.offset, data, true);\n            buf.offset += (4 * data.length);\n        }\n        if (args !== undefined) {\n            // accept any number of valid data args, iterate over in a priv\n            for (let arg of args) {\n                buf.buf.setFloat32(buf.offset, arg, true);\n                buf.offset += 4;\n            }\n        }\n    }\n    instanceAttribPointer(index, attribLocation, components, type, normalize, stride, offset) {\n        if (!this.instances.has(index)) {\n            let err = \"Attempted to point to unmapped index\";\n            console.error(err);\n            console.log(index);\n            throw Error(err);\n        }\n        let buf = this.instances.get(index).buf;\n        buf.bindToInstancedVertexAttribute(attribLocation, components, type, normalize, stride, offset, 1);\n        this.enabledAttributes.add(attribLocation);\n        this.attributeToBuffer.set(attribLocation, index);\n    }\n}\nexports.InstancedModelImpl = InstancedModelImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/InstancedModelImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/ModelImpl.ts":
/*!**********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/ModelImpl.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelImpl = void 0;\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nconst Model_1 = __webpack_require__(/*! ../../model/Model */ \"./hingler-party/client/ts/engine/model/Model.ts\");\n// instanced pathway: draw all instances in one go?\n// if that's the case, then tiling gets a bit weird\n// instanced rendering is not compatible with our current workflow, and cannot be used\n// in place of regular models (limitations on instancing + materials)\n// as a workaround, in order to support instancing we'll need a subclass of materials to support it\n// we'll need a completely separate workflow for instanced rendering, probably involving\n// queueing up \"draws\" by uploading attributes, etc. before finally \"flush\"ing those attributes\n// in one go\n// we'd probably construct the instanced model in a super class and manage it from there.\n// we'd have to set the model's material, instead of a material consuming a model.\n// and remember to use gl.DYNAMIC_DRAW.\n// for now though: use regular models :-)\n// TODO: reclassify as primitive -- point=1, line=2, tri=3\nclass TriangleIterator {\n    constructor(model) {\n        this.model = model;\n        this.offset = 0;\n        this.instance = 0;\n    }\n    next() {\n        // if we are not at the end of the index list: return the next index\n        // otherwise, go to the next instance\n        if (this.instance >= this.model.instances.length) {\n            return { value: null, done: true };\n        }\n        if (this.offset >= this.model.instances[this.instance].indices.count) {\n            this.instance++;\n            this.offset = 0;\n            // :(\n            if (this.instance >= this.model.instances.length) {\n                return { value: null, done: true };\n            }\n        }\n        let verts = [];\n        let inst = this.model.instances[this.instance];\n        // assuming tris\n        for (let i = 0; i < 3; i++) {\n            let ind = inst.indices.getIndex(this.offset++);\n            let pos = (inst.positions ? inst.positions.get(ind) : null);\n            let norm = (inst.normals ? inst.normals.get(ind) : null);\n            let tex = (inst.texcoords ? inst.texcoords.get(ind) : null);\n            let joint = (inst.joints ? [] : null);\n            let weight = (inst.weights ? [] : null);\n            if (inst.joints) {\n                for (let j = 0; j < inst.joints.length; j++) {\n                    joint.push(inst.joints[j].get(ind));\n                }\n            }\n            if (inst.weights) {\n                for (let j = 0; j < inst.weights.length; j++) {\n                    weight.push(inst.weights[j].get(ind));\n                }\n            }\n            let vert = {\n                position: pos,\n                normal: norm,\n                texcoord: tex,\n                joints: joint,\n                weights: weight\n            };\n            verts.push(vert);\n        }\n        // all good\n        let res = {\n            vertices: verts\n        };\n        return { value: res, done: ((this.instance === this.model.instances.length - 1) && this.offset >= this.model.instances[this.instance].indices.count) };\n    }\n}\n// export function createModelInstanceFromModelSpec(spec: GLModelSpec) {\n//   const list = spec.getAttributes();\n//   const res = {} as ModelInstance;\n//   for (let pair of list) {\n//     res.\n//   }\n// }\nclass ModelImpl extends Model_1.Model {\n    constructor(instances, armature) {\n        super();\n        this.instances = instances;\n        this.posLocation = -1;\n        this.normLocation = -1;\n        this.texLocation = -1;\n        this.tangentLocation = -1;\n        this.jointLocation = null;\n        this.weightLocation = null;\n        this.armature = (armature || null);\n    }\n    // setting armature data?\n    getArmature() {\n        return this.armature;\n    }\n    setArmature(armature) {\n        this.armature = armature;\n    }\n    [Symbol.iterator]() {\n        return new TriangleIterator(this);\n    }\n    // todo: allow arb data?\n    bindAttribute(at, ...location) {\n        switch (at) {\n            case AttributeType_1.AttributeType.POSITION:\n                this.posLocation = location[0];\n                break;\n            case AttributeType_1.AttributeType.NORMAL:\n                this.normLocation = location[0];\n                break;\n            case AttributeType_1.AttributeType.TEXCOORD:\n                this.texLocation = location[0];\n                break;\n            case AttributeType_1.AttributeType.TANGENT:\n                this.tangentLocation = location[0];\n                break;\n            case AttributeType_1.AttributeType.JOINT:\n                this.jointLocation = location;\n                break;\n            case AttributeType_1.AttributeType.WEIGHT:\n                this.weightLocation = location;\n                break;\n            default:\n                console.warn(\"noop: bindattribute received unhandled attribute type\");\n        }\n    }\n    pointToAttributes(inst) {\n        if (this.posLocation >= 0) {\n            inst.positions.pointToAttribute(this.posLocation);\n        }\n        else {\n            const err = \"position not bound on draw :)\";\n            console.error(err);\n            throw Error(err);\n        }\n        if (inst.normals && this.normLocation >= 0) {\n            inst.normals.pointToAttribute(this.normLocation);\n        }\n        else if (this.normLocation >= 0) {\n            inst.positions.setDefaultAttributeComps(this.normLocation, 3, 0, 0, 1);\n        }\n        if (inst.texcoords && this.texLocation >= 0) {\n            inst.texcoords.pointToAttribute(this.texLocation);\n        }\n        else if (this.texLocation >= 0) {\n            inst.positions.setDefaultAttributeComps(this.texLocation, 2, 0, 0);\n        }\n        if (inst.tangents && this.tangentLocation >= 0) {\n            inst.tangents.pointToAttribute(this.tangentLocation);\n        }\n        else if (this.tangentLocation >= 0) {\n            inst.positions.setDefaultAttributeComps(this.tangentLocation, 3, 1, 0, 0);\n        }\n        if (inst.joints && this.jointLocation && this.jointLocation.length > 0) {\n            for (let i = 0; inst.joints && this.jointLocation && i < this.jointLocation.length && i < inst.joints.length; i++) {\n                inst.joints[i].pointToAttribute(this.jointLocation[i]);\n            }\n        }\n        else if (this.jointLocation && this.jointLocation.length > 0) {\n            for (let i = 0; i < this.jointLocation.length; i++) {\n                inst.positions.setDefaultAttributeComps(this.jointLocation[i], 4, 0, 0, 0, 0);\n            }\n        }\n        if (inst.weights && this.weightLocation && this.weightLocation.length > 0) {\n            for (let i = 0; inst.weights && this.weightLocation && i < this.weightLocation.length && i < inst.weights.length; i++) {\n                inst.weights[i].pointToAttribute(this.weightLocation[i]);\n            }\n        }\n        else if (this.weightLocation && this.weightLocation.length > 0) {\n            for (let i = 0; i < this.weightLocation.length; i++) {\n                inst.positions.setDefaultAttributeComps(this.weightLocation[i], 4, 0, 0, 0, 0);\n            }\n        }\n    }\n    disableIndices(inst) {\n        inst.positions.disableAttribute();\n        if (inst.normals) {\n            inst.normals.disableAttribute();\n        }\n        if (inst.texcoords) {\n            inst.texcoords.disableAttribute();\n        }\n        if (inst.tangents) {\n            inst.tangents.disableAttribute();\n        }\n        if (inst.joints) {\n            for (let joint of inst.joints) {\n                joint.disableAttribute();\n            }\n        }\n        if (inst.weights) {\n            for (let weight of inst.weights) {\n                weight.disableAttribute();\n            }\n        }\n    }\n    resetAttributes() {\n        this.posLocation = -1;\n        this.normLocation = -1;\n        this.texLocation = -1;\n        this.tangentLocation = -1;\n        this.jointLocation = [];\n        this.weightLocation = [];\n    }\n    drawInstanced(count) {\n        // attributes are already bound\n        // just do the same thing\n        for (let inst of this.instances) {\n            this.pointToAttributes(inst);\n            inst.indices.drawInstanced(count);\n            this.disableIndices(inst);\n        }\n        // disable only on last, we're enabling the same attribs each time.\n        this.resetAttributes();\n    }\n    draw() {\n        for (let inst of this.instances) {\n            this.pointToAttributes(inst);\n            inst.indices.draw();\n            this.disableIndices(inst);\n        }\n    }\n}\nexports.ModelImpl = ModelImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/ModelImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/PBRModelImpl.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/PBRModelImpl.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRModelImpl = void 0;\nconst ShadowNoTextureMaterial_1 = __webpack_require__(/*! ../../material/ShadowNoTextureMaterial */ \"./hingler-party/client/ts/engine/material/ShadowNoTextureMaterial.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst PBRModel_1 = __webpack_require__(/*! ../../model/PBRModel */ \"./hingler-party/client/ts/engine/model/PBRModel.ts\");\nclass PBRModelImpl extends PBRModel_1.PBRModel {\n    // swap to PBR\n    constructor(ctx, instances, mats, armature) {\n        super();\n        if (instances.length !== mats.length) {\n            throw Error(\"PBR model should contain one material per instance!\");\n        }\n        this.instances = instances;\n        this.mats = mats;\n        this.shadowTex = new ShadowNoTextureMaterial_1.ShadowNoTextureMaterial(ctx);\n        this.name = undefined;\n        this.armature = (armature || null);\n        for (let model of instances) {\n            // ensure all models share the same base armature\n            model.setArmature(this.armature);\n        }\n    }\n    setName(name) {\n        this.name = name;\n    }\n    getArmature() {\n        return this.armature;\n    }\n    bindAttribute(at, index) {\n        for (let model of this.instances) {\n            model.bindAttribute(at, index);\n        }\n    }\n    draw() {\n        for (let model of this.instances) {\n            model.draw();\n        }\n    }\n    drawPBR(modelMatrix, rc) {\n        if (rc.getRenderPass() === RenderContext_1.RenderPass.SHADOW) {\n            return this.drawPBRShadow(modelMatrix, rc);\n        }\n        // in order to use materials: we need to know where the model is, and where the camera is.\n        let info = rc.getActiveCameraInfo();\n        for (let i = 0; i < this.instances.length; i++) {\n            let mat = this.mats[i];\n            let mod = this.instances[i];\n            mat.cameraPos = info.cameraPosition;\n            mat.modelMat = modelMatrix;\n            mat.vpMat = info.vpMatrix;\n            mat.setSpotLight(rc.getSpotLightInfo());\n            const skybox = rc.getSkybox();\n            mat.setSkybox(skybox);\n            mat.drawMaterial(mod);\n        }\n    }\n    drawPBRShadow(modelMatrix, rc) {\n        let info = rc.getActiveCameraInfo();\n        for (let i = 0; i < this.instances.length; i++) {\n            let mod = this.instances[i];\n            this.shadowTex.modelMat = modelMatrix;\n            this.shadowTex.shadowMat = info.vpMatrix;\n            this.shadowTex.drawMaterial(mod);\n        }\n    }\n}\nexports.PBRModelImpl = PBRModelImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/PBRModelImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts":
/*!**********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLTFSamplerInterpolation = exports.GLTFAccessorType = exports.GLTFTargetPathType = void 0;\n;\n;\n;\n;\n;\n;\n;\n;\nvar GLTFTargetPathType;\n(function (GLTFTargetPathType) {\n    GLTFTargetPathType[\"TRANSLATION\"] = \"translation\";\n    GLTFTargetPathType[\"ROTATION\"] = \"rotation\";\n    GLTFTargetPathType[\"SCALE\"] = \"scale\";\n})(GLTFTargetPathType = exports.GLTFTargetPathType || (exports.GLTFTargetPathType = {}));\nvar GLTFAccessorType;\n(function (GLTFAccessorType) {\n    GLTFAccessorType[\"SCALAR\"] = \"SCALAR\";\n    GLTFAccessorType[\"VEC2\"] = \"VEC2\";\n    GLTFAccessorType[\"VEC3\"] = \"VEC3\";\n    GLTFAccessorType[\"VEC4\"] = \"VEC4\";\n})(GLTFAccessorType = exports.GLTFAccessorType || (exports.GLTFAccessorType = {}));\nvar GLTFSamplerInterpolation;\n(function (GLTFSamplerInterpolation) {\n    GLTFSamplerInterpolation[\"LINEAR\"] = \"LINEAR\";\n})(GLTFSamplerInterpolation = exports.GLTFSamplerInterpolation || (exports.GLTFSamplerInterpolation = {}));\n;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/loaders/internal/gltfTypes.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer.ts":
/*!************************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer.ts ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CalculateNormalMatrixFromBuffer = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nfunction CalculateNormalMatrixFromBuffer(src, dst, instances, offset, stride) {\n    let step = (stride === 0 ? 64 : stride);\n    if (src.size() < instances * step + offset) {\n        const warning = \"Buffer is not large enough to hold described number of matrices.\";\n        console.warn(warning);\n    }\n    let offsetSrc = offset;\n    let offsetDst = 0;\n    let normSpace = gl_matrix_1.mat3.create();\n    for (let i = 0; i < instances; i++) {\n        let mat = src.getFloat32Array(offset, 16);\n        offset += step;\n        gl_matrix_1.mat3.fromMat4(normSpace, mat);\n        gl_matrix_1.mat3.transpose(normSpace, normSpace);\n        gl_matrix_1.mat3.invert(normSpace, normSpace);\n        dst.setFloatArray(offsetDst, normSpace);\n        offsetDst += 36;\n    }\n}\nexports.CalculateNormalMatrixFromBuffer = CalculateNormalMatrixFromBuffer;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/ColorDisplay.ts":
/*!*****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/ColorDisplay.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorDisplay = void 0;\nconst TextureDisplay_1 = __webpack_require__(/*! ./TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nclass ColorDisplay extends TextureDisplay_1.TextureDisplay {\n    constructor(ctx, texture) {\n        super(ctx, (0, getEnginePath_1.getEnginePath)(\"engine/glsl/texturexfer/texturexfer.vert\"), (0, getEnginePath_1.getEnginePath)(\"engine/glsl/texturexfer/texturexfer.frag\"), texture);\n    }\n    prepareUniforms() {\n        // basic texture xfer is what we want\n    }\n}\nexports.ColorDisplay = ColorDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/ColorDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/InstancedShadowMaterial.ts":
/*!****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/InstancedShadowMaterial.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstancedShadowMaterial = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nconst GLProgramWrap_1 = __webpack_require__(/*! ../gl/internal/GLProgramWrap */ \"./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nclass InstancedShadowMaterial {\n    constructor(ctx) {\n        this.modelMatIndex = -1;\n        this.ctx = ctx;\n        this.prog = null;\n        this.progWrap = null;\n        this.shadow_matrix = gl_matrix_1.mat4.identity(gl_matrix_1.mat4.create());\n        // revise engine paths to use \"engine\"\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/shadownotexture/shadownotexture_instanced.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/shadownotexture/shadownotexture.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this))\n            .catch(console.error.bind(console));\n    }\n    configureProgram(prog) {\n        let gl = this.ctx.getGLContext();\n        this.prog = prog;\n        this.progWrap = new GLProgramWrap_1.GLProgramWrap(gl, this.prog);\n        this.locs = {\n            shadow_matrix: gl.getUniformLocation(prog, \"shadow_matrix\")\n        };\n        this.attribs = {\n            position: gl.getAttribLocation(prog, \"position\"),\n            model_matrix: gl.getAttribLocation(prog, \"model_matrix\")\n        };\n    }\n    setModelMatrixIndex(index) {\n        this.modelMatIndex = index;\n    }\n    prepareAttributes(model, instances, rc) {\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        if (this.prog === null) {\n            const err = \"Shadow material not yet compiled -- cannot prepare!\";\n            throw Error(err);\n        }\n        if (this.prog !== null) {\n            wrap.useProgram(this.prog);\n            gl.uniformMatrix4fv(this.locs.shadow_matrix, false, rc.getActiveCameraInfo().vpMatrix);\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, this.attribs.position);\n            for (let i = 0; i < 4; i++) {\n                let loc = this.attribs.model_matrix + i;\n                let byteOffset = i * 16;\n                model.instanceAttribPointer(this.modelMatIndex, loc, 4, gl.FLOAT, false, 64, byteOffset);\n            }\n        }\n    }\n    cleanUpAttributes() {\n    }\n}\nexports.InstancedShadowMaterial = InstancedShadowMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/InstancedShadowMaterial.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/PBRMaterialImpl.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/PBRMaterialImpl.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// todo: replace instances of WebGLProgram with a version which keeps track of uniform locations\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRMaterialImpl = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nconst ColorCubemap_1 = __webpack_require__(/*! ../gl/ColorCubemap */ \"./hingler-party/client/ts/engine/gl/ColorCubemap.ts\");\nconst GLBufferImpl_1 = __webpack_require__(/*! ../gl/internal/GLBufferImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts\");\nconst GLProgramWrap_1 = __webpack_require__(/*! ../gl/internal/GLProgramWrap */ \"./hingler-party/client/ts/engine/gl/internal/GLProgramWrap.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst CalculateNormalMatrixFromBuffer_1 = __webpack_require__(/*! ./CalculateNormalMatrixFromBuffer */ \"./hingler-party/client/ts/engine/material/CalculateNormalMatrixFromBuffer.ts\");\nconst TextureDummy_1 = __webpack_require__(/*! ./TextureDummy */ \"./hingler-party/client/ts/engine/material/TextureDummy.ts\");\n// todo: merge this and instanced?\n// create a single unified material which supports instancing\nclass PBRMaterialImpl {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.placeholder = new TextureDummy_1.TextureDummy(ctx);\n        this.placeholderNorm = new TextureDummy_1.TextureDummy(ctx);\n        this.placeholderARM = new TextureDummy_1.TextureDummy(ctx);\n        this.placeholderEmission = new TextureDummy_1.TextureDummy(ctx);\n        this.placeholderParallax = new TextureDummy_1.TextureDummy(ctx);\n        this.vpMat = gl_matrix_1.mat4.create();\n        this.modelMat = gl_matrix_1.mat4.create();\n        this.normal = null;\n        this.color = null;\n        this.heightMap = null;\n        this.irridance = null;\n        this.specular = null;\n        this.brdf = null;\n        this.colorFactor = gl_matrix_1.vec4.create();\n        this.metalRough = null;\n        this.metalFactor = 1.0;\n        this.roughFactor = 1.0;\n        this.heightScale = 0.1;\n        this.emissionFactor = gl_matrix_1.vec4.create();\n        this.emission = null;\n        this.placeholderCube = new ColorCubemap_1.ColorCubemap(ctx, 8);\n        this.placeholderCubeSpec = new ColorCubemap_1.ColorCubemap(ctx, 8);\n        this.placeholderBRDF = new TextureDummy_1.TextureDummy(ctx);\n        this.placeholderCubeSub = new ColorCubemap_1.ColorCubemap(ctx, 8);\n        this.placeholderCubeSpecSub = new ColorCubemap_1.ColorCubemap(ctx, 8);\n        this.spotPlaceholders = [];\n        for (let i = 0; i < 4; i++) {\n            this.spotPlaceholders.push(new TextureDummy_1.TextureDummy(ctx));\n        }\n        this.skyboxes = [];\n        gl_matrix_1.vec4.zero(this.emissionFactor);\n        this.cameraPos = gl_matrix_1.vec3.create();\n        ctx.getGLExtension(\"EXT_shader_texture_lod\");\n        ctx.getGLExtension(\"OES_standard_derivatives\");\n        this.modelMatrixIndex = -1;\n        let gl = ctx.getGLContext();\n        this.normalBuffer = new GLBufferImpl_1.GLBufferImpl(ctx, undefined, gl.DYNAMIC_DRAW);\n        // note: make it obvious that the shader returned is the same?\n        // note: statics are going to conflict with one another\n        if (PBRMaterialImpl.progLoading === false) {\n            PBRMaterialImpl.progLoading = true;\n            new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n                .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/pbr/pbr.vert\"))\n                .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/pbr/pbr.frag\"))\n                .build()\n                .then(this.configureProgram.bind(this));\n        }\n    }\n    configureProgram(prog) {\n        PBRMaterialImpl.prog = prog;\n        let gl = this.ctx.getGLContext();\n        if (PBRMaterialImpl.locs === null) {\n            PBRMaterialImpl.locs = {\n                modelMat: gl.getUniformLocation(prog, \"model_matrix\"),\n                vpMat: gl.getUniformLocation(prog, \"vp_matrix\"),\n                normalMat: gl.getUniformLocation(prog, \"normal_matrix\"),\n                lightCount: gl.getUniformLocation(prog, \"spotlightCount\"),\n                jointMatrix: [],\n                jointMatrixNormal: [],\n                useSkeletalAnimation: gl.getUniformLocation(prog, \"useSkeletalAnimation\"),\n                lightCountNoShadow: gl.getUniformLocation(prog, \"spotlightCount_no_shadow\"),\n                ambientCount: gl.getUniformLocation(prog, \"ambientCount\"),\n                cameraPos: gl.getUniformLocation(prog, \"camera_pos\"),\n                texAlbedo: gl.getUniformLocation(prog, \"tex_albedo\"),\n                texNorm: gl.getUniformLocation(prog, \"tex_norm\"),\n                texMetalRough: gl.getUniformLocation(prog, \"tex_metal_rough\"),\n                texEmission: gl.getUniformLocation(prog, \"tex_emission\"),\n                texParallax: gl.getUniformLocation(prog, \"tex_parallax\"),\n                parallaxHeightScale: gl.getUniformLocation(prog, \"parallax_heightscale\"),\n                useAlbedo: gl.getUniformLocation(prog, \"use_albedo\"),\n                useNorm: gl.getUniformLocation(prog, \"use_norm\"),\n                useRough: gl.getUniformLocation(prog, \"use_metal_rough\"),\n                useEmission: gl.getUniformLocation(prog, \"use_emission\"),\n                useParallax: gl.getUniformLocation(prog, \"use_parallax\"),\n                albedoDef: gl.getUniformLocation(prog, \"color_factor\"),\n                roughDef: gl.getUniformLocation(prog, \"rough_factor\"),\n                metalDef: gl.getUniformLocation(prog, \"metal_factor\"),\n                emissionFactor: gl.getUniformLocation(prog, \"emission_factor\"),\n                useAttribute: gl.getUniformLocation(prog, \"is_instanced\"),\n                irridance: gl.getUniformLocation(prog, \"irridance\"),\n                specular: gl.getUniformLocation(prog, \"specular\"),\n                brdf: gl.getUniformLocation(prog, \"brdf\"),\n                skyboxIntensity: gl.getUniformLocation(prog, \"skyboxIntensity\"),\n                specSize: gl.getUniformLocation(prog, \"specSize\"),\n                useIrridance: gl.getUniformLocation(prog, \"useIrridance\"),\n                irridance_l: gl.getUniformLocation(prog, \"irridance_l\"),\n                specular_l: gl.getUniformLocation(prog, \"specular_l\"),\n                specSize_l: gl.getUniformLocation(prog, \"specSize_l\"),\n                skyboxIntensity_l: gl.getUniformLocation(prog, \"skyboxIntensity_l\"),\n                useIrridance_l: gl.getUniformLocation(prog, \"useIrridance_l\")\n            };\n        }\n        PBRMaterialImpl.attribs = {\n            pos: gl.getAttribLocation(prog, \"position\"),\n            norm: gl.getAttribLocation(prog, \"normal\"),\n            tex: gl.getAttribLocation(prog, \"texcoord\"),\n            tan: gl.getAttribLocation(prog, \"tangent\"),\n            joints: gl.getAttribLocation(prog, \"joints\"),\n            weights: gl.getAttribLocation(prog, \"weights\"),\n            modelMat: gl.getAttribLocation(prog, \"a_model_matrix\"),\n            normMat: gl.getAttribLocation(prog, \"a_normal_matrix\")\n        };\n        for (let i = 0; i < 32; i++) {\n            PBRMaterialImpl.locs.jointMatrix.push(gl.getUniformLocation(prog, `jointMatrix[${i}]`));\n            PBRMaterialImpl.locs.jointMatrixNormal.push(gl.getUniformLocation(prog, `jointMatrixNormal[${i}]`));\n        }\n        PBRMaterialImpl.progWrap = new GLProgramWrap_1.GLProgramWrap(gl, PBRMaterialImpl.prog);\n        PBRMaterialImpl.spotLightUniforms = [];\n        PBRMaterialImpl.spotLightUniformsNoShadow = [];\n        for (let i = 0; i < 8; i++) {\n            let uni = {};\n            const ext = (i % 2 === 1 ? \"_no_shadow\" : \"\");\n            const flad = Math.floor(i / 2);\n            uni.position = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].position`);\n            uni.direction = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].dir`);\n            uni.fov = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].fov`);\n            uni.falloff = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].falloffRadius`);\n            uni.intensity = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].intensity`);\n            uni.color = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].color`);\n            uni.transform = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].lightTransform`);\n            uni.shadowSize = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].shadowSize`);\n            if (i % 2 === 0) {\n                uni.shadowtex = gl.getUniformLocation(prog, `texture_spotlight[${flad}]`);\n            }\n            uni.atten_const = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].a.atten_const`);\n            uni.atten_linear = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].a.atten_linear`);\n            uni.atten_quad = gl.getUniformLocation(prog, `spotlight${ext}[${flad}].a.atten_quad`);\n            (i % 2 === 0 ? PBRMaterialImpl.spotLightUniforms : PBRMaterialImpl.spotLightUniformsNoShadow).push(uni);\n        }\n    }\n    bindSpotLightStruct(s, loc) {\n        const gl = this.ctx.getGLContext();\n        gl.uniform3fv(loc.position, s.position);\n        gl.uniform3fv(loc.direction, s.dir);\n        gl.uniform1f(loc.fov, s.fov);\n        gl.uniform1f(loc.falloff, s.falloffRadius);\n        gl.uniform1f(loc.intensity, s.intensity);\n        gl.uniform4fv(loc.color, s.color);\n        if (s.hasShadow()) {\n            s.shadowTex.bindToUniform(loc.shadowtex, s.getShadowTextureIndex());\n        }\n        gl.uniformMatrix4fv(loc.transform, false, s.lightTransform);\n        gl.uniform2fv(loc.shadowSize, s.shadowSize);\n        gl.uniform1f(loc.atten_const, s.attenuation.atten_const);\n        gl.uniform1f(loc.atten_linear, s.attenuation.atten_linear);\n        gl.uniform1f(loc.atten_quad, s.attenuation.atten_quad);\n    }\n    setSpotLight(light) {\n        this.spot = light;\n    }\n    setAmbientLight(light) {\n        this.amb = light;\n    }\n    setSkybox(skybox) {\n        this.skyboxes = skybox;\n    }\n    setModelMatrixIndex(index) {\n        this.modelMatrixIndex = index;\n    }\n    calculateNormalMatrixFromBuffer(buf, instances) {\n        (0, CalculateNormalMatrixFromBuffer_1.CalculateNormalMatrixFromBuffer)(buf, this.normalBuffer, instances, 0, 0);\n    }\n    prepareAttributes(model, instances, rc) {\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        // there's some setup that happens here which breaks the shadow renderer, when the prog fails\n        // to compile the shadow view looks just fine so i will have to investigate further :(\n        // shadow bug somewhere ... not sure what\n        // todo: find and resolve the shadow bug ... whatever it is\n        if (PBRMaterialImpl.prog !== null) {\n            wrap.useProgram(PBRMaterialImpl.prog);\n            this.setSpotLight(rc.getSpotLightInfo());\n            this.setAmbientLight(rc.getAmbientLightInfo());\n            let info = rc.getActiveCameraInfo();\n            gl.uniformMatrix4fv(PBRMaterialImpl.locs.vpMat, false, info.vpMatrix);\n            const skyboxList = rc.getSkybox();\n            if (skyboxList.length > 0 && skyboxList[0].irridance !== null && skyboxList[0].specular !== null && skyboxList[0].brdf !== null) {\n                const skybox = skyboxList[0];\n                skybox.irridance.bindToUniform(PBRMaterialImpl.locs.irridance, 8);\n                skybox.specular.bindToUniform(PBRMaterialImpl.locs.specular, 9);\n                skybox.brdf.bindToUniform(PBRMaterialImpl.locs.brdf, 10);\n                wrap.uniform1f(PBRMaterialImpl.locs.specSize, skybox.specular.dims);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity, skybox.intensity);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance, 1);\n            }\n            else {\n                // need more cubes!!!!!\n                this.placeholderCube.bindToUniform(PBRMaterialImpl.locs.irridance, 8);\n                this.placeholderCubeSpec.bindToUniform(PBRMaterialImpl.locs.specular, 9);\n                this.placeholderBRDF.bindToUniform(PBRMaterialImpl.locs.brdf, 10);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity, 0.0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance, 0);\n            }\n            if (skyboxList.length > 1 && skyboxList[1].irridance !== null && skyboxList[1].specular !== null && skyboxList[1].brdf !== null) {\n                const skybox = skyboxList[1];\n                skybox.irridance.bindToUniform(PBRMaterialImpl.locs.irridance_l, 11);\n                skybox.specular.bindToUniform(PBRMaterialImpl.locs.specular_l, 12);\n                wrap.uniform1f(PBRMaterialImpl.locs.specSize_l, skybox.specular.dims);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity_l, skybox.intensity);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance_l, 1);\n            }\n            else {\n                // need more cubes!!!!!\n                this.placeholderCubeSub.bindToUniform(PBRMaterialImpl.locs.irridance_l, 11);\n                this.placeholderCubeSpecSub.bindToUniform(PBRMaterialImpl.locs.specular_l, 12);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity_l, 0.0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance_l, 0);\n            }\n            let shadowSpot = 0;\n            let noShadowSpot = 0;\n            if (this.spot) {\n                for (let i = 0; i < this.spot.length; i++) {\n                    if (this.spot[i].hasShadow() && shadowSpot < 4) {\n                        this.spot[i].setShadowTextureIndex(shadowSpot + 4);\n                        this.bindSpotLightStruct(this.spot[i], PBRMaterialImpl.spotLightUniforms[shadowSpot]);\n                        shadowSpot++;\n                    }\n                    else {\n                        this.bindSpotLightStruct(this.spot[i], PBRMaterialImpl.spotLightUniformsNoShadow[noShadowSpot]);\n                        noShadowSpot++;\n                    }\n                }\n            }\n            for (let i = shadowSpot; i < 4; i++) {\n                this.spotPlaceholders[i].bindToUniform(PBRMaterialImpl.spotLightUniforms[i].shadowtex, i + 4);\n            }\n            wrap.uniform1i(PBRMaterialImpl.locs.lightCount, shadowSpot);\n            wrap.uniform1i(PBRMaterialImpl.locs.lightCountNoShadow, noShadowSpot);\n            if (this.amb) {\n                for (let i = 0; i < this.amb.length && i < 4; i++) {\n                    this.amb[i].bindToUniformByName(PBRMaterialImpl.progWrap, `ambient[${i}]`);\n                }\n                wrap.uniform1i(PBRMaterialImpl.locs.ambientCount, this.amb.length);\n            }\n            else {\n                wrap.uniform1i(PBRMaterialImpl.locs.ambientCount, 0);\n            }\n            gl.uniform3fv(PBRMaterialImpl.locs.cameraPos, info.cameraPosition);\n            if (this.color === null) {\n                this.placeholder.bindToUniform(PBRMaterialImpl.locs.texAlbedo, 0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useAlbedo, 0);\n            }\n            else { // this.color instanceof Texture*\n                this.color.bindToUniform(PBRMaterialImpl.locs.texAlbedo, 0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useAlbedo, 1);\n            }\n            gl.uniform4fv(PBRMaterialImpl.locs.albedoDef, this.colorFactor);\n            wrap.uniform1i(PBRMaterialImpl.locs.useAttribute, 1);\n            if (this.normal === null) {\n                this.placeholderNorm.bindToUniform(PBRMaterialImpl.locs.texNorm, 1);\n                wrap.uniform1i(PBRMaterialImpl.locs.useNorm, 0);\n            }\n            else {\n                this.normal.bindToUniform(PBRMaterialImpl.locs.texNorm, 1);\n                wrap.uniform1i(PBRMaterialImpl.locs.useNorm, 1);\n            }\n            if (this.metalRough === null) {\n                this.placeholderARM.bindToUniform(PBRMaterialImpl.locs.texMetalRough, 2);\n                wrap.uniform1i(PBRMaterialImpl.locs.useRough, 0);\n            }\n            else {\n                this.metalRough.bindToUniform(PBRMaterialImpl.locs.texMetalRough, 2);\n                wrap.uniform1i(PBRMaterialImpl.locs.useRough, 1);\n            }\n            if (this.emission === null) {\n                this.placeholderEmission.bindToUniform(PBRMaterialImpl.locs.texEmission, 3);\n                wrap.uniform1i(PBRMaterialImpl.locs.useEmission, 0);\n            }\n            else {\n                this.emission.bindToUniform(PBRMaterialImpl.locs.texEmission, 3);\n                wrap.uniform1i(PBRMaterialImpl.locs.useEmission, 1);\n            }\n            wrap.uniform1f(PBRMaterialImpl.locs.parallaxHeightScale, this.heightScale);\n            if (this.heightMap === null) {\n                wrap.uniform1i(PBRMaterialImpl.locs.useParallax, 0);\n                this.placeholderParallax.bindToUniform(PBRMaterialImpl.locs.texParallax, 4);\n            }\n            else {\n                wrap.uniform1i(PBRMaterialImpl.locs.useParallax, 1);\n                this.heightMap.bindToUniform(PBRMaterialImpl.locs.texParallax, 4);\n            }\n            wrap.uniform1f(PBRMaterialImpl.locs.roughDef, this.roughFactor);\n            wrap.uniform1f(PBRMaterialImpl.locs.metalDef, this.metalFactor);\n            gl.uniform4fv(PBRMaterialImpl.locs.emissionFactor, this.emissionFactor);\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, PBRMaterialImpl.attribs.pos);\n            model.bindAttribute(AttributeType_1.AttributeType.NORMAL, PBRMaterialImpl.attribs.norm);\n            model.bindAttribute(AttributeType_1.AttributeType.TEXCOORD, PBRMaterialImpl.attribs.tex);\n            model.bindAttribute(AttributeType_1.AttributeType.TANGENT, PBRMaterialImpl.attribs.tan);\n            if (model.getArmature()) {\n                wrap.uniform1i(PBRMaterialImpl.locs.useSkeletalAnimation, 1);\n                const bones = model.getArmature().getJointMatrices();\n                const bonesNormal = model.getArmature().getJointNormalMatrices();\n                for (let i = 0; i < bones.length && i < 32; i++) {\n                    gl.uniformMatrix4fv(PBRMaterialImpl.locs.jointMatrix[i], false, bones[i]);\n                    gl.uniformMatrix3fv(PBRMaterialImpl.locs.jointMatrixNormal[i], false, bonesNormal[i]);\n                }\n                model.bindAttribute(AttributeType_1.AttributeType.JOINT, PBRMaterialImpl.attribs.joints);\n                model.bindAttribute(AttributeType_1.AttributeType.WEIGHT, PBRMaterialImpl.attribs.weights);\n            }\n            else {\n                wrap.uniform1i(PBRMaterialImpl.locs.useSkeletalAnimation, 0);\n            }\n            for (let i = 0; i < 4; i++) {\n                let loc = PBRMaterialImpl.attribs.modelMat + i;\n                let byteOffset = i * 16;\n                model.instanceAttribPointer(this.modelMatrixIndex, loc, 4, gl.FLOAT, false, 64, byteOffset);\n            }\n            let modelmats = model.getReadOnlyBuffer(this.modelMatrixIndex);\n            // TODO: allow this field to be initialized externally?\n            this.calculateNormalMatrixFromBuffer(modelmats, instances);\n            for (let i = 0; i < 3; i++) {\n                let loc = PBRMaterialImpl.attribs.normMat + i;\n                let byteOffset = i * 12;\n                this.normalBuffer.bindToInstancedVertexAttribute(loc, 3, gl.FLOAT, false, 36, byteOffset);\n            }\n        }\n    }\n    cleanUpAttributes() {\n        for (let i = 0; i < 3; i++) {\n            this.normalBuffer.disableInstancedVertexAttribute(PBRMaterialImpl.attribs.normMat + i);\n        }\n    }\n    drawMaterial(model) {\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        if (PBRMaterialImpl.prog !== null) {\n            wrap.useProgram(PBRMaterialImpl.prog);\n            let normalMat = gl_matrix_1.mat3.create();\n            normalMat = gl_matrix_1.mat3.fromMat4(normalMat, this.modelMat);\n            normalMat = gl_matrix_1.mat3.transpose(normalMat, normalMat);\n            normalMat = gl_matrix_1.mat3.invert(normalMat, normalMat);\n            gl.uniformMatrix4fv(PBRMaterialImpl.locs.modelMat, false, this.modelMat);\n            gl.uniformMatrix4fv(PBRMaterialImpl.locs.vpMat, false, this.vpMat);\n            gl.uniformMatrix3fv(PBRMaterialImpl.locs.normalMat, false, normalMat);\n            let useSkyboxMain = false;\n            if (this.skyboxes.length > 0) {\n                const skybox = this.skyboxes[0];\n                if (skybox.irridance !== null && skybox.specular !== null && skybox.brdf !== null) {\n                    skybox.irridance.bindToUniform(PBRMaterialImpl.locs.irridance, 8);\n                    skybox.specular.bindToUniform(PBRMaterialImpl.locs.specular, 9);\n                    skybox.brdf.bindToUniform(PBRMaterialImpl.locs.brdf, 10);\n                    wrap.uniform1f(PBRMaterialImpl.locs.specSize, skybox.specular.dims);\n                    wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity, skybox.intensity);\n                    wrap.uniform1i(PBRMaterialImpl.locs.useIrridance, 1);\n                    useSkyboxMain = true;\n                }\n            }\n            if (!useSkyboxMain) {\n                this.placeholderCube.bindToUniform(PBRMaterialImpl.locs.irridance, 8);\n                this.placeholderCubeSpec.bindToUniform(PBRMaterialImpl.locs.specular, 9);\n                this.placeholderBRDF.bindToUniform(PBRMaterialImpl.locs.brdf, 10);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity, 0.0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance, 0);\n            }\n            let useSkyboxSub = false;\n            if (this.skyboxes.length > 1) {\n                const skybox = this.skyboxes[1];\n                if (skybox.irridance !== null && skybox.specular !== null && skybox.brdf !== null) {\n                    skybox.irridance.bindToUniform(PBRMaterialImpl.locs.irridance_l, 11);\n                    skybox.specular.bindToUniform(PBRMaterialImpl.locs.specular_l, 12);\n                    wrap.uniform1f(PBRMaterialImpl.locs.specSize_l, skybox.specular.dims);\n                    wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity_l, skybox.intensity);\n                    wrap.uniform1i(PBRMaterialImpl.locs.useIrridance_l, 1);\n                    useSkyboxSub = true;\n                }\n            }\n            if (!useSkyboxSub) {\n                this.placeholderCubeSub.bindToUniform(PBRMaterialImpl.locs.irridance_l, 11);\n                this.placeholderCubeSpecSub.bindToUniform(PBRMaterialImpl.locs.specular_l, 12);\n                wrap.uniform1f(PBRMaterialImpl.locs.skyboxIntensity_l, 0.0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useIrridance_l, 0);\n            }\n            let shadowSpot = 0;\n            let noShadowSpot = 0;\n            if (this.spot) {\n                for (let i = 0; i < this.spot.length; i++) {\n                    if (this.spot[i].hasShadow() && shadowSpot < 4) {\n                        this.spot[i].setShadowTextureIndex(shadowSpot + 4);\n                        this.bindSpotLightStruct(this.spot[i], PBRMaterialImpl.spotLightUniforms[shadowSpot]);\n                        shadowSpot++;\n                    }\n                    else {\n                        this.bindSpotLightStruct(this.spot[i], PBRMaterialImpl.spotLightUniformsNoShadow[noShadowSpot]);\n                        noShadowSpot++;\n                    }\n                }\n            }\n            for (let i = shadowSpot; i < 4; i++) {\n                this.spotPlaceholders[i].bindToUniform(PBRMaterialImpl.spotLightUniforms[i].shadowtex, i + 4);\n            }\n            wrap.uniform1i(PBRMaterialImpl.locs.lightCount, shadowSpot);\n            wrap.uniform1i(PBRMaterialImpl.locs.lightCountNoShadow, noShadowSpot);\n            gl.uniform3fv(PBRMaterialImpl.locs.cameraPos, this.cameraPos);\n            if (!this.color) {\n                this.placeholder.bindToUniform(PBRMaterialImpl.locs.texAlbedo, 0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useAlbedo, 0);\n            }\n            else { // this.color instanceof Texture*\n                this.color.bindToUniform(PBRMaterialImpl.locs.texAlbedo, 0);\n                wrap.uniform1i(PBRMaterialImpl.locs.useAlbedo, 1);\n            }\n            gl.uniform4fv(PBRMaterialImpl.locs.albedoDef, this.colorFactor);\n            if (!this.normal) {\n                this.placeholderNorm.bindToUniform(PBRMaterialImpl.locs.texNorm, 1);\n                wrap.uniform1i(PBRMaterialImpl.locs.useNorm, 0);\n            }\n            else {\n                this.normal.bindToUniform(PBRMaterialImpl.locs.texNorm, 1);\n                wrap.uniform1i(PBRMaterialImpl.locs.useNorm, 1);\n            }\n            if (!this.metalRough) {\n                this.placeholderARM.bindToUniform(PBRMaterialImpl.locs.texMetalRough, 2);\n                wrap.uniform1i(PBRMaterialImpl.locs.useRough, 0);\n            }\n            else {\n                this.metalRough.bindToUniform(PBRMaterialImpl.locs.texMetalRough, 2);\n                wrap.uniform1i(PBRMaterialImpl.locs.useRough, 1);\n            }\n            if (this.emission === null) {\n                this.placeholderEmission.bindToUniform(PBRMaterialImpl.locs.texEmission, 3);\n                wrap.uniform1i(PBRMaterialImpl.locs.useEmission, 0);\n            }\n            else {\n                this.emission.bindToUniform(PBRMaterialImpl.locs.texEmission, 3);\n                wrap.uniform1i(PBRMaterialImpl.locs.useEmission, 1);\n            }\n            wrap.uniform1f(PBRMaterialImpl.locs.parallaxHeightScale, this.heightScale);\n            if (this.heightMap === null) {\n                wrap.uniform1i(PBRMaterialImpl.locs.useParallax, 0);\n                this.placeholderParallax.bindToUniform(PBRMaterialImpl.locs.texParallax, 4);\n            }\n            else {\n                wrap.uniform1i(PBRMaterialImpl.locs.useParallax, 1);\n                this.heightMap.bindToUniform(PBRMaterialImpl.locs.texParallax, 4);\n            }\n            wrap.uniform1f(PBRMaterialImpl.locs.roughDef, this.roughFactor);\n            wrap.uniform1f(PBRMaterialImpl.locs.metalDef, this.metalFactor);\n            gl.uniform4fv(PBRMaterialImpl.locs.emissionFactor, this.emissionFactor);\n            wrap.uniform1i(PBRMaterialImpl.locs.useAttribute, 0);\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, PBRMaterialImpl.attribs.pos);\n            model.bindAttribute(AttributeType_1.AttributeType.NORMAL, PBRMaterialImpl.attribs.norm);\n            model.bindAttribute(AttributeType_1.AttributeType.TEXCOORD, PBRMaterialImpl.attribs.tex);\n            model.bindAttribute(AttributeType_1.AttributeType.TANGENT, PBRMaterialImpl.attribs.tan);\n            if (model.getArmature()) {\n                wrap.uniform1i(PBRMaterialImpl.locs.useSkeletalAnimation, 1);\n                const bones = model.getArmature().getJointMatrices();\n                const bonesNormal = model.getArmature().getJointNormalMatrices();\n                for (let i = 0; i < bones.length && i < 32; i++) {\n                    gl.uniformMatrix4fv(PBRMaterialImpl.locs.jointMatrix[i], false, bones[i]);\n                    gl.uniformMatrix3fv(PBRMaterialImpl.locs.jointMatrixNormal[i], false, bonesNormal[i]);\n                }\n                model.bindAttribute(AttributeType_1.AttributeType.JOINT, PBRMaterialImpl.attribs.joints);\n                model.bindAttribute(AttributeType_1.AttributeType.WEIGHT, PBRMaterialImpl.attribs.weights);\n            }\n            else {\n                wrap.uniform1i(PBRMaterialImpl.locs.useSkeletalAnimation, 0);\n            }\n            model.draw();\n        }\n    }\n}\nexports.PBRMaterialImpl = PBRMaterialImpl;\n// statics are a bit iffy but :(\nPBRMaterialImpl.progWrap = null;\nPBRMaterialImpl.prog = null;\nPBRMaterialImpl.progLoading = false;\nPBRMaterialImpl.locs = null;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/PBRMaterialImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/PostProcessingFilter.ts":
/*!*************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/PostProcessingFilter.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostProcessingFilter = void 0;\nconst TextureDisplay_1 = __webpack_require__(/*! ./TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\n/**\n * Represents a filter which is applied to the final image after rendering.\n */\nclass PostProcessingFilter {\n    constructor(ctx) {\n        this.ctx = ctx;\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        this.buf = gl.createBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        gl.bufferData(gl.ARRAY_BUFFER, TextureDisplay_1.screenCoords, gl.STATIC_DRAW);\n        this.name = this.constructor.name;\n    }\n    getContext() {\n        return this.ctx;\n    }\n    /**\n     * @returns a buffer containing geometry data which covers the screen.\n     */\n    getScreenBuffer() {\n        return this.buf;\n    }\n    filterfunc(src, dst, rc) {\n        this.runFilter(src, dst, rc);\n    }\n}\nexports.PostProcessingFilter = PostProcessingFilter;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/PostProcessingFilter.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/ShadowDisplay.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/ShadowDisplay.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShadowDisplay = void 0;\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst TextureDisplay_1 = __webpack_require__(/*! ./TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nclass ShadowDisplay extends TextureDisplay_1.TextureDisplay {\n    constructor(ctx, light) {\n        super(ctx, (0, getEnginePath_1.getEnginePath)(\"engine/glsl/debug/shadowdebug.vert\"), (0, getEnginePath_1.getEnginePath)(\"engine/glsl/debug/shadowdebug.frag\"), light.getShadowTexture());\n        this.near = light.near;\n        this.far = light.far;\n        this.locsShadow = null;\n    }\n    prepareUniforms(prog) {\n        let gl = this.getContext().getGLContext();\n        if (this.locsShadow === null) {\n            this.locsShadow = {\n                near: gl.getUniformLocation(prog, \"near\"),\n                far: gl.getUniformLocation(prog, \"far\")\n            };\n        }\n        const wrap = this.getContext().getGL();\n        wrap.useProgram(prog);\n        gl.uniform1f(this.locsShadow.near, this.near);\n        gl.uniform1f(this.locsShadow.far, this.far);\n    }\n}\nexports.ShadowDisplay = ShadowDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/ShadowDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/ShadowNoTextureMaterial.ts":
/*!****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/ShadowNoTextureMaterial.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShadowNoTextureMaterial = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nclass ShadowNoTextureMaterial {\n    constructor(ctx) {\n        this.ctx = ctx,\n            this.prog = null;\n        let modelMat = gl_matrix_1.mat4.create();\n        let shadowMat = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.identity(modelMat);\n        gl_matrix_1.mat4.identity(shadowMat);\n        this.modelMat = modelMat;\n        this.shadowMat = shadowMat;\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/shadownotexture/shadownotexture.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/shadownotexture/shadownotexture.frag\"))\n            .build()\n            .then((prog) => {\n            this.prog = prog;\n            let gl = this.ctx.getGLContext();\n            this.locs = {\n                model_matrix: gl.getUniformLocation(prog, \"model_matrix\"),\n                shadow_matrix: gl.getUniformLocation(prog, \"shadow_matrix\")\n            };\n            this.attribs = {\n                position: gl.getAttribLocation(prog, \"position\")\n            };\n        })\n            .catch((err) => {\n            console.error(err);\n        });\n    }\n    drawMaterial(model) {\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        if (this.prog !== null) {\n            wrap.useProgram(this.prog);\n            gl.uniformMatrix4fv(this.locs.model_matrix, false, this.modelMat);\n            gl.uniformMatrix4fv(this.locs.shadow_matrix, false, this.shadowMat);\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, this.attribs.position);\n            model.draw();\n        }\n    }\n}\nexports.ShadowNoTextureMaterial = ShadowNoTextureMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/ShadowNoTextureMaterial.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/SkyboxMaterial.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/SkyboxMaterial.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SkyboxMaterial = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nconst ColorCubemap_1 = __webpack_require__(/*! ../gl/ColorCubemap */ \"./hingler-party/client/ts/engine/gl/ColorCubemap.ts\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\n// renders a skybox :D\nclass SkyboxMaterial {\n    constructor(ctx) {\n        this.view = gl_matrix_1.mat4.create();\n        this.persp = gl_matrix_1.mat4.create();\n        this.skyboxes = [];\n        this.prog = null;\n        this.ctx = ctx;\n        this.placeholder_l = new ColorCubemap_1.ColorCubemap(ctx, 8);\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/skybox/skybox.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/skybox/skybox.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    configureProgram(res) {\n        const gl = this.ctx.getGLContext();\n        this.prog = res;\n        this.posLoc = gl.getAttribLocation(res, \"aPosition\");\n        this.unifs = {\n            uViewmat: gl.getUniformLocation(res, \"uViewmat\"),\n            uPersmat: gl.getUniformLocation(res, \"uPersmat\"),\n            uCubemap: gl.getUniformLocation(res, \"uCubemap\"),\n            skyboxIntensity: gl.getUniformLocation(res, \"skyboxIntensity\"),\n            uCubemap_l: gl.getUniformLocation(res, \"uCubemap_l\"),\n            skyboxIntensity_l: gl.getUniformLocation(res, \"skyboxIntensity_l\")\n        };\n    }\n    drawMaterial(model) {\n        const gl = this.ctx.getGLContext();\n        if (this.prog !== null && this.skyboxes.length > 0) {\n            const wrap = this.ctx.getGL();\n            wrap.useProgram(this.prog);\n            const strip = gl_matrix_1.mat4.copy(gl_matrix_1.mat4.create(), this.view);\n            // equiv to mat4 -> mat3 -> mat4\n            strip[3] = 0;\n            strip[7] = 0;\n            strip[11] = 0;\n            strip[12] = 0;\n            strip[13] = 0;\n            strip[14] = 0;\n            strip[15] = 1;\n            gl.uniformMatrix4fv(this.unifs.uViewmat, false, strip);\n            gl.uniformMatrix4fv(this.unifs.uPersmat, false, this.persp);\n            gl.uniform1f(this.unifs.skyboxIntensity, this.skyboxes[0].intensity);\n            this.skyboxes[0].color.bindToUniform(this.unifs.uCubemap, 1);\n            if (this.skyboxes.length > 1) {\n                gl.uniform1f(this.unifs.skyboxIntensity_l, this.skyboxes[1].intensity);\n                this.skyboxes[1].color.bindToUniform(this.unifs.uCubemap_l, 2);\n            }\n            else {\n                gl.uniform1f(this.unifs.skyboxIntensity_l, 0);\n                this.placeholder_l.bindToUniform(this.unifs.uCubemap_l, 2);\n            }\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, this.posLoc);\n            model.draw();\n        }\n    }\n}\nexports.SkyboxMaterial = SkyboxMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/SkyboxMaterial.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/TextureDisplay.ts":
/*!*******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/TextureDisplay.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureDisplay = exports.screenCoords = void 0;\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst Texture_1 = __webpack_require__(/*! ../gl/Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\nconst Task_1 = __webpack_require__(/*! ../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\n// fucking \nexports.screenCoords = new Float32Array([\n    1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1\n]);\nclass TextureDisplay {\n    constructor(ctx, vert, frag, texture) {\n        this.ctx = ctx;\n        this.tex = null;\n        if (texture instanceof Texture_1.Texture) {\n            this.tex = texture;\n        }\n        else {\n            if (texture.valid()) {\n                this.tex = texture.get();\n            }\n            else {\n                texture.wait().then((tex) => { this.tex = tex; });\n            }\n        }\n        let gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        this.prog = null;\n        let shaderTask = new Task_1.Task();\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader(vert)\n            .withFragmentShader(frag)\n            .build()\n            .then((res) => { this.configureProgram(res); return res; })\n            .then(shaderTask.resolve.bind(shaderTask));\n        this.shaderFuture = shaderTask.getFuture();\n        this.buf = gl.createBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        gl.bufferData(gl.ARRAY_BUFFER, exports.screenCoords, gl.STATIC_DRAW);\n    }\n    prepareAttributes() {\n        let gl = this.ctx.getGLContext();\n        this.attribs = {\n            pos: gl.getAttribLocation(this.prog, \"aPosition\")\n        };\n        this.locs = {\n            tex: gl.getUniformLocation(this.prog, \"tex\")\n        };\n    }\n    // returns the game context for this object :3\n    getContext() {\n        return this.ctx;\n    }\n    // fetches the descriptor for the compiled GL program\n    getProgram() {\n        return this.prog;\n    }\n    // override as needed -- called after compilation, allowing the extender\n    // to configure any necessary uniforms.\n    configureProgram(prog) {\n        // nop\n    }\n    getShaderFuture() {\n        return this.shaderFuture;\n    }\n    drawTexture() {\n        let gl = this.ctx.getGLContext();\n        if (this.prog === null) {\n            if (this.shaderFuture.valid()) {\n                this.prog = this.shaderFuture.get();\n                this.prepareAttributes();\n            }\n        }\n        if (this.prog !== null && this.tex !== null) {\n            const wrap = this.ctx.getGL();\n            wrap.useProgram(this.prog);\n            this.prepareUniforms(this.prog);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n            gl.vertexAttribPointer(this.attribs.pos, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.attribs.pos);\n            this.tex.bindToUniform(this.locs.tex, 1);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.attribs.pos);\n        }\n        else {\n            if (this.prog === null) {\n                console.debug(\"TextureDisplay program was null!\");\n            }\n            if (this.tex === null) {\n                console.debug(\"TextureDisplay texture was null!\");\n            }\n        }\n    }\n}\nexports.TextureDisplay = TextureDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/TextureDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/TextureDummy.ts":
/*!*****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/TextureDummy.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureDummy = void 0;\nconst ColorTexture_1 = __webpack_require__(/*! ../gl/internal/ColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/ColorTexture.ts\");\nconst Texture_1 = __webpack_require__(/*! ../gl/Texture */ \"./hingler-party/client/ts/engine/gl/Texture.ts\");\n// a dummy texture which is used to fill a sampler2D if no texture is desired\nlet texid = null;\nclass TextureDummy extends Texture_1.Texture {\n    constructor(ctx) {\n        super();\n        this.ctx = ctx;\n        if (texid === null) {\n            texid = new ColorTexture_1.ColorTexture(ctx, [1, 1]);\n        }\n        this.dims = [1, 1];\n    }\n    setSamplingMode(mode) {\n        // ignore sampling sets for our dummy\n        return true;\n    }\n    getTextureFormat() {\n        return texid.getTextureFormat();\n    }\n    bindToUniform(location, index) {\n        texid.bindToUniform(location, index);\n    }\n}\nexports.TextureDummy = TextureDummy;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/TextureDummy.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/deferred/PositionMaterial.ts":
/*!******************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/deferred/PositionMaterial.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PositionMaterial = void 0;\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst AttributeType_1 = __webpack_require__(/*! nekogirl-valhalla/model/AttributeType */ \"./node_modules/nekogirl-valhalla/model/AttributeType.js\");\nclass PositionMaterial {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.prog = null;\n        new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/position/position.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/position/position.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    configureProgram(prog) {\n        const gl = this.ctx.getGLContext();\n        this.locs = {\n            modelMatrix: gl.getUniformLocation(prog, \"modelMatrix\"),\n            vpMatrix: gl.getUniformLocation(prog, \"vpMatrix\"),\n            jointMatrix: [],\n            useSkeletalAnimation: gl.getUniformLocation(prog, \"useSkeletalAnimation\")\n        };\n        for (let i = 0; i < 32; i++) {\n            this.locs.jointMatrix.push(gl.getUniformLocation(prog, `jointMatrix[${i}]`));\n        }\n        this.positionAttribute = gl.getAttribLocation(prog, \"position\");\n        this.jointAttribute = gl.getAttribLocation(prog, \"joints\");\n        this.weightAttribute = gl.getAttribLocation(prog, \"weights\");\n        this.prog = prog;\n    }\n    drawMaterial(model) {\n        let gl = this.ctx.getGLContext();\n        if (this.prog !== null) {\n            const wrap = this.ctx.getGL();\n            wrap.useProgram(this.prog);\n            gl.uniformMatrix4fv(this.locs.modelMatrix, false, this.modelMat);\n            gl.uniformMatrix4fv(this.locs.vpMatrix, false, this.vpMat);\n            const arm = model.getArmature();\n            model.bindAttribute(AttributeType_1.AttributeType.POSITION, this.positionAttribute);\n            if (arm) {\n                const bones = model.getArmature().getJointMatrices();\n                for (let i = 0; i < bones.length && i < 32; i++) {\n                    gl.uniformMatrix4fv(this.locs.jointMatrix[i], false, bones[i]);\n                }\n                model.bindAttribute(AttributeType_1.AttributeType.JOINT, this.jointAttribute);\n                model.bindAttribute(AttributeType_1.AttributeType.WEIGHT, this.weightAttribute);\n                wrap.uniform1i(this.locs.useSkeletalAnimation, 1);\n            }\n            else {\n                wrap.uniform1i(this.locs.useSkeletalAnimation, 0);\n            }\n            model.draw();\n        }\n    }\n}\nexports.PositionMaterial = PositionMaterial;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/deferred/PositionMaterial.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/internal/BRDFLutDisplay.ts":
/*!****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/internal/BRDFLutDisplay.ts ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BRDFLutDisplay = void 0;\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst TextureDisplay_1 = __webpack_require__(/*! ../TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nclass BRDFLutDisplay {\n    constructor(ctx) {\n        this.prog = null;\n        this.ctx = ctx;\n        ctx.getGLExtension(\"OES_standard_derivatives\");\n        this.compilePromise = new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/ibllut/ibllut.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/ibllut/ibllut.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    waitUntilCompiled() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.compilePromise;\n        });\n    }\n    configureProgram(res) {\n        const gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        this.prog = res;\n        this.posLoc = gl.getAttribLocation(res, \"aPosition\");\n        this.buf = gl.createBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        gl.bufferData(gl.ARRAY_BUFFER, TextureDisplay_1.screenCoords, gl.STATIC_DRAW);\n    }\n    draw() {\n        if (this.prog !== null) {\n            const gl = this.ctx.getGLContext();\n            const wrap = this.ctx.getGL();\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n            wrap.useProgram(this.prog);\n            gl.vertexAttribPointer(this.posLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.posLoc);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.posLoc);\n        }\n    }\n}\nexports.BRDFLutDisplay = BRDFLutDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/internal/BRDFLutDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/internal/CubemapToDiffuseIBLDisplay.ts":
/*!****************************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/internal/CubemapToDiffuseIBLDisplay.ts ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CubemapToDiffuseIBLDisplay = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst TextureDisplay_1 = __webpack_require__(/*! ../TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nclass CubemapToDiffuseIBLDisplay {\n    constructor(ctx, tex) {\n        this.tex = tex;\n        this.ctx = ctx;\n        this.center = gl_matrix_1.vec3.create();\n        this.right = gl_matrix_1.vec3.create();\n        this.up = gl_matrix_1.vec3.create();\n        this.prog = null;\n        this.compilePromise = new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/ibldiffuse/ibldiffuse.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/ibldiffuse/ibldiffuse.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    waitUntilCompiled() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.compilePromise;\n        });\n    }\n    configureProgram(res) {\n        this.prog = res;\n        const gl = this.ctx.getGLContext();\n        this.posLoc = gl.getAttribLocation(res, \"aPosition\");\n        this.unifs = {\n            center: gl.getUniformLocation(res, \"center\"),\n            right: gl.getUniformLocation(res, \"right\"),\n            up: gl.getUniformLocation(res, \"up\"),\n            skybox: gl.getUniformLocation(res, \"skybox\")\n        };\n        const wrap = this.ctx.getGL();\n        this.buf = gl.createBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        gl.bufferData(gl.ARRAY_BUFFER, TextureDisplay_1.screenCoords, gl.STATIC_DRAW);\n    }\n    draw() {\n        if (this.prog !== null && this.tex !== null) {\n            const gl = this.ctx.getGLContext();\n            const wrap = this.ctx.getGL();\n            const prog = this.prog;\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n            wrap.useProgram(prog);\n            gl.uniform3fv(this.unifs.center, this.center);\n            gl.uniform3fv(this.unifs.right, this.right);\n            gl.uniform3fv(this.unifs.up, this.up);\n            this.tex.bindToUniform(this.unifs.skybox, 1);\n            gl.vertexAttribPointer(this.posLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.posLoc);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.posLoc);\n        }\n    }\n}\nexports.CubemapToDiffuseIBLDisplay = CubemapToDiffuseIBLDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/internal/CubemapToDiffuseIBLDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/internal/CubemapToSpecularIBLDisplay.ts":
/*!*****************************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/internal/CubemapToSpecularIBLDisplay.ts ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CubemapToSpecularIBLDisplay = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ShaderProgramBuilder_1 = __webpack_require__(/*! ../../gl/ShaderProgramBuilder */ \"./hingler-party/client/ts/engine/gl/ShaderProgramBuilder.ts\");\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst TextureDisplay_1 = __webpack_require__(/*! ../TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nclass CubemapToSpecularIBLDisplay {\n    constructor(ctx, cubemap) {\n        this.tex = cubemap;\n        this.ctx = ctx;\n        this.center = gl_matrix_1.vec3.create();\n        this.right = gl_matrix_1.vec3.create();\n        this.up = gl_matrix_1.vec3.create();\n        this.roughness = 0.0;\n        this.cubemapRes = 256;\n        this.prog = null;\n        this.compilePromise = new ShaderProgramBuilder_1.ShaderProgramBuilder(ctx)\n            .withVertexShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/iblspecular/iblspecular.vert\"))\n            .withFragmentShader((0, getEnginePath_1.getEnginePath)(\"engine/glsl/iblspecular/iblspecular.frag\"))\n            .build()\n            .then(this.configureProgram.bind(this));\n    }\n    waitUntilCompiled() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.compilePromise;\n        });\n    }\n    configureProgram(res) {\n        this.prog = res;\n        const gl = this.ctx.getGLContext();\n        const wrap = this.ctx.getGL();\n        this.posLoc = gl.getAttribLocation(res, \"aPosition\");\n        this.unifs = {\n            center: gl.getUniformLocation(res, \"center\"),\n            right: gl.getUniformLocation(res, \"right\"),\n            up: gl.getUniformLocation(res, \"up\"),\n            skybox: gl.getUniformLocation(res, \"skybox\"),\n            roughness: gl.getUniformLocation(res, \"roughness\"),\n            sourceDestRes: gl.getUniformLocation(res, \"sourceDestRes\")\n        };\n        this.buf = gl.createBuffer();\n        wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        gl.bufferData(gl.ARRAY_BUFFER, TextureDisplay_1.screenCoords, gl.STATIC_DRAW);\n    }\n    draw() {\n        if (this.prog !== null && this.tex !== null) {\n            const gl = this.ctx.getGLContext();\n            const prog = this.prog;\n            const wrap = this.ctx.getGL();\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            wrap.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n            wrap.useProgram(prog);\n            gl.uniform3fv(this.unifs.center, this.center);\n            gl.uniform3fv(this.unifs.right, this.right);\n            gl.uniform3fv(this.unifs.up, this.up);\n            wrap.uniform1f(this.unifs.roughness, this.roughness);\n            gl.uniform2f(this.unifs.sourceDestRes, this.cubemapRes, this.destRes);\n            this.tex.bindToUniform(this.unifs.skybox, 1);\n            gl.vertexAttribPointer(this.posLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(this.posLoc);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n            gl.disableVertexAttribArray(this.posLoc);\n        }\n    }\n}\nexports.CubemapToSpecularIBLDisplay = CubemapToSpecularIBLDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/internal/CubemapToSpecularIBLDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/material/internal/HDRToCubemapDisplay.ts":
/*!*********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/material/internal/HDRToCubemapDisplay.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HDRToCubemapDisplay = void 0;\nconst getEnginePath_1 = __webpack_require__(/*! ../../internal/getEnginePath */ \"./hingler-party/client/ts/engine/internal/getEnginePath.ts\");\nconst TextureDisplay_1 = __webpack_require__(/*! ../TextureDisplay */ \"./hingler-party/client/ts/engine/material/TextureDisplay.ts\");\nclass HDRToCubemapDisplay extends TextureDisplay_1.TextureDisplay {\n    constructor(ctx, hdr) {\n        super(ctx, (0, getEnginePath_1.getEnginePath)(\"engine/glsl/hdr-to-skybox/hdr-to-skybox.vert\"), (0, getEnginePath_1.getEnginePath)(\"engine/glsl/hdr-to-skybox/hdr-to-skybox.frag\"), hdr);\n    }\n    configureProgram(prog) {\n        const gl = this.getContext().getGLContext();\n        this.unifs = {\n            center: gl.getUniformLocation(prog, \"center\"),\n            right: gl.getUniformLocation(prog, \"right\"),\n            up: gl.getUniformLocation(prog, \"up\")\n        };\n    }\n    prepareUniforms() {\n        if (this.getShaderFuture().valid()) {\n            const gl = this.getContext().getGLContext();\n            gl.uniform3fv(this.unifs.center, this.center);\n            gl.uniform3fv(this.unifs.right, this.right);\n            gl.uniform3fv(this.unifs.up, this.up);\n        }\n    }\n}\nexports.HDRToCubemapDisplay = HDRToCubemapDisplay;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/material/internal/HDRToCubemapDisplay.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/Model.ts":
/*!*******************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/Model.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Model = void 0;\n/**\n * Represents a 3D model.\n * TODO: Create a version of Model which acts like a GLTF model.\n * Probably wrap this class and not import -- draw will use GLTF material w params.\n */\nclass Model {\n}\nexports.Model = Model;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/Model.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/ModelInstance.ts":
/*!***************************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/ModelInstance.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelInstance = void 0;\nclass ModelInstance {\n    constructor() {\n        this.deleted_ = false;\n    }\n    get deleted() {\n        return this.deleted_;\n    }\n    /**\n     * Marks this instance for deletion.\n     */\n    deleteInstance() {\n        this.deleted_ = true;\n    }\n}\nexports.ModelInstance = ModelInstance;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/ModelInstance.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/PBRInstance.ts":
/*!*************************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/PBRInstance.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRInstance = void 0;\nconst ModelInstance_1 = __webpack_require__(/*! ./ModelInstance */ \"./hingler-party/client/ts/engine/model/ModelInstance.ts\");\nclass PBRInstance extends ModelInstance_1.ModelInstance {\n}\nexports.PBRInstance = PBRInstance;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/PBRInstance.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/PBRInstanceFactory.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/PBRInstanceFactory.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// expose functions to draw it\n// and expose functions to set instance state\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRInstanceFactory = void 0;\nconst InstancedShadowMaterial_1 = __webpack_require__(/*! ../material/InstancedShadowMaterial */ \"./hingler-party/client/ts/engine/material/InstancedShadowMaterial.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst PBRInstanceImpl_1 = __webpack_require__(/*! ./internal/PBRInstanceImpl */ \"./hingler-party/client/ts/engine/model/internal/PBRInstanceImpl.ts\");\n// factor out into impl and interface :(\nclass PBRInstanceFactory {\n    constructor(ctx, models, mats) {\n        this.ctx = ctx;\n        this.models = models;\n        this.materials = mats;\n        this.currentPass = RenderContext_1.RenderPass.FINAL;\n        this.shadowMat = new InstancedShadowMaterial_1.InstancedShadowMaterial(this.ctx);\n        for (let i = 0; i < this.models.length; i++) {\n            this.models[i].setInstancedMaterial(this.materials[i]);\n            this.materials[i].setModelMatrixIndex(PBRInstanceImpl_1.PBR_MODEL_MAT_INDEX);\n        }\n        this.shadowMat.setModelMatrixIndex(PBRInstanceImpl_1.PBR_MODEL_MAT_INDEX);\n    }\n    getInstance() {\n        let inst = new PBRInstanceImpl_1.PBRInstanceImpl(this.callbackfunc.bind(this));\n        return inst;\n    }\n    /**\n     * Draws several instances from an array representing a model matrix.\n     * @param matList - array-like structure containing our matrices\n     */\n    drawInstanceFromModelMatArray(matList, rc) {\n        const instanceCount = Math.floor(matList.length / 16);\n        let mat = matList;\n        // array does not contain exact amt of instance data\n        if (instanceCount * 16 !== matList.length) {\n            mat = matList.slice(0, instanceCount * 16);\n        }\n        const pass = rc.getRenderPass();\n        if (this.currentPass !== pass) {\n            this.currentPass = pass;\n            for (let i = 0; i < this.models.length; i++) {\n                let model = this.models[i];\n                // issue: imagine that we were to draw to the FB, not flush, then draw to shadow\n                model.flush(rc);\n                if (pass === RenderContext_1.RenderPass.SHADOW) {\n                    model.setInstancedMaterial(this.shadowMat);\n                }\n                else {\n                    model.setInstancedMaterial(this.materials[i]);\n                }\n            }\n        }\n        for (let i = 0; i < this.models.length; i++) {\n            // also calculate normal matrices, or skip?\n            this.models[i].appendInstanceData(PBRInstanceImpl_1.PBR_MODEL_MAT_INDEX, mat);\n            this.models[i].drawManyInstanced(instanceCount);\n        }\n    }\n    callbackfunc(mat, rc) {\n        let pass = rc.getRenderPass();\n        if (this.currentPass !== pass) {\n            this.currentPass = pass;\n            for (let i = 0; i < this.models.length; i++) {\n                let model = this.models[i];\n                // issue: imagine that we were to draw to the FB, not flush, then draw to shadow\n                model.flush(rc);\n                if (pass === RenderContext_1.RenderPass.SHADOW) {\n                    model.setInstancedMaterial(this.shadowMat);\n                }\n                else {\n                    model.setInstancedMaterial(this.materials[i]);\n                }\n            }\n        }\n        for (let i = 0; i < this.models.length; i++) {\n            // need some sort of \"batchedinstancemodel\" which queues several draws at once\n            this.models[i].appendInstanceData(PBRInstanceImpl_1.PBR_MODEL_MAT_INDEX, mat);\n            this.models[i].drawInstanced();\n        }\n    }\n}\nexports.PBRInstanceFactory = PBRInstanceFactory;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/PBRInstanceFactory.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/PBRModel.ts":
/*!**********************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/PBRModel.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRModel = void 0;\nconst Model_1 = __webpack_require__(/*! ./Model */ \"./hingler-party/client/ts/engine/model/Model.ts\");\nclass PBRModel extends Model_1.Model {\n}\nexports.PBRModel = PBRModel;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/PBRModel.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/model/internal/PBRInstanceImpl.ts":
/*!**************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/model/internal/PBRInstanceImpl.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PBRInstanceImpl = exports.PBR_MODEL_MAT_INDEX = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst PBRInstance_1 = __webpack_require__(/*! ../PBRInstance */ \"./hingler-party/client/ts/engine/model/PBRInstance.ts\");\nexports.PBR_MODEL_MAT_INDEX = 4;\nclass PBRInstanceImpl extends PBRInstance_1.PBRInstance {\n    constructor(callback) {\n        super();\n        this.modelMat = gl_matrix_1.mat4.identity(gl_matrix_1.mat4.create());\n        this.callback = callback;\n    }\n    draw(rc) {\n        this.callback(this.modelMat, rc);\n    }\n}\nexports.PBRInstanceImpl = PBRInstanceImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/model/internal/PBRInstanceImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/armature/ArmatureManager.ts":
/*!***************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/armature/ArmatureManager.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArmatureManager = void 0;\n// should load a bunch of user-requested animations at once, and \nclass ArmatureManager {\n    // add animations later\n    // animations can work by using existing splines -- sample, return joints\n    // probably pass ctx here\n    constructor(root, ctx) {\n        this.root = root;\n        this.cacheArmatureNodes();\n        this.ctx = ctx;\n    }\n    // set an animator\n    // when we call jointmatrices, update based on time step\n    getJointMatrices() {\n        const jointArray = [];\n        for (let joint of this.orderedJoints) {\n            jointArray.push(joint.getJointMatrix());\n        }\n        return jointArray;\n    }\n    getJointNormalMatrices() {\n        const jointArray = [];\n        for (let joint of this.orderedJoints) {\n            jointArray.push(joint.getJointMatrixNormal());\n        }\n        return jointArray;\n    }\n    sampleFromAnimator(animator, t) {\n        for (let joint of this.orderedJoints) {\n            const id = joint.nodeID;\n            const animData = animator.sample(id, t);\n            if (animData.position) {\n                joint.setPosition(animData.position);\n            }\n            if (animData.rotation) {\n                joint.setRotationQuat(animData.rotation);\n            }\n            if (animData.scale) {\n                joint.setScale(animData.scale);\n            }\n        }\n    }\n    cacheArmatureNodes() {\n        this.orderedJoints = [];\n        ArmatureManager.cacheArmatureNodes_recurse(this.root, this.orderedJoints);\n        this.orderedJoints.sort((a, b) => a.getId() - b.getId());\n    }\n    static cacheArmatureNodes_recurse(root, jointCache) {\n        jointCache.push(root);\n        for (let child of root.getChildren()) {\n            this.cacheArmatureNodes_recurse(child, jointCache);\n        }\n    }\n}\nexports.ArmatureManager = ArmatureManager;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/armature/ArmatureManager.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/armature/ArmatureNode.ts":
/*!************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/armature/ArmatureNode.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArmatureNode = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst NestableBase_1 = __webpack_require__(/*! nekogirl-valhalla/object/NestableBase */ \"./node_modules/nekogirl-valhalla/object/NestableBase.js\");\nconst TransformableBase_1 = __webpack_require__(/*! nekogirl-valhalla/object/TransformableBase */ \"./node_modules/nekogirl-valhalla/object/TransformableBase.js\");\n// todo: move hierarchal structure into another component?\n// eh, its too diff\nclass ArmatureNode extends NestableBase_1.NestableBase {\n    constructor(jointID, invbind) {\n        super(jointID);\n        this.transform = new TransformableBase_1.TransformableBase();\n        this.inverseBindMatrix = invbind;\n        this.dirty = true;\n        this.transform_cache = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.identity(this.transform_cache);\n        this.transform_cache_joint = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.identity(this.transform_cache_joint);\n        this.transform_cache_joint_normal = gl_matrix_1.mat3.create();\n        gl_matrix_1.mat3.identity(this.transform_cache_joint_normal);\n    }\n    setNodeID(id) {\n        this.nodeID_ = id;\n    }\n    get nodeID() {\n        return this.nodeID_;\n    }\n    getRotation() {\n        return this.transform.getRotation();\n    }\n    getPosition() {\n        return this.transform.getPosition();\n    }\n    getScale() {\n        return this.transform.getScale();\n    }\n    setRotationEuler(x, y, z) {\n        this.transform.setRotationEuler(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    setRotationQuat(x, y, z, w) {\n        this.transform.setRotationQuat(x, y, z, w);\n        this.invalidateTransformCache_();\n    }\n    setScale(x, y, z) {\n        this.transform.setScale(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    setPosition(x, y, z) {\n        this.transform.setPosition(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    // possible redundancy cut:\n    // - move functionality to a different class which combines transformable and nestable\n    // - extend that here\n    invalidateTransformCache_() {\n        if (!this.dirty) {\n            this.dirty = true;\n            for (let child of this.getChildren()) {\n                child.invalidateTransformCache_();\n            }\n        }\n    }\n    updateMatrixCache() {\n        let res = this.transform_cache;\n        let joint = this.transform_cache_joint;\n        gl_matrix_1.mat4.fromRotationTranslationScale(res, this.getRotation(), this.getPosition(), this.getScale());\n        if (this.getParent() !== null) {\n            gl_matrix_1.mat4.mul(res, this.getParent().getTransformationMatrix(), res);\n        }\n        gl_matrix_1.mat4.mul(joint, res, this.inverseBindMatrix);\n        gl_matrix_1.mat3.fromMat4(this.transform_cache_joint_normal, joint);\n        this.dirty = false;\n    }\n    getTransformationMatrix() {\n        if (this.dirty) {\n            this.updateMatrixCache();\n        }\n        return this.transform_cache;\n    }\n    getJointMatrix() {\n        if (this.dirty) {\n            this.updateMatrixCache();\n        }\n        return this.transform_cache_joint;\n    }\n    getJointMatrixNormal() {\n        if (this.dirty) {\n            this.updateMatrixCache();\n        }\n        return this.transform_cache_joint_normal;\n    }\n}\nexports.ArmatureNode = ArmatureNode;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/armature/ArmatureNode.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/GameCamera.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/GameCamera.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameCamera = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst GameObject_1 = __webpack_require__(/*! ./GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\n// i think this is ok since circular references wont be a problem\n// might have to factor\nclass GameCamera extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        this.active = false;\n        this.fov = 60;\n        this.near = 0.1;\n        this.far = 100.0;\n        this.filterIDs = [];\n        this.filters = [];\n        this.lastFilter = 0;\n    }\n    getCameraMatrix() {\n        let perspectiveMatrix = this.getPerspectiveMatrix();\n        let viewMatrix = this.getViewMatrix();\n        gl_matrix_1.mat4.mul(viewMatrix, perspectiveMatrix, viewMatrix);\n        return viewMatrix;\n    }\n    getCameraInfo() {\n        let pos = gl_matrix_1.vec3.create();\n        gl_matrix_1.vec3.zero(pos);\n        let mat = this.getTransformationMatrix();\n        gl_matrix_1.vec3.transformMat4(pos, pos, mat);\n        let res = {\n            viewMatrix: this.getViewMatrix(),\n            perspectiveMatrix: this.getPerspectiveMatrix(),\n            vpMatrix: gl_matrix_1.mat4.create(),\n            cameraPosition: this.getGlobalPosition()\n        };\n        gl_matrix_1.mat4.mul(res.vpMatrix, res.perspectiveMatrix, res.viewMatrix);\n        return res;\n    }\n    getViewMatrix() {\n        let vm = gl_matrix_1.mat4.copy(gl_matrix_1.mat4.create(), this.getTransformationMatrix());\n        gl_matrix_1.mat4.invert(vm, vm);\n        return vm;\n    }\n    getPerspectiveMatrix() {\n        let dims = this.getContext().getScreenDims();\n        let aspectRatio = dims[0] / dims[1];\n        let pm = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.perspective(pm, this.fov * (Math.PI / 180.0), aspectRatio, this.near, this.far);\n        return pm;\n    }\n    // todo2: set active camera?\n    setAsActive() {\n        // contract: only one active camera at a time\n        let cur = this;\n        let parent = cur.getParent();\n        while (parent !== null) {\n            cur = parent;\n            parent = cur.getParent();\n        }\n        this.findActiveCameraAndDeactivate(cur);\n        // no cameras are active now, set this one as active\n        this.active = true;\n    }\n    isActive() {\n        return this.active;\n    }\n    deactivateCamera() {\n        this.active = false;\n    }\n    findActiveCameraAndDeactivate(root) {\n        if (root instanceof GameCamera) {\n            let cam = root;\n            if (cam.active) {\n                cam.deactivateCamera();\n                return;\n            }\n        }\n        for (let child of root.getChildren()) {\n            this.findActiveCameraAndDeactivate(child);\n        }\n    }\n    addFilter(filter) {\n        this.filterIDs.push(this.lastFilter);\n        this.filters.push(filter);\n        return this.lastFilter++;\n    }\n    getFilters() {\n        return this.filters;\n    }\n    deleteFilter(filter) {\n        let cur = this.filterIDs.indexOf(filter);\n        if (cur < 0) {\n            return false;\n        }\n        this.filterIDs = this.filterIDs.splice(cur, 1);\n        this.filters = this.filters.splice(cur, 1);\n    }\n}\nexports.GameCamera = GameCamera;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/GameCamera.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/GameModel.ts":
/*!*****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/GameModel.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameModel = void 0;\nconst Model_1 = __webpack_require__(/*! ../../model/Model */ \"./hingler-party/client/ts/engine/model/Model.ts\");\nconst ShadowNoTextureMaterial_1 = __webpack_require__(/*! ../../material/ShadowNoTextureMaterial */ \"./hingler-party/client/ts/engine/material/ShadowNoTextureMaterial.ts\");\nconst RenderContext_1 = __webpack_require__(/*! ../../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst GameObject_1 = __webpack_require__(/*! ./GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst ComponentType_1 = __webpack_require__(/*! ../../component/ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nclass GameModel extends GameObject_1.GameObject {\n    constructor(ctx, init, modelName) {\n        // pass by path? pass as arg?\n        // ctor raw seems like a piss idea\n        super(ctx);\n        this.addComponent(ComponentType_1.ComponentType.MODEL);\n        this.model = null;\n        this.shadowTex = new ShadowNoTextureMaterial_1.ShadowNoTextureMaterial(ctx);\n        if (typeof init === \"string\") {\n            // TODO: figure out how best to expose our GLTF loader from the engine context.\n            this.getContext().getGLTFLoader().loadGLTFModel(init)\n                .then((res) => {\n                if (res.length > 0) {\n                    this.setModel(res[0]);\n                }\n                else {\n                    console.error(\"could not assign model!\");\n                }\n            }).catch((reason) => {\n                console.error(\"Something went wrong while parsing model\");\n                console.error(reason);\n            });\n            this.setDebugName(`${this.getDebugName()}:${init}`);\n        }\n        else if (init instanceof Model_1.Model) {\n            // TODO: Model is abstract for type inf, roll it back bc future is abstract\n            // init instanceof Model\n            this.setModel(init);\n        }\n        else {\n            // init instanceof Future\n            if (init.valid()) {\n                this.setModel(init.get());\n            }\n            else {\n                init.wait().then((res) => {\n                    this.setModel(res);\n                });\n            }\n        }\n        if (modelName !== undefined) {\n            // preserve file path if provided, add name to end\n            this.setDebugName(`${this.getDebugName()}:${modelName}`);\n        }\n    }\n    setModel(model) {\n        this.model = model;\n        const mod = this.getComponent(ComponentType_1.ComponentType.MODEL);\n        mod.model = this.model;\n    }\n    // temp in case something is fucky here\n    getModel() {\n        return this.model;\n    }\n    /**\n     * draws this model with `material`. Does not modify material state.\n     * @param rc - the render context associated with this draw call.\n     * @param material - the material which should be drawn.\n     */\n    drawModel(rc, material) {\n        let info = rc.getActiveCameraInfo();\n        if (this.model) {\n            // this is a lazy fallback\n            if (rc.getRenderPass() === RenderContext_1.RenderPass.SHADOW) {\n                this.shadowTex.modelMat = this.getTransformationMatrix();\n                this.shadowTex.shadowMat = info.vpMatrix;\n                this.shadowTex.drawMaterial(this.model);\n            }\n            else {\n                material.drawMaterial(this.model);\n            }\n        }\n    }\n}\nexports.GameModel = GameModel;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/GameModel.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/GameObject.ts":
/*!******************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/GameObject.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameObject = void 0;\nconst NestableComponent_1 = __webpack_require__(/*! nekogirl-valhalla/object/NestableComponent */ \"./node_modules/nekogirl-valhalla/object/NestableComponent.js\");\nconst TransformableNestableComponent_1 = __webpack_require__(/*! nekogirl-valhalla/object/TransformableNestableComponent */ \"./node_modules/nekogirl-valhalla/object/TransformableNestableComponent.js\");\nconst TransformableBase_1 = __webpack_require__(/*! nekogirl-valhalla/object/TransformableBase */ \"./node_modules/nekogirl-valhalla/object/TransformableBase.js\");\nconst IDGenerator_1 = __webpack_require__(/*! nekogirl-valhalla/object/IDGenerator */ \"./node_modules/nekogirl-valhalla/object/IDGenerator.js\");\nconst performance_1 = __webpack_require__(/*! @hingler-party/ts/performance */ \"./hingler-party/ts/performance.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../../internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst ComponentManager_1 = __webpack_require__(/*! ../../component/internal/ComponentManager */ \"./hingler-party/client/ts/engine/component/internal/ComponentManager.ts\");\nconst gen = new IDGenerator_1.IDGenerator();\n/**\n * Game object rendered to a lovely 3d world.\n */\nclass GameObject {\n    // unfortunately we can't really track destruction of objects\n    // our engine will destroy, so we could maintain destruction through that\n    // remove destroy from gameobject, and attach it to scene\n    // then, we can clear resources by calling methods\n    constructor(ctx) {\n        const id = gen.getNewID();\n        this.name = this.constructor.name;\n        this.created = false;\n        this.context_ = ctx;\n        this.name = this.constructor.name;\n        this.componentList = new Map();\n        this.dirty = true;\n        this.nest = new NestableComponent_1.NestableComponent(id, this);\n        this.transform = new TransformableBase_1.TransformableBase();\n        this.nesttransform = new TransformableNestableComponent_1.TransformableNestableComponent(this);\n    }\n    getDebugName() {\n        return this.name;\n    }\n    setDebugName(name) {\n        this.name = name;\n    }\n    getParent() {\n        return this.nest.getParent();\n    }\n    getChild(id) {\n        return this.nest.getChild(id);\n    }\n    getChildren() {\n        return this.nest.getChildren();\n    }\n    getId() {\n        return this.nest.getId();\n    }\n    setId(id) {\n        return this.nest.setId(id);\n    }\n    getContext() {\n        return this.context_;\n    }\n    removeChild(id) {\n        const child = this.nest.removeChild(id);\n        child.invalidateTransformCache_();\n        return child;\n    }\n    addChild(elem) {\n        const res = this.nest.addChild(elem.nest);\n        elem.invalidateTransformCache_();\n        return res;\n    }\n    /**\n     * Function which draws this component onto the screen.\n     * Should be called once whenever this object is drawn.\n     */\n    renderMaterial(rc) {\n        // currently a noop\n    }\n    // renders itself and its children\n    renderfunc(rc) {\n        this.renderMaterial(rc);\n        // overtime should round out :)\n        for (let child of this.nest.getChildren()) {\n            child.renderfunc(rc);\n        }\n    }\n    childcallback(cb) {\n        // this is hopefully fine?\n        cb(this);\n        for (let child of this.nest.getChildren()) {\n            child.childcallback(cb);\n        }\n    }\n    // nop\n    create() { }\n    update() { }\n    updatefunc() {\n        if (!this.created) {\n            this.create();\n            this.created = true;\n        }\n        const start = performance_1.perf.now();\n        this.update();\n        const end = performance_1.perf.now();\n        (0, performanceanalytics_1.logUpdate)(this.name, end - start);\n        for (let child of this.nest.getChildren()) {\n            child.updatefunc();\n        }\n    }\n    /**\n     * @returns Rotation of this gameobject.\n     */\n    getRotation() {\n        return this.transform.getRotation();\n    }\n    /**\n     * @returns Position of this gameobject.\n     */\n    getPosition() {\n        return this.transform.getPosition();\n    }\n    /**\n     * @returns Scale of this gameobject.\n     */\n    getScale() {\n        return this.transform.getScale();\n    }\n    /**\n     * Sets the rotation of this GameObject as euler coordinates, specified in degrees.\n     * @param x - x rotation, or vec3 containing XYZ euler rotation.\n     * @param y - if valid: y rotation.\n     * @param z - if valid: z rotation.\n     */\n    setRotationEuler(x, y, z) {\n        this.transform.setRotationEuler(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    setRotationQuat(x, y, z, w) {\n        this.transform.setRotationQuat(x, y, z, w);\n        this.invalidateTransformCache_();\n    }\n    /**\n     * Sets the scale of this GameObject.\n     * @param x - either the x dimension or our scale, or a vec3 containing the new scale for this object.\n     * @param y - if valid: y scale.\n     * @param z - if valid: z scale.\n     */\n    setScale(x, y, z) {\n        this.transform.setScale(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    /**\n     * Sets the position of this GameObject.\n     * @param x - x coordinate, or vector containing new pos.\n     * @param y - y coordinate, if valid.\n     * @param z - z coordinate, if valid.\n     */\n    setPosition(x, y, z) {\n        this.transform.setPosition(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    getGlobalPosition() {\n        return this.nesttransform.getGlobalPosition();\n    }\n    lookAt(x, y, z) {\n        this.nesttransform.lookAt(x, y, z);\n        this.invalidateTransformCache_();\n    }\n    invalidateTransformCache_() {\n        // note: lots of redundant action if we do a lot of txs\n        // assumption: if a child is already dirty, its children will be dirty as well\n        this.nesttransform.invalidateTransformCache();\n        if (!this.dirty) {\n            this.dirty = true;\n            for (let child of this.nest.getChildren()) {\n                child.invalidateTransformCache_();\n            }\n        }\n    }\n    /**\n     * @returns the transformation matrix associated with this GameObject.\n     */\n    getTransformationMatrix() {\n        this.dirty = false;\n        return this.nesttransform.getTransformationMatrix();\n    }\n    getComponent(type) {\n        if (this.componentList.has(type)) {\n            return this.componentList.get(type);\n        }\n        return null;\n    }\n    addComponent(type) {\n        if (this.componentList.has(type)) {\n            return this.componentList.get(type);\n        }\n        const component = ComponentManager_1.ComponentManager.getComponent(type);\n        if (component) {\n            this.componentList.set(type, component);\n        }\n        return component;\n    }\n}\nexports.GameObject = GameObject;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/GameObject.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/GamePBRModel.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/GamePBRModel.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GamePBRModel = void 0;\nconst RenderContext_1 = __webpack_require__(/*! ../../render/RenderContext */ \"./hingler-party/client/ts/engine/render/RenderContext.ts\");\nconst PBRModel_1 = __webpack_require__(/*! ../../model/PBRModel */ \"./hingler-party/client/ts/engine/model/PBRModel.ts\");\nconst GameObject_1 = __webpack_require__(/*! ./GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst performanceanalytics_1 = __webpack_require__(/*! ../../internal/performanceanalytics */ \"./hingler-party/client/ts/engine/internal/performanceanalytics.ts\");\nconst ComponentType_1 = __webpack_require__(/*! ../../component/ComponentType */ \"./hingler-party/client/ts/engine/component/ComponentType.ts\");\nclass GamePBRModel extends GameObject_1.GameObject {\n    constructor(ctx, init) {\n        super(ctx);\n        this.addComponent(ComponentType_1.ComponentType.MODEL);\n        this.model_ = null;\n        if (init instanceof PBRModel_1.PBRModel) {\n            this.model = init;\n        }\n        else {\n            if (init.valid()) {\n                this.model = init.get();\n            }\n            else {\n                init.wait().then((res) => {\n                    this.model = res;\n                });\n            }\n        }\n    }\n    updateDebugName() {\n        if (this.model_ !== null && this.model_.name !== undefined && this.model_.name.length > 0) {\n            this.setDebugName(this.model_.name);\n        }\n    }\n    set model(model) {\n        this.model_ = model;\n        const mod = this.getComponent(ComponentType_1.ComponentType.MODEL);\n        mod.model = model;\n        this.updateDebugName();\n    }\n    get model() {\n        return this.model_;\n    }\n    setPBRModel(model) {\n        if (model instanceof PBRModel_1.PBRModel) {\n            this.model = model;\n        }\n        else {\n            if (model.valid()) {\n                console.log(model.get());\n                this.model = model.get();\n            }\n            else {\n                model.wait().then((res) => {\n                    this.model = res;\n                });\n            }\n        }\n    }\n    renderMaterial(rc) {\n        const timer = this.getContext().getGPUTimer();\n        const id = timer.startQuery();\n        if (this.model_ !== null) {\n            let modelMat = this.getTransformationMatrix();\n            if (rc.getRenderPass() === RenderContext_1.RenderPass.SHADOW) {\n                this.model_.drawPBRShadow(modelMat, rc);\n                timer.stopQueryAndLog(id, `${this.getDebugName()}.PBRShadow`, performanceanalytics_1.RenderType.SHADOW);\n            }\n            else {\n                this.model_.drawPBR(modelMat, rc);\n                timer.stopQueryAndLog(id, `${this.getDebugName()}.PBRMaterial`, performanceanalytics_1.RenderType.FINAL);\n            }\n        }\n    }\n}\nexports.GamePBRModel = GamePBRModel;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/GamePBRModel.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/SkyboxObject.ts":
/*!********************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/SkyboxObject.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SkyboxObject = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst DataType_1 = __webpack_require__(/*! nekogirl-valhalla/model/DataType */ \"./node_modules/nekogirl-valhalla/model/DataType.js\");\nconst DepthStencilRenderbuffer_1 = __webpack_require__(/*! ../../gl/internal/DepthStencilRenderbuffer */ \"./hingler-party/client/ts/engine/gl/internal/DepthStencilRenderbuffer.ts\");\nconst FloatColorTexture_1 = __webpack_require__(/*! ../../gl/internal/FloatColorTexture */ \"./hingler-party/client/ts/engine/gl/internal/FloatColorTexture.ts\");\nconst GLAttributeImpl_1 = __webpack_require__(/*! ../../gl/internal/GLAttributeImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLAttributeImpl.ts\");\nconst GLBufferImpl_1 = __webpack_require__(/*! ../../gl/internal/GLBufferImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLBufferImpl.ts\");\nconst GLIndexImpl_1 = __webpack_require__(/*! ../../gl/internal/GLIndexImpl */ \"./hingler-party/client/ts/engine/gl/internal/GLIndexImpl.ts\");\nconst HDRTexture_1 = __webpack_require__(/*! ../../gl/internal/HDRTexture */ \"./hingler-party/client/ts/engine/gl/internal/HDRTexture.ts\");\nconst SkyboxFramebuffer_1 = __webpack_require__(/*! ../../gl/internal/SkyboxFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/SkyboxFramebuffer.ts\");\nconst ModelImpl_1 = __webpack_require__(/*! ../../loaders/internal/ModelImpl */ \"./hingler-party/client/ts/engine/loaders/internal/ModelImpl.ts\");\nconst BRDFLutDisplay_1 = __webpack_require__(/*! ../../material/internal/BRDFLutDisplay */ \"./hingler-party/client/ts/engine/material/internal/BRDFLutDisplay.ts\");\nconst CubemapToDiffuseIBLDisplay_1 = __webpack_require__(/*! ../../material/internal/CubemapToDiffuseIBLDisplay */ \"./hingler-party/client/ts/engine/material/internal/CubemapToDiffuseIBLDisplay.ts\");\nconst CubemapToSpecularIBLDisplay_1 = __webpack_require__(/*! ../../material/internal/CubemapToSpecularIBLDisplay */ \"./hingler-party/client/ts/engine/material/internal/CubemapToSpecularIBLDisplay.ts\");\nconst HDRToCubemapDisplay_1 = __webpack_require__(/*! ../../material/internal/HDRToCubemapDisplay */ \"./hingler-party/client/ts/engine/material/internal/HDRToCubemapDisplay.ts\");\nconst SkyboxMaterial_1 = __webpack_require__(/*! ../../material/SkyboxMaterial */ \"./hingler-party/client/ts/engine/material/SkyboxMaterial.ts\");\nconst GameObject_1 = __webpack_require__(/*! ./GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\n// todo2: cubemap wrapper?\n// representation of a simple skybox :D\nclass SkyboxObject extends GameObject_1.GameObject {\n    // how can we tell the engine that we're rendering our skybox?\n    // add skybox construction as a context feature so we can pass in an engine context\n    // use the engine context to notify client that we're compiling a skybox\n    constructor(ctx, path) {\n        super(ctx);\n        // ensure this extension is loaded if avail -- we dont \"need\" it but it helps\n        ctx.getGLExtension(\"EXT_shader_texture_lod\");\n        this.extMipmapRender = !!(ctx.getGLExtension(\"OES_fbo_render_mipmap\"));\n        ctx.getGLExtension(\"OES_standard_derivatives\");\n        this.cubemap = null;\n        this.cubemapDiffuse = null;\n        this.cubemapSpecular = null;\n        this.iblBRDF = null;\n        ctx.getGLExtension(\"OES_standard_derivatives\");\n        this.intensity = 1.0;\n        this.model = SkyboxObject.createSkyboxCube(ctx);\n        this.hdr = new HDRTexture_1.HDRTexture(ctx, path);\n        this.mat = new SkyboxMaterial_1.SkyboxMaterial(ctx);\n        this.hdrProg = new HDRToCubemapDisplay_1.HDRToCubemapDisplay(ctx, this.hdr);\n        const hdrPromise = this.hdr.waitUntilUploaded();\n        hdrPromise.then(this.prepareSkybox.bind(this));\n    }\n    getCubemap() {\n        return this.cubemap;\n    }\n    getCubemapDiffuse() {\n        return this.cubemapDiffuse;\n    }\n    getCubemapSpecular() {\n        // uh oh!!! funky business :)\n        // i'll figure it out later :nerd:\n        return this.cubemapSpecular;\n    }\n    getBRDF() {\n        return this.iblBRDF;\n    }\n    static createSkyboxCube(ctx) {\n        const vertexBuf = new GLBufferImpl_1.GLBufferImpl(ctx);\n        const indexBuf = new GLBufferImpl_1.GLBufferImpl(ctx);\n        const gl = ctx.getGLContext();\n        for (let i = 0; i < 8; i++) {\n            vertexBuf.setFloatArray(i * 12, [(i & 1 ? 1 : -1), (i & 2 ? 1 : -1), (i & 4 ? 1 : -1)]);\n        }\n        const indexFaces = [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 4, 5, 2, 3, 6, 7, 0, 2, 4, 6, 1, 3, 5, 7];\n        let offset = 0;\n        for (let i = 0; i < indexFaces.length; i += 4) {\n            indexBuf.setUint16(offset, indexFaces[i + 2], true);\n            offset += 2;\n            indexBuf.setUint16(offset, indexFaces[i + 1], true);\n            offset += 2;\n            indexBuf.setUint16(offset, indexFaces[i], true);\n            offset += 2;\n            indexBuf.setUint16(offset, indexFaces[i + 1], true);\n            offset += 2;\n            indexBuf.setUint16(offset, indexFaces[i + 2], true);\n            offset += 2;\n            indexBuf.setUint16(offset, indexFaces[i + 3], true);\n            offset += 2;\n        }\n        const vertAttrib = GLAttributeImpl_1.GLAttributeImpl.createFromValues(vertexBuf, 3, gl.FLOAT, 24, 0, 0);\n        const index = GLIndexImpl_1.GLIndexImpl.createFromValues(indexBuf, DataType_1.DataType.UNSIGNED_SHORT, Math.round(indexFaces.length * 1.5), 0);\n        const inst = {\n            positions: vertAttrib,\n            indices: index\n        };\n        return new ModelImpl_1.ModelImpl([inst]);\n    }\n    prepareSkybox() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const dim = this.hdr.dims.reduce((prev, cur) => Math.min(prev, cur));\n            const cubeBuffer = new SkyboxFramebuffer_1.SkyboxFramebuffer(this.getContext(), dim / 2);\n            const diffuseBuffer = new SkyboxFramebuffer_1.SkyboxFramebuffer(this.getContext(), 32);\n            const specBuffer = new SkyboxFramebuffer_1.SkyboxFramebuffer(this.getContext(), dim / 4);\n            yield this.hdrProg.getShaderFuture().wait();\n            yield this.renderSkybox(cubeBuffer, diffuseBuffer, specBuffer);\n        });\n    }\n    configureCubemapCoords(i, mat) {\n        mat.center[0] = 0;\n        mat.center[1] = 0;\n        mat.center[2] = 0;\n        mat.center[Math.floor(i / 2)] = (1 - (i % 2)) * 2 - 1;\n        // right:  [0, 0, 1], [0, 0, -1], [-1, 0, 0], [-1, 0, 0], [-1, 0, 0], [1, 0, 0]\n        mat.right[0] = (i < 2 ? 0 : (i === 5 ? 1 : -1));\n        mat.right[2] = (i < 2 ? (1 - (i % 2)) * 2 - 1 : 0);\n        // up:     [0, 1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1], [0, 1, 0], [0, 1, 0]\n        mat.up[2] = (i === 2 || i === 3 ? (i % 2) * 2 - 1 : 0);\n        mat.up[1] = (i === 2 || i === 3 ? 0 : 1);\n    }\n    renderSkybox(cubeBuffer, diffuseBuffer, specBuffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // draw our HDR onto each side of the texture\n            // use some SkyboxDisplay function to blast our HDR onto the side of the cubemap\n            const gl = this.getContext().getGLContext();\n            this.hdrProg.center = gl_matrix_1.vec3.create();\n            this.hdrProg.right = gl_matrix_1.vec3.create();\n            this.hdrProg.up = gl_matrix_1.vec3.create();\n            // cubeBuffer.setMipLevel(0);\n            for (let i = 0; i < 6; i++) {\n                cubeBuffer.bindFramebuffer(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n                gl.viewport(0, 0, cubeBuffer.dim, cubeBuffer.dim);\n                this.configureCubemapCoords(i, this.hdrProg);\n                this.hdrProg.drawTexture();\n            }\n            this.cubemap = cubeBuffer.getCubemap();\n            this.cubemap.generateMipmaps();\n            const diffuseMat = new CubemapToDiffuseIBLDisplay_1.CubemapToDiffuseIBLDisplay(this.getContext(), this.cubemap);\n            yield diffuseMat.waitUntilCompiled();\n            // render diffuse buffer\n            for (let i = 0; i < 6; i++) {\n                diffuseBuffer.bindFramebuffer(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n                gl.viewport(0, 0, diffuseBuffer.dim, diffuseBuffer.dim);\n                this.configureCubemapCoords(i, diffuseMat);\n                diffuseMat.draw();\n            }\n            this.cubemapDiffuse = diffuseBuffer.getCubemap();\n            this.cubemapDiffuse.generateMipmaps();\n            yield this.renderSpecularIBL(this.cubemap, specBuffer);\n        });\n    }\n    renderSpecularIBL(cube, specBuffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gl = this.getContext().getGLContext();\n            const specMat = new CubemapToSpecularIBLDisplay_1.CubemapToSpecularIBLDisplay(this.getContext(), this.cubemap);\n            yield specMat.waitUntilCompiled();\n            specMat.cubemapRes = cube.dims;\n            const mipLevels = 5;\n            let dim = specBuffer.dim;\n            let targ = specBuffer;\n            for (let i = 0; i < 5; i++) {\n                specMat.destRes = dim;\n                specMat.roughness = i / (mipLevels - 1);\n                if (!this.extMipmapRender) {\n                    // draw to temp fb (a bit dumb but for now its whatever)\n                    targ = new SkyboxFramebuffer_1.SkyboxFramebuffer(this.getContext(), dim);\n                }\n                else {\n                    targ = specBuffer;\n                    targ.setMipLevel(i);\n                }\n                gl.viewport(0, 0, dim, dim);\n                for (let j = 0; j < 6; j++) {\n                    targ.bindFramebuffer(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j);\n                    this.configureCubemapCoords(j, specMat);\n                    specMat.draw();\n                }\n                if (!this.extMipmapRender) {\n                    // copy from targ over to specbuffer\n                    const col = specBuffer.getCubemap();\n                    for (let j = 0; j < 6; j++) {\n                        targ.bindFramebuffer(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j);\n                        col.bindCubemap(gl.TEXTURE_CUBE_MAP, 0);\n                        gl.copyTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, 0, 0, 0, 0, dim, dim);\n                    }\n                }\n                dim = Math.round(dim / 2);\n            }\n            // if this is avail: we can use cubelod to fetch\n            // if not: we have to create several textures, and render to each one!\n            this.cubemapSpecular = specBuffer.getCubemap();\n            yield this.createBRDF();\n        });\n    }\n    createBRDF() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const gl = this.getContext().getGLContext();\n            const mat = new BRDFLutDisplay_1.BRDFLutDisplay(this.getContext());\n            yield mat.waitUntilCompiled();\n            const tex = new FloatColorTexture_1.FloatColorTexture(this.getContext(), [512, 512]);\n            const fb = gl.createFramebuffer();\n            const rb = new DepthStencilRenderbuffer_1.DepthStencilRenderbuffer(this.getContext(), [512, 512]);\n            rb.attachToFramebuffer(fb);\n            tex.attachToFramebuffer(fb, gl.COLOR_ATTACHMENT0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n            gl.viewport(0, 0, 512, 512);\n            mat.draw();\n            this.iblBRDF = tex;\n        });\n    }\n}\nexports.SkyboxObject = SkyboxObject;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/SkyboxObject.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/light/AmbientLightObject.ts":
/*!********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/light/AmbientLightObject.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmbientLightObject = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst GameObject_1 = __webpack_require__(/*! ../GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nclass AmbientLightObject extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        this.color = gl_matrix_1.vec4.fromValues(1.0, 1.0, 1.0, 1.0);\n        this.intensity = 0.3;\n    }\n}\nexports.AmbientLightObject = AmbientLightObject;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/light/AmbientLightObject.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts":
/*!*****************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpotLightObject = void 0;\nconst gl_matrix_1 = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/index.js\");\nconst ShadowFramebuffer_1 = __webpack_require__(/*! ../../../gl/internal/ShadowFramebuffer */ \"./hingler-party/client/ts/engine/gl/internal/ShadowFramebuffer.ts\");\nconst GameObject_1 = __webpack_require__(/*! ../GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\nconst TextureDummy_1 = __webpack_require__(/*! ../../../material/TextureDummy */ \"./hingler-party/client/ts/engine/material/TextureDummy.ts\");\nclass SpotLightObject extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n        // TODO: find some way to store consts like shadow map size across objects\n        this.fb = new ShadowFramebuffer_1.ShadowFramebuffer(ctx, [512, 512]);\n        this.fov = 45;\n        this.near = 0.1;\n        this.far = 1000.0;\n        this.falloffRadius = 1;\n        this.color = gl_matrix_1.vec4.create();\n        this.intensity = 1;\n        this.shadows = true;\n        this.atten_const = 1.0;\n        this.atten_linear = 0.0;\n        this.atten_quad = 0.0;\n        this.dummy = new TextureDummy_1.TextureDummy(ctx);\n    }\n    setShadowDims(dim_a, dim_b) {\n        // maintain a color texture for rendering\n        // i mean at that point we might as well manage the whole framebuffer here\n        let dims = (typeof dim_a === \"number\" ? [dim_a, dim_b] : dim_a);\n        if (dims[0] < 1 || dims[1] < 1) {\n            let err = \"Invalid values for shadow dimensions!\";\n            console.error(err);\n            throw Error(err);\n        }\n        if (dims[0] !== dims[1]) {\n            let err = \"Shadow texture must be square!\";\n            console.error(err);\n            throw Error(err);\n        }\n        else if ((dims[0] & (dims[0] - 1)) !== 0) {\n            let err = \"Dimensions must be power of two!\";\n            console.error(err);\n            throw Error(err);\n        }\n        this.fb.setFramebufferSize(dims);\n    }\n    getShadowDims() {\n        return Array.from(this.fb.dims);\n    }\n    getDirectionVector() {\n        let mat = this.getTransformationMatrix();\n        let dir = new Float32Array([0, 0, -1, 0]);\n        gl_matrix_1.vec4.transformMat4(dir, dir, mat);\n        gl_matrix_1.vec4.normalize(dir, dir);\n        return gl_matrix_1.vec3.fromValues(dir[0], dir[1], dir[2]);\n    }\n    getLightMatrix() {\n        let mat = this.getTransformationMatrix();\n        let res = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.copy(res, mat);\n        gl_matrix_1.mat4.invert(res, res);\n        let persp = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.perspective(persp, this.fov * (Math.PI / 180), 1, this.near, this.far);\n        gl_matrix_1.mat4.mul(res, persp, res);\n        return res;\n    }\n    /**\n     * @returns this light's perspective as a CameraInfo.\n     */\n    getLightMatrixAsCameraInfo() {\n        // zero, bc our transformation matrix will move it\n        let pos = gl_matrix_1.vec3.create();\n        gl_matrix_1.vec3.zero(pos);\n        gl_matrix_1.vec3.transformMat4(pos, pos, this.getTransformationMatrix());\n        let view = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.copy(view, this.getTransformationMatrix());\n        gl_matrix_1.mat4.invert(view, view);\n        let persp = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.perspective(persp, this.fov * (Math.PI / 180), 1, this.near, this.far);\n        let vp = gl_matrix_1.mat4.create();\n        gl_matrix_1.mat4.mul(vp, persp, view);\n        let info = {\n            viewMatrix: view,\n            perspectiveMatrix: persp,\n            vpMatrix: vp,\n            cameraPosition: pos\n        };\n        return info;\n    }\n    getShadowTexture() {\n        return this.fb.getDepthTexture();\n    }\n    setShadows(toggle) {\n        this.shadows = toggle;\n    }\n    getShadowState() {\n        return this.shadows;\n    }\n    _getShadowFramebuffer() {\n        return this.fb;\n    }\n}\nexports.SpotLightObject = SpotLightObject;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/game/light/SpotLightObject.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/scene/Scene.ts":
/*!**************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/scene/Scene.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst Task_1 = __webpack_require__(/*! ../../../../../ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst GameObjectRoot_1 = __webpack_require__(/*! ./internal/GameObjectRoot */ \"./hingler-party/client/ts/engine/object/scene/internal/GameObjectRoot.ts\");\n/**\n * Contains the contents of our level.\n * Scenes should expose a single root level component for the game view,\n * representing the root object of their scene. All other components\n * should be attached to this root.\n */\nclass Scene {\n    constructor() {\n        this.initialized = false;\n        this.gameRoot = null;\n        this.initFuture = new Task_1.Task();\n    }\n    /**\n     *\n     * @returns the root game object.\n     */\n    getGameObjectRoot() {\n        return this.gameRoot;\n    }\n    begininit(ctx) {\n        // no async loading in js\n        this.ctx = ctx;\n        this.gameRoot = new GameObjectRoot_1.GameObjectRoot(this.ctx);\n        this.initialize(this.ctx).then(() => {\n            this.initialized = true;\n            this.initFuture.resolve();\n        });\n    }\n    isInitialized() {\n        return this.initialized;\n    }\n    waitUntilInitialized() {\n        return this.initFuture.getFuture().wait();\n    }\n    isLoaded() {\n        if (this.initialized) {\n            return (this.ctx.getFileLoader().getFractionLoaded() >= 0.999);\n        }\n        return false;\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/scene/Scene.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/scene/internal/GameObjectRoot.ts":
/*!********************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/scene/internal/GameObjectRoot.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameObjectRoot = void 0;\nconst GameObject_1 = __webpack_require__(/*! ../../game/GameObject */ \"./hingler-party/client/ts/engine/object/game/GameObject.ts\");\n// special type of game object which exposes update funcs\nclass GameObjectRoot extends GameObject_1.GameObject {\n    constructor(ctx) {\n        super(ctx);\n    }\n    renderChildren(rc) {\n        this.renderfunc(rc);\n    }\n    callbackChildren(cb) {\n        this.childcallback(cb);\n    }\n    updateChildren() {\n        this.updatefunc();\n    }\n}\nexports.GameObjectRoot = GameObjectRoot;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/scene/internal/GameObjectRoot.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/object/scene/internal/SceneSwapImpl.ts":
/*!*******************************************************************************!*\
  !*** ./hingler-party/client/ts/engine/object/scene/internal/SceneSwapImpl.ts ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneSwapImpl = void 0;\nclass SceneSwapImpl {\n    /**\n     * Creates a new SceneSwap.\n     * @param newContext - the context which will eventually be associated with the associated scene.\n     * @param scene - the associated scene.\n     */\n    constructor(newContext, scene) {\n        this.newctx = newContext;\n        this.scene = scene;\n        this.swapReady = false;\n    }\n    getFractionLoaded() {\n        return this.newctx.getFileLoader().getFractionLoaded();\n    }\n    swap() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.scene.waitUntilInitialized();\n            this.swapReady = true;\n        });\n    }\n    // used by engine to swap in the new context\n    canSwap() {\n        return this.swapReady;\n    }\n}\nexports.SceneSwapImpl = SceneSwapImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/object/scene/internal/SceneSwapImpl.ts?");

/***/ }),

/***/ "./hingler-party/client/ts/engine/render/RenderContext.ts":
/*!****************************************************************!*\
  !*** ./hingler-party/client/ts/engine/render/RenderContext.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Passed to components on draw.\n * Contains information on the scene in general.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderPass = void 0;\n/**\n * Identifies which render pass we should run.\n */\nvar RenderPass;\n(function (RenderPass) {\n    RenderPass[RenderPass[\"SHADOW\"] = 0] = \"SHADOW\";\n    RenderPass[RenderPass[\"FINAL\"] = 1] = \"FINAL\";\n})(RenderPass = exports.RenderPass || (exports.RenderPass = {}));\n;\n;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/client/ts/engine/render/RenderContext.ts?");

/***/ }),

/***/ "./hingler-party/ts/performance.ts":
/*!*****************************************!*\
  !*** ./hingler-party/ts/performance.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.perf = void 0;\nexports.perf = (typeof performance === \"undefined\" ? Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'perf_hooks'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) : performance);\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/performance.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/MobileCheck.ts":
/*!**********************************************!*\
  !*** ./hingler-party/ts/util/MobileCheck.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mobileCheck = void 0;\n// http://detectmobilebrowsers.com/\nfunction mobileCheck() {\n    let check = false;\n    (function (a) { if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)))\n        check = true; })(navigator.userAgent || navigator.vendor);\n    return check;\n}\nexports.mobileCheck = mobileCheck;\n;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/MobileCheck.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/PingQueue.ts":
/*!********************************************!*\
  !*** ./hingler-party/ts/util/PingQueue.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PingQueue = void 0;\nclass PingQueue {\n    constructor(len) {\n        this.arr = [];\n        this.capacity = len;\n        this.ind = 0;\n    }\n    enqueue(ping) {\n        this.arr[this.ind++] = ping;\n        if (this.ind >= this.capacity) {\n            this.ind -= this.capacity;\n        }\n    }\n    getAverage() {\n        if (this.arr.length === 0) {\n            return NaN;\n        }\n        let coll = 0;\n        // prioritize newer data over older\n        return this.arr.reduce((acc, val, ind) => {\n            let wgt = Math.pow(0.8, (this.capacity - (ind - (this.ind - 1))) % this.capacity);\n            let res = acc + (val * wgt);\n            coll += wgt;\n            return res;\n        }, 0) / coll;\n    }\n}\nexports.PingQueue = PingQueue;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/PingQueue.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/StringToArrayBuffer.ts":
/*!******************************************************!*\
  !*** ./hingler-party/ts/util/StringToArrayBuffer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArrayBufferToString = exports.StringToArrayBuffer = void 0;\nconst enc = new TextEncoder();\nconst dec = new TextDecoder(\"utf-8\");\nfunction StringToArrayBuffer(s) {\n    let buf = new ArrayBuffer(s.length * 2);\n    let view = new DataView(buf);\n    return enc.encode(s);\n}\nexports.StringToArrayBuffer = StringToArrayBuffer;\nfunction ArrayBufferToString(arr) {\n    let dec = new TextDecoder(\"utf-8\");\n    return dec.decode(arr);\n}\nexports.ArrayBufferToString = ArrayBufferToString;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/StringToArrayBuffer.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/task/Future.ts":
/*!**********************************************!*\
  !*** ./hingler-party/ts/util/task/Future.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Future = void 0;\nclass Future {\n}\nexports.Future = Future;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/task/Future.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/task/Task.ts":
/*!********************************************!*\
  !*** ./hingler-party/ts/util/task/Task.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Task = void 0;\nconst FutureImpl_1 = __webpack_require__(/*! ./internal/FutureImpl */ \"./hingler-party/ts/util/task/internal/FutureImpl.ts\");\nclass Task {\n    constructor() {\n        this.future = new FutureImpl_1.FutureImpl();\n    }\n    getFuture() {\n        return this.future;\n    }\n    resolve(value) {\n        this.future.setValue(value);\n    }\n}\nexports.Task = Task;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/task/Task.ts?");

/***/ }),

/***/ "./hingler-party/ts/util/task/internal/FutureImpl.ts":
/*!***********************************************************!*\
  !*** ./hingler-party/ts/util/task/internal/FutureImpl.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FutureImpl = void 0;\nconst Future_1 = __webpack_require__(/*! ../Future */ \"./hingler-party/ts/util/task/Future.ts\");\nclass FutureImpl extends Future_1.Future {\n    constructor() {\n        super();\n        this.resolved = false;\n        this.value = null;\n        this.valuePromise = new Promise((res, rej) => {\n            this.res = res;\n            this.rej = rej;\n        });\n    }\n    valid() {\n        return (this.resolved === true);\n    }\n    wait() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.resolved) {\n                return Promise.resolve(this.value);\n            }\n            else {\n                yield this.valuePromise;\n                return this.value;\n            }\n        });\n    }\n    get() {\n        if (this.resolved) {\n            return this.value;\n        }\n        return null;\n    }\n    setValue(value) {\n        this.value = value;\n        this.resolved = true;\n        this.res();\n    }\n}\nexports.FutureImpl = FutureImpl;\n\n\n//# sourceURL=webpack://hingler-online/./hingler-party/ts/util/task/internal/FutureImpl.ts?");

/***/ }),

/***/ "./test/mapscenetest.ts":
/*!******************************!*\
  !*** ./test/mapscenetest.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MapSceneTest = void 0;\nconst GameWorldManagerSinglePlayer_1 = __webpack_require__(/*! ../client/ts/game/GameWorldManagerSinglePlayer */ \"./client/ts/game/GameWorldManagerSinglePlayer.ts\");\nconst Scene_1 = __webpack_require__(/*! ../hingler-party/client/ts/engine/object/scene/Scene */ \"./hingler-party/client/ts/engine/object/scene/Scene.ts\");\nclass MapSceneTest extends Scene_1.Scene {\n    initialize(ctx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            ctx.setContextVar(\"SHADER_FXAA_QUALITY\", 2, { shaderInteger: true });\n            let root = this.getGameObjectRoot();\n            const player = yield ctx.getGLTFLoader().loadAsGLTFScene(\"../res/chewingcharacter.glb\");\n            root.addChild(new GameWorldManagerSinglePlayer_1.GameWorldManagerSinglePlayer(ctx, player.getPBRModel(0)));\n        });\n    }\n}\nexports.MapSceneTest = MapSceneTest;\n\n\n//# sourceURL=webpack://hingler-online/./test/mapscenetest.ts?");

/***/ }),

/***/ "./test/stub/TileFactoryStub.ts":
/*!**************************************!*\
  !*** ./test/stub/TileFactoryStub.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileFactoryStub = void 0;\nconst Task_1 = __webpack_require__(/*! @hingler-party/ts/util/task/Task */ \"./hingler-party/ts/util/task/Task.ts\");\nconst BombTile_1 = __webpack_require__(/*! ../../client/ts/game/tile/generic/BombTile */ \"./client/ts/game/tile/generic/BombTile.ts\");\nconst CrateTile_1 = __webpack_require__(/*! ../../client/ts/game/tile/generic/CrateTile */ \"./client/ts/game/tile/generic/CrateTile.ts\");\nconst ExplosionTile_1 = __webpack_require__(/*! ../../client/ts/game/tile/generic/ExplosionTile */ \"./client/ts/game/tile/generic/ExplosionTile.ts\");\nconst KnightTile_1 = __webpack_require__(/*! ../../client/ts/game/tile/generic/KnightTile */ \"./client/ts/game/tile/generic/KnightTile.ts\");\nconst PowerupTile_1 = __webpack_require__(/*! ../../client/ts/game/tile/generic/PowerupTile */ \"./client/ts/game/tile/generic/PowerupTile.ts\");\nconst ExplosionInstanceFactory_1 = __webpack_require__(/*! ../../client/ts/game/tile/instancefactory/ExplosionInstanceFactory */ \"./client/ts/game/tile/instancefactory/ExplosionInstanceFactory.ts\");\nconst PowerupInstanceFactory_1 = __webpack_require__(/*! ../../client/ts/game/tile/instancefactory/PowerupInstanceFactory */ \"./client/ts/game/tile/instancefactory/PowerupInstanceFactory.ts\");\nconst TileID_1 = __webpack_require__(/*! ../../client/ts/game/tile/TileID */ \"./client/ts/game/tile/TileID.ts\");\nclass TileFactoryStub {\n    constructor(ctx) {\n        this.ctx = ctx;\n        // create instances for all desired tiles\n        this.crateFactory = null;\n        this.explosionFactory = null;\n        this.knight = null;\n        this.crab = null;\n        this.goat = new Task_1.Task();\n        this.pipebomb = new Task_1.Task();\n        this.speedPower = new Task_1.Task();\n        this.bombPower = new Task_1.Task();\n        this.radiusPower = new Task_1.Task();\n        // need a new tile class which accepts two models\n        // and handles spinning\n        this.powerupFactory = new Task_1.Task();\n        this.scenePromise = new Task_1.Task();\n        this.powerupPromise = new Task_1.Task();\n        ctx.getGLTFLoader().loadAsGLTFScene(\"../res/crate3d.glb\").then(this.configureCrateFactory.bind(this));\n        ctx.getGLTFLoader().loadAsGLTFScene(\"../res/powerups.glb\").then(this.configurePowerupFactory.bind(this));\n    }\n    ;\n    ;\n    configureCrateFactory(scene) {\n        // all factories will exist after scene promise is resolved\n        this.crateFactory = scene.getPBRInstanceFactory(\"Cube\");\n        this.explosionFactory = new ExplosionInstanceFactory_1.ExplosionInstanceFactory(this.ctx, scene.getInstancedModel(\"Sphere\"));\n        this.wallFactory = scene.getPBRInstanceFactory(\"Cube.001\");\n        this.bombFactory = scene.getPBRInstanceFactory(\"Bomb\");\n        this.knight = (scene.getPBRInstanceFactory(\"knight\"));\n        this.crab = scene.getPBRInstanceFactory(\"crab\");\n        this.goat.resolve(scene.getPBRInstanceFactory(\"goat\"));\n        this.pipebomb.resolve(scene.getPBRInstanceFactory(\"pipebomb\"));\n        this.scenePromise.resolve(scene);\n    }\n    configurePowerupFactory(scene) {\n        this.speedPower.resolve(scene.getPBRInstanceFactory(\"powerup_speed\"));\n        this.bombPower.resolve(scene.getPBRInstanceFactory(\"powerup_bomb\"));\n        this.radiusPower.resolve(scene.getPBRInstanceFactory(\"powerup_radius\"));\n        let powerupBase = scene.getInstancedModel(\"powerup_base\");\n        this.powerupFactory.resolve(new PowerupInstanceFactory_1.PowerupInstanceFactory(this.ctx, powerupBase));\n        this.powerupPromise.resolve(scene);\n    }\n    getTileFromID(id) {\n        if (id === 0) {\n            // air\n            return null;\n        }\n        else {\n            switch (id) {\n                case TileID_1.TileID.CRATE:\n                    return this.getCrate();\n                case TileID_1.TileID.EXPLOSION:\n                    return this.getExplosion();\n                case TileID_1.TileID.WALL:\n                    return this.getWall();\n                case TileID_1.TileID.BOMB:\n                    return this.getBomb();\n                case TileID_1.TileID.ENEMY_KNIGHT:\n                    return this.getKnight();\n                case TileID_1.TileID.ENEMY_CRAB:\n                    // cringe code\n                    // side note: if enemy is null, game crashes -- enemy should never be null, so its OK\n                    return this.getCrab();\n                case TileID_1.TileID.PIPE_BOMB:\n                    return new BombTile_1.BombTile(this.ctx, this.loadInstanceFromFactory(this.pipebomb.getFuture()));\n                case TileID_1.TileID.ENEMY_GOAT:\n                    return new KnightTile_1.KnightTile(this.ctx, this.loadInstanceFromFactory(this.goat.getFuture()));\n                case TileID_1.TileID.POWER_SPEED:\n                    return new PowerupTile_1.PowerupTile(this.ctx, this.getPowerupBaseFuture(), this.loadInstanceFromFactory(this.speedPower.getFuture()), id);\n                case TileID_1.TileID.POWER_BOMB:\n                    return new PowerupTile_1.PowerupTile(this.ctx, this.getPowerupBaseFuture(), this.loadInstanceFromFactory(this.bombPower.getFuture()), id);\n                case TileID_1.TileID.POWER_RADIUS:\n                    return new PowerupTile_1.PowerupTile(this.ctx, this.getPowerupBaseFuture(), this.loadInstanceFromFactory(this.radiusPower.getFuture()), id);\n                default:\n                    console.error(\"Encountered invalid TileID: \" + id);\n            }\n        }\n        return null;\n    }\n    getPowerupBaseFuture() {\n        let loadtask = new Task_1.Task();\n        let f = this.powerupFactory.getFuture();\n        if (f.valid()) {\n            loadtask.resolve(f.get().getInstance());\n        }\n        else {\n            this.powerupFactory.getFuture().wait().then((fac) => {\n                loadtask.resolve(fac.getInstance());\n            });\n        }\n        return loadtask.getFuture();\n    }\n    getCrate() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.crateFactory.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.crateFactory.getInstance());\n            });\n        }\n        return new CrateTile_1.CrateTile(this.ctx, loadtask.getFuture());\n    }\n    getExplosion() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.explosionFactory.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.explosionFactory.getInstance());\n            });\n        }\n        return new ExplosionTile_1.ExplosionTile(this.ctx, loadtask.getFuture());\n    }\n    getWall() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.wallFactory.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.wallFactory.getInstance());\n            });\n        }\n        return new CrateTile_1.CrateTile(this.ctx, loadtask.getFuture());\n    }\n    getBomb() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.bombFactory.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.bombFactory.getInstance());\n            });\n        }\n        return new BombTile_1.BombTile(this.ctx, loadtask.getFuture());\n    }\n    getKnight() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.knight.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.knight.getInstance());\n            });\n        }\n        return new KnightTile_1.KnightTile(this.ctx, loadtask.getFuture());\n    }\n    getCrab() {\n        let loadtask = new Task_1.Task();\n        if (this.scenePromise.getFuture().valid()) {\n            loadtask.resolve(this.crab.getInstance());\n        }\n        else {\n            this.scenePromise.future.wait().then((_) => {\n                loadtask.resolve(this.crab.getInstance());\n            });\n        }\n        return new KnightTile_1.KnightTile(this.ctx, loadtask.getFuture());\n    }\n    loadInstanceFromFactory(fac) {\n        let loadtask = new Task_1.Task();\n        if (fac.valid()) {\n            loadtask.resolve(fac.get().getInstance());\n        }\n        else {\n            fac.wait().then((resFac) => {\n                loadtask.resolve(resFac.getInstance());\n            });\n        }\n        return loadtask.getFuture();\n    }\n}\nexports.TileFactoryStub = TileFactoryStub;\n\n\n//# sourceURL=webpack://hingler-online/./test/stub/TileFactoryStub.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./client/ts/maptest.ts");
/******/ 	
/******/ })()
;